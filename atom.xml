<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[zxhfirefox's Blog]]></title>
  <link href="http://zxhfirefox.github.io/atom.xml" rel="self"/>
  <link href="http://zxhfirefox.github.io/"/>
  <updated>2014-11-17T23:28:12+08:00</updated>
  <id>http://zxhfirefox.github.io/</id>
  <author>
    <name><![CDATA[zxhfirefox]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Using Swift With Cocoa and Objective-C: Migration-Migrating Your ObjC Code to Swift]]></title>
    <link href="http://zxhfirefox.github.io/blog/2014/11/17/using-swift-with-objc-n-migration-migrating-your-objc-code-to-swift/"/>
    <updated>2014-11-17T23:24:58+08:00</updated>
    <id>http://zxhfirefox.github.io/blog/2014/11/17/using-swift-with-objc-n-migration-migrating-your-objc-code-to-swift</id>
    <content type="html"><![CDATA[<p>迁移，让我们有机会去重新审视现有的ObjC的app，我们可以使用Swift来替换其中的一部分来改进它的架构，逻辑和性能。直接来说，我们使用前面学得知识(混合与匹配，互用性)来一点点迁移我们的app。混合与匹配，让我们选择合适的部分来使用Swift重写，把剩下的留在ObjC。互用性让我们可以把这些新的特性在融会到ObjC里。使用这些工具来探索Swift丰富的功能，然后把这些在整合回ObjC得app，我们不需要一次性从头使用Swift写一个新的app。</p>

<h3>为了迁移修改ObjC的代码</h3>

<p>在我们迁移代码之前，确保我们的Swift和ObjC都有着最好的兼容性。这意味着需要整理和现代化我们现有的ObjC代码。我们现有的遵循现代化的ObjC代码会让迁移过程变得简单。如何现代化ObjC的代码，可以去看<a href="https://developer.apple.com/library/ios/releasenotes/ObjectiveC/ModernizationObjC/AdoptingModernObjective-C/AdoptingModernObjective-C.html#//apple_ref/doc/uid/TP40014150">这个文档</a>。</p>

<h3>迁移过程</h3>

<p>最高效的迁移过程是按照文件来做，一次迁移一个类。因为我们不能在ObjC里继承Swift的类，所以我们最好选择那些没有子类的类。我们用.swift文件来代替.h和.m文件。所有的接口和实现都在一个文件里。我们不需要创建头文件，Xcode会在我们需要引用时自动为我们创建一个头文件。</p>

<h4>开始之前</h4>

<ol>
<li>创建一个对应的.swift文件，我们可以使用和.m一样名字的也可以选择不一样的。类名字的前缀也是可选的。</li>
<li>导入相关的系统框架。</li>
<li>在ObjC桥接头文件里添加我们需要在Swift使用的ObjC文件。</li>
<li>为了让我们的Swift类在ObjC里可见和可用，我们要么让它继承自一个ObjC的类，要么标记为@objc。为了给出在ObjC里使用的一个名字，可以使用@objc(&lt;#name#>)，其中&lt;#name#>是我们在ObjC里要用来引用这类的名字。</li>
</ol>


<h4>迁移中</h4>

<ol>
<li>我们可以通过继承ObjC的类，实现ObjC的协议等等让我们Swift类可以整合ObjC的行为。</li>
<li>当我们使用ObjC的API时，我们需要知道Swift是如何把ObjC的API导入进来的。</li>
<li>当我们使用Cocoa框架时，记得有些类型Swift是桥接的，这意味着我们可以直接使用Swift类型。</li>
<li>当我们使用Cocoa框架时，我们需要使用Cocoa转换过来的常用设计模式。</li>
<li>当我们打算把ObjC的属性转到Swift时，读一下属性那篇文档。</li>
<li>使用@objc(&lt;#name#>)来给出在ObjC里使用时的名字。</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">var</span> <span class="nl">enabled</span><span class="p">:</span> <span class="n">Bool</span> <span class="p">{</span>
</span><span class='line'><span class="p">@</span><span class="n">objc</span><span class="p">(</span><span class="n">isEnabled</span><span class="p">)</span> <span class="n">get</span> <span class="p">{</span>
</span><span class='line'>    <span class="cm">/* ... */</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ol>
<li>把实例方法(-)和类方法(+)，转到对应的func和class func。</li>
<li>把简单的宏定义为常量，把复杂的宏定义为函数。</li>
</ol>


<h4>迁移结束后</h4>

<ol>
<li>在ObjC里，把头文件改成 #import &ldquo;ProductModuleName-Swift.h&#8221;。</li>
<li>从目标(target)里删掉原来的.m和.h文件，不需要删除文件。</li>
<li>我代码里的旧的ObjC的类的名字用Swift的名字替换掉。</li>
</ol>


<h3>注意和技巧</h3>

<p>尽管我们需要迁移的代码不尽相同，但是下面是一些通用的步骤和技巧。</p>

<ol>
<li>记得我们无法在ObjC里继承一个Swift类。因此，迁移的ObjC的类不能有子类。</li>
<li>迁移完毕一个类之后，从目标里把ObjC的类移除，避免编译错误(重复的符号)。</li>
<li>为了让Swift在ObjC中可用，Swift的类必须继承自ObjC的类，或是用@objc标记。</li>
<li>在ObjC使用Swift代码，记得有些Swift特性是无法转换到ObjC的。</li>
<li>cmd-click来查看一个Swift的类的生成的头文件。</li>
<li>option-click一个符号，来查看它的信息：类型，特性，文档注释。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using Swift With Cocoa and Objective-C: Mix and Match-Swift and ObjC in the Same Project]]></title>
    <link href="http://zxhfirefox.github.io/blog/2014/11/17/using-swift-with-objc-mix-and-match-swift-and-objc-in-same-project/"/>
    <updated>2014-11-17T23:22:01+08:00</updated>
    <id>http://zxhfirefox.github.io/blog/2014/11/17/using-swift-with-objc-mix-and-match-swift-and-objc-in-same-project</id>
    <content type="html"><![CDATA[<p>Swift和ObjC的互用性可以让我们在一个工程里包含这两种语言的源文件。我们可以使用这一特性，混合与匹配(Mix and Match)，来写出混合语言的代码。使用混合与匹配，我们可以把app部分的功能用最新的Swift特性来实现，又可以和已有的ObjC代码融合到一起。</p>

<!-- more -->


<h3>混合与匹配概述</h3>

<p>ObjC和Swift代码可以在一个项目同时存在，不管项目最开始是ObjC得还是Swift的。我们只需要给项目添加需要的文件即可。</p>

<p>使用混合语言编程的过程对于不同的编译目标是不一样的。下面我们会详细讲解。</p>

<p><img src="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/Art/DAG_2x.png" alt="" /></p>

<h3>同一个app目标的代码导入</h3>

<p>下面的部分说的流程适用于非框架的目标。</p>

<h4>把ObjC导入到Swift</h4>

<p>要把一部分ObjC的文件导入成Swift代码，我们需要使用ObjC桥接头文件(bridging header)来把这些文件暴露给Swift。当我们在添加一个ObjC文件到一个Swift工程或Swift文件到ObjC工程时，Xcode会提醒你来添加这样的ObjC桥接头文件。</p>

<p><img src="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/Art/bridgingheader_2x.png" alt="" /></p>

<p>如果我们接受，Xcode会创建一个头文件，他的名字是工程模块的名字加上&#8221;-Bridging-Header.h&#8221;。</p>

<p>我们也可以自己添加这个头文件。</p>

<p>我们需要编辑这个头文件来把ObjC暴露给Swift</p>

<p><strong><em>同一目标导入ObjC代码给Swift</em></strong></p>

<ol>
<li>在桥接头文件里添加所有我们需要暴露的ObjC的头文件。</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="cp">#import &quot;XYZCustomCell.h&quot;</span>
</span><span class='line'><span class="cp">#import &quot;XYZCustomView.h&quot;</span>
</span><span class='line'><span class="cp">#import &quot;XYZCustomViewController.h&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<ol>
<li>在编译设置里，确保这个ObjC桥接头文件在Swift的编译器-代码生成里有。这个路径应该是相对于工程路径的，和我们给出Info.plist路径一样。通常，我们不需要修改这个。</li>
</ol>


<p>任何在这个头文件里的公开的ObjC都会在Swift可用。ObjC的功能在这个目标里的任何Swift文件都可见，不需要其他导入操作。我们在Swift里用Swift的语法来使用ObjC代码。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">let</span> <span class="n">myCell</span> <span class="o">=</span> <span class="n">XYZCustomCell</span><span class="p">()</span>
</span><span class='line'><span class="n">myCell</span><span class="p">.</span><span class="n">subtitle</span> <span class="o">=</span> <span class="s">&quot;A custom cell&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<h4>把Swift导入ObjC</h4>

<p>当我们需要把Swift代码导入到ObjC时，我们需要使用Xcode为这些文件生成的头文件来在ObjC中使用。这些自动生成的头文件是我们把目标里Swift接口转换到ObjC的头文件。这个可以认为是我们Swift代码的囊括头文件(umbrella header)。这个文件的名字是我们模块的名字加上&#8221;-Swift.h&#8221;</p>

<p>默认的，生成的头文件包含了Swift里标记为public的声明。如果我们的工程包含一个ObjC桥接头文件，它也会包含了那些标记为internal的声明。private的声明就不会出现在这个头文件。除非private的声明同时标记为了@IBAction,@IBOutlet,@objc，否则他们不会暴露给ObjC。</p>

<p>我们不需要做额外的其他工作，只需要在我们的ObjC代码里导入这个头文件即可。注意，这个生成的头文件里的Swift接口包含了所有他们引用到的ObjC类型。如果我们在Swift代码里用到我们自己的ObjC类型，那么我们在需要访问Swift的ObjC的m文件里需要把这些ObjC的头文件先于Swift生成的头文件。</p>

<p><strong><em>同一目标导入Swift代码给ObjC</em></strong></p>

<p>在需要使用Swift的ObjC的.m文件里导入这个生成的头文件。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="cp">#import &quot;ProductModuleName-Swift.h&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>目标里的Swift文件就会在这个.m文件里可见。</p>

<pre><code>             导入Swift                 导入ObjC
Swift代码     不需要导入语句             #import "ProductModuleName-Swift.h"       
ObjC代码      不需要导入语句，           #import "Header.h"
             ObjC桥接头文件
</code></pre>

<h3>同一个框架目标的代码导入</h3>

<p>如果我们用多语言编写一个框架，我们也会需要在从ObjC访问Swift或是从Swift访问ObjC。</p>

<h4>把ObjC导入到Swift</h4>

<p>为了把同一个框架ObjC的部分代码暴露给Swift，我们需要把这些文件导入到框架的ObjC的囊括头文件(umbrella header).</p>

<p><strong><em>同一框架导入ObjC代码给Swift</em></strong></p>

<ol>
<li>在编译设置里的打包(Packaging)，确保为框架定义模块的设置是YES</li>
<li>在我们的囊括头文件(umbrella header)，导入我们需要暴露的ObjC头文件</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="cp">#import &lt;XYZ/XYZCustomCell.h&gt;</span>
</span><span class='line'><span class="cp">#import &lt;XYZ/XYZCustomView.h&gt;</span>
</span><span class='line'><span class="cp">#import &lt;XYZ/XYZCustomViewController.h&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>任何在这个头文件里的公开的ObjC都会在Swift可用。ObjC的功能在这个目标里的任何Swift文件都可见，不需要其他导入操作。我们在Swift里用Swift的语法来使用ObjC代码。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">let</span> <span class="n">myCell</span> <span class="o">=</span> <span class="n">XYZCustomCell</span><span class="p">()</span>
</span><span class='line'><span class="n">myCell</span><span class="p">.</span><span class="n">subtitle</span> <span class="o">=</span> <span class="s">&quot;A custom cell&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<h4>把Swift导入ObjC</h4>

<p>要把一个框架目标的Swift的部分文件导入到ObjC代码里，我们不需要在框架的囊括头文件(umbrella header)里导入任何东西。相反，我们需要在需要使用Swift的ObjC文件里导入Xcode产生的Swift头文件。</p>

<p>因为框架的产生的头文件是框架公开接口的一部分，所以只有标记为public的声明会出现在头文件里，但是在同一个框架里，我们在ObjC里使用那些Swift里面是internal的，并且是继承自ObjC的类的声明。</p>

<p><strong><em>同一框架导入Swift代码给ObjC</em></strong></p>

<ol>
<li>在编译设置里的打包(Packaging)，确保为框架定义模块的设置是YES</li>
<li>使用下面的语法和对应的名字把头文件导入到需要使用Swift的ObjC的.m文件里。</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="cp">#import &lt;ProductName/ProductModuleName-Swift.h&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>框架里的Swift文件就会在这个.m文件里可见。</p>

<pre><code>             导入Swift                 导入ObjC
Swift代码     不需要导入语句             #import &lt;ProductName/ProductModuleName-Swift.h&gt;       
ObjC代码      不需要导入语句，           #import "Header.h"
             需要ObjC囊括头文件
</code></pre>

<h3>导入外部框架</h3>

<p>我们可以导入来自外部的框架，不论它是一个语言写的还是多个语言写的。这个过程和使用的语言没有关系。但是，我们需要确认，导入的框架在编译时，定义模块的选项是YES。</p>

<p>在Swift里：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">import</span> <span class="n">FrameworkName</span>
</span></code></pre></td></tr></table></div></figure>


<p>在ObjC里：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">@</span><span class="n">import</span> <span class="n">FrameworkName</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<h3>在ObjC里使用Swift</h3>

<p>一旦我们在ObjC里导入了Swift代码，我们就可以用ObjC的语法来使用这些Swift的类。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">MySwiftClass</span> <span class="o">*</span><span class="n">swiftObject</span> <span class="o">=</span> <span class="p">[[</span><span class="n">MySwiftClass</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'><span class="p">[</span><span class="n">swiftObject</span> <span class="n">swiftMethod</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>Swift的类或协议必须标记为 @objc才能在ObjC中被使用。如果Swift的类是继承自ObjC的类，那么编译器会自动插入 @objc。</p>

<p>我们可以访问任何的标记为@objc的类和协议。除了下面这些：
1.  泛型
2.  元组
3.  Swift定义的枚举
4.  Swift定义的全局函数
5.  Swift定义的全局变量
6.  Swift定义的类型别名
7.  Swift风格的variadics
8.  嵌套的类型
9.  科里化(Curried)的函数</p>

<p>为了避免循环的引用，不要把Swift导入到ObjC的头文件。相反，我们可以前置声明一个Swift类用在头文件里。注意，我们不能在ObjC里继承Swift的类。</p>

<p><strong><em>在ObjC头文件里引用Swift类</em></strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@class</span> <span class="nc">MySwiftClass</span>;
</span><span class='line'><span class="k">@interface</span> <span class="nc">MyObjcClass</span> : <span class="bp">NSObject</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="n">MySwiftClass</span> <span class="o">*</span><span class="p">)</span><span class="nf">returnSwiftObject</span><span class="p">;</span>
</span><span class='line'><span class="cm">/* ... */</span>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<h3>命名我们的产品模块</h3>

<p>Xcode为Swift生成头文件和Xcode创建的ObjC桥接头文件的名字都依赖于我们的产品模块名。默认的，这个名字就是我们产品的名字。然而，如果我们的产品名字有不是字母数字字符的，例如 &ldquo;.&#8221;，会被取代为&rdquo; _ &ldquo;，如果由数字开头，第一个数字会被&rdquo; _ &ldquo;取代。</p>

<p>我们也可以给模块起自定义的名字，Xcode会使用这个。我们修改产品模块名的变异设置即可。</p>

<h3>注意和技巧</h3>

<ol>
<li>把ObjC和Swift文件想象为一套代码，注意命名冲突</li>
<li>如果在制作框架，注意把打包(Packaging)下面的定义模块(Defines Module)设为YES</li>
<li>如果在使用ObjC桥接头文件，这个头文件的路径必须在Swift编译器(Swift Compiler)-代码生成(Code Generation)-ObjC桥接头文件(Objective-C Bridging Header)的设置里。这个路径必须指向文件，而不是包含文件的目录。</li>
<li>Xcode使用产品模块名，而不是目标名，来命名我们的ObjC桥接头文件和Swift生成的头文件</li>
<li>要在ObjC中使用，Swift的类必须要么是ObjC类的子类，要么标记为@objc</li>
<li>当我们把Swift代码导入ObjC时，注意不是所有的Swift特性都可以在ObjC中使用</li>
<li>我们在ObjC里使用的Swift代码用到了我们自己其他的ObjC类型，我们需要把这些ObjC的头文件先于Swift的生成头文件导入到这个ObjC的.m文件里</li>
<li>Swift的private的声明不会出现在生成的头文件里。private的声明除非标记为@IBAction, @IBOutlet, 或 @objc，否则不会暴露给ObjC</li>
<li>如果目标是app，如果有ObjC桥接头文件，internal的声明就会出现在Swift生成的头文件里</li>
<li>如果目标是框架，只有public的声明会出现在Swift生成的头文件里。但是我们仍然可以在ObjC里使用Swift标记为internal的方法和属性，只要这些声明的类继承自ObjC。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using Swift With Cocoa and Objective-C: Interoperability-Interacting With C APIs]]></title>
    <link href="http://zxhfirefox.github.io/blog/2014/11/17/using-swift-with-objc-interoperability-y-interact-with-c/"/>
    <updated>2014-11-17T23:19:56+08:00</updated>
    <id>http://zxhfirefox.github.io/blog/2014/11/17/using-swift-with-objc-interoperability-y-interact-with-c</id>
    <content type="html"><![CDATA[<p>作为和ObjC互用性的一部分，Swift保留了一部分和C兼容的类型和特性。Swift也提供了一种和通用的C结构和模式的方法。</p>

<!-- more -->


<h3>基础类型</h3>

<p>Swift提供了和C一样的基础整数类型。然而，Swift并不提供默认的这些类型和Swift类型的自动转换，所以谨慎使用。</p>

<pre><code>C Type              Swift Type
bool                CBool
char,signed char    CChar
unsigned char       CUnsignedChar
short               CShort
unsigned short      CUnsignedShort
int                 CInt
unsigned int        CUnsignedInt
long                CLong
unsigned long       CUnsignedLong
long long           CLongLong
unsigned long long  CUnsignedLongLong
wchar_t             CWideChar
char16_t            CChar16
char32_t            CChar32
float               CFloat
double              CDouble
</code></pre>

<h3>枚举</h3>

<p>Swift会把所有的使用NS_ENUM的C枚举导入成一个Swift的枚举类型。这意味着枚举值的前缀会被截掉。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">//ObjC</span>
</span><span class='line'><span class="k">typedef</span> <span class="nf">NS_ENUM</span><span class="p">(</span><span class="bp">NSInteger</span><span class="p">,</span> <span class="n">UITableViewCellStyle</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>   <span class="n">UITableViewCellStyleDefault</span><span class="p">,</span>
</span><span class='line'>   <span class="n">UITableViewCellStyleValue1</span><span class="p">,</span>
</span><span class='line'>   <span class="n">UITableViewCellStyleValue2</span><span class="p">,</span>
</span><span class='line'>   <span class="n">UITableViewCellStyleSubtitle</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>到了Swift就变成了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">//Swift</span>
</span><span class='line'><span class="k">enum</span> <span class="nl">UITableViewCellStyle</span><span class="p">:</span> <span class="n">Int</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">Default</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">Value1</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">Value2</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">Subtitle</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>当我们引用一个枚举值时，在值的前面加一个 .</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">let</span> <span class="nl">cellStyle</span><span class="p">:</span> <span class="n">UITableViewCellStyle</span> <span class="o">=</span> <span class="p">.</span><span class="n">Default</span>
</span></code></pre></td></tr></table></div></figure>


<p>Swift也会导入被标记为NS_OPTIONS的options枚举值。这些枚举的值可以支持位操作符。</p>

<p>在ObjC里，我们使用0表示空的option。在Swift里，使用nil。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">let</span> <span class="n">myString</span> <span class="o">=</span> <span class="n">myData</span><span class="p">.</span><span class="n">base64EncodedStringWithOptions</span><span class="p">(</span><span class="nb">nil</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h3>指针</h3>

<p>在任何时候，Swift都会避免让我们直接访问指针。但是，仍然提供了一些指针类型供我们需要时使用。下面的Type是一个真实类型的占位符。</p>

<p>对于返回值，变量，参数，有下面的映射：</p>

<pre><code>C Syntax        Swift Syntax
const Type *    UnsafePointer&lt;Type&gt;
Type *          UnsafeMuatblePointer&lt;Type&gt;
</code></pre>

<p>对于类类型：</p>

<pre><code>C Syntax            Swift Syntax
Type * const *      UnsafePointer&lt;Type&gt;
Type * __strong *   UnsafeMutablePointer&lt;Type&gt;
Type **             AutoreleasingUnsafeMutablePointer&lt;Type&gt;
</code></pre>

<h4>常量指针</h4>

<p>当一个函数声明如果接受一个UnsafePointer<Type>的参数，它可以接受一下几种：
    *   nil，作为空指针传入
    *   一个UnsafePointer<Type>，UnsafeMutablePointer<Type>，AutoreleasingUnsafeMutablePointer<Type> 值，并转换到UnsafePointer<Type>。
    *   一个in-out表达式，它的操作数是一个Type的左值。作为操作数的地址传入。
    *   一个[Type]值，作为一个数组开始的指针传入，生命周期也是函数调用。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">func</span> <span class="nf">takesAPointer</span><span class="p">(</span><span class="nl">x</span><span class="p">:</span> <span class="n">UnsafePointer</span><span class="o">&lt;</span><span class="n">Float</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/*...*/</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们可以调用：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">var</span> <span class="nl">x</span><span class="p">:</span> <span class="n">Float</span> <span class="o">=</span> <span class="mf">0.0</span>
</span><span class='line'><span class="n">var</span> <span class="nl">p</span><span class="p">:</span> <span class="n">UnsafePointer</span><span class="o">&lt;</span><span class="n">Float</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nb">nil</span>
</span><span class='line'><span class="n">takesAPointer</span><span class="p">(</span><span class="nb">nil</span><span class="p">)</span>
</span><span class='line'><span class="n">takesAPointer</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
</span><span class='line'><span class="n">takesAPointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">)</span>
</span><span class='line'><span class="n">takesAPointer</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">])</span>
</span></code></pre></td></tr></table></div></figure>


<p>当一个函数接受一个UnsafePointer<Void>的参数，他可以接受任何的Type在UnsafePointer<Type>里可以接受的参数。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">func</span> <span class="nf">takesAVoidPointer</span><span class="p">(</span><span class="nl">x</span><span class="p">:</span> <span class="n">UnsafePointer</span><span class="o">&lt;</span><span class="n">Void</span><span class="o">&gt;</span><span class="p">)</span>  <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们可以调用：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">var</span> <span class="nl">x</span><span class="p">:</span> <span class="n">Float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="nl">y</span><span class="p">:</span> <span class="n">Int</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'><span class="n">var</span> <span class="nl">p</span><span class="p">:</span> <span class="n">UnsafePointer</span><span class="o">&lt;</span><span class="n">Float</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">,</span> <span class="nl">q</span><span class="p">:</span> <span class="n">UnsafePointer</span><span class="o">&lt;</span><span class="n">Int</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nb">nil</span>
</span><span class='line'><span class="n">takesAVoidPointer</span><span class="p">(</span><span class="nb">nil</span><span class="p">)</span>
</span><span class='line'><span class="n">takesAVoidPointer</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
</span><span class='line'><span class="n">takesAVoidPointer</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
</span><span class='line'><span class="n">takesAVoidPointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">)</span>
</span><span class='line'><span class="n">takesAVoidPointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">y</span><span class="p">)</span>
</span><span class='line'><span class="n">takesAVoidPointer</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">]</span> <span class="n">as</span> <span class="p">[</span><span class="n">Float</span><span class="p">])</span>
</span><span class='line'><span class="n">let</span> <span class="n">intArray</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</span><span class='line'><span class="n">takesAVoidPointer</span><span class="p">(</span><span class="n">intArray</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h4>可变指针</h4>

<p>当一个函数接受一个UnsafeMutablePointer<Type>的参数时，它可以接受下面的实参：
    *   nil作为空指针传入
    *   一个 UnsafeMutablePointer<Type> 值
    *   一个in-out表达式，它的操作数是一个Type的左值。作为操作数的地址传入
    *   一个[Type]值，作为一个数组开始的指针传入，生命周期也是函数调用</p>

<p>例如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">func</span> <span class="nf">takesAMutablePointer</span><span class="p">(</span><span class="nl">x</span><span class="p">:</span> <span class="n">UnsafeMutablePointer</span><span class="o">&lt;</span><span class="n">Float</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/*...*/</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>下面的调用都可以：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">var</span> <span class="nl">x</span><span class="p">:</span> <span class="n">Float</span> <span class="o">=</span> <span class="mf">0.0</span>
</span><span class='line'><span class="n">var</span> <span class="nl">p</span><span class="p">:</span> <span class="n">UnsafeMutablePointer</span><span class="o">&lt;</span><span class="n">Float</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nb">nil</span>
</span><span class='line'><span class="n">var</span> <span class="nl">a</span><span class="p">:</span> <span class="p">[</span><span class="n">Float</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">]</span>
</span><span class='line'><span class="n">takesAMutablePointer</span><span class="p">(</span><span class="nb">nil</span><span class="p">)</span>
</span><span class='line'><span class="n">takesAMutablePointer</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
</span><span class='line'><span class="n">takesAMutablePointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">)</span>
</span><span class='line'><span class="n">takesAMutablePointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>当一个函数接受一个UnsafeMutablePointer <Void>的参数，他可以接受任何的Type在UnsafeMutablePointer <Type>里可以接受的参数。</p>

<p>例如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">func</span> <span class="nf">takesAMutableVoidPointer</span><span class="p">(</span><span class="nl">x</span><span class="p">:</span> <span class="n">UnsafeMutablePointer</span><span class="o">&lt;</span><span class="n">Void</span><span class="o">&gt;</span><span class="p">)</span>  <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>下面的调用都可以：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">var</span> <span class="nl">x</span><span class="p">:</span> <span class="n">Float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="nl">y</span><span class="p">:</span> <span class="n">Int</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'><span class="n">var</span> <span class="nl">p</span><span class="p">:</span> <span class="n">UnsafeMutablePointer</span><span class="o">&lt;</span><span class="n">Float</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">,</span> <span class="nl">q</span><span class="p">:</span> <span class="n">UnsafeMutablePointer</span><span class="o">&lt;</span><span class="n">Int</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nb">nil</span>
</span><span class='line'><span class="n">var</span> <span class="nl">a</span><span class="p">:</span> <span class="p">[</span><span class="n">Float</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">],</span> <span class="nl">b</span><span class="p">:</span> <span class="p">[</span><span class="n">Int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</span><span class='line'><span class="n">takesAMutableVoidPointer</span><span class="p">(</span><span class="nb">nil</span><span class="p">)</span>
</span><span class='line'><span class="n">takesAMutableVoidPointer</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
</span><span class='line'><span class="n">takesAMutableVoidPointer</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
</span><span class='line'><span class="n">takesAMutableVoidPointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">)</span>
</span><span class='line'><span class="n">takesAMutableVoidPointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">y</span><span class="p">)</span>
</span><span class='line'><span class="n">takesAMutableVoidPointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">)</span>
</span><span class='line'><span class="n">takesAMutableVoidPointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h4>自动释放的指针</h4>

<p>当一个函数接受一个AutoreleasingUnsafeMutablePointer <Type>的参数时，它可以接受下面的实参：
    *   nil作为空指针传入
    *   一个 AutoreleasingUnsafeMutablePointer <Type> 值
    *   一个in-out表达式，它的操作数是基础类型被拷贝的临时的非拥有的buffer。这个buffer的地址被传递给被调用函数，然后在返回时，这个buffer的值被加载，保留(retained)，并且赋值给这个操作数</p>

<p>注意，没有数组。</p>

<p>例如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">func</span> <span class="nf">takesAnAutoreleasingPointer</span><span class="p">(</span><span class="nl">x</span><span class="p">:</span> <span class="n">AutoreleasingUnsafeMutablePointer</span><span class="o">&lt;</span><span class="bp">NSDate</span><span class="o">?&gt;</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>下面的调用都可以：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">var</span> <span class="nl">x</span><span class="p">:</span> <span class="bp">NSDate</span><span class="o">?</span> <span class="o">=</span> <span class="nb">nil</span>
</span><span class='line'><span class="n">var</span> <span class="nl">p</span><span class="p">:</span> <span class="n">AutoreleasingUnsafeMutablePointer</span><span class="o">&lt;</span><span class="bp">NSDate</span><span class="o">?&gt;</span> <span class="o">=</span> <span class="nb">nil</span>
</span><span class='line'><span class="n">takesAnAutoreleasingPointer</span><span class="p">(</span><span class="nb">nil</span><span class="p">)</span>
</span><span class='line'><span class="n">takesAnAutoreleasingPointer</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
</span><span class='line'><span class="n">takesAnAutoreleasingPointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>被指向的类型是不会被桥接的。例如，NSString** 转到Swift就成了AutoreleasingUnsafeMutablePointer&lt;NSString?>而不是AutoreleasingUnsafeMutablePointer&lt;String?>。</p>

<h4>函数指针</h4>

<p>C的函数指针在Swift里成了CFunctionPointer<Type>，而Type是一个Swift函数类型。例如，一个C里的函数指针是 int (*)(void)类型的，转到Swift就变成了CFunctionPointer&lt;() -> Int32>。</p>

<h3>全局常量</h3>

<p>在C和ObjC定义的全局常量会被自动导入为Swift全局常量。</p>

<h3>预编译指令</h3>

<p>Swift编译器并不包含预编译器。相反，它使用一些编译期的属性，编译配置和语言特性来完成类似的功能。因此，预编译指令在Swift里并没有被实现。</p>

<h4>简单的宏</h4>

<p>通常我们在C和ObjC里用#define来定义的宏，在Swift都应该用全局常量代替。例如，#define FADE_ANIMATION_DURATION 0.35 在Swift里表示为let FADE_ANIMATION_DURATION = 0.35 更好。这样简单的宏会被导入为全局常量。</p>

<h4>复杂的宏</h4>

<p>在C和ObjC里使用的复杂的宏在Swift里没有替代品。复杂的宏是指那些没有定义常量的，包括使用参数的，类似于函数的宏。我们在C和ObjC里使用复杂的宏是为了避免类型检查的限制或者避免大量重复的代码。然而，宏会增加我们bebug和重构的复杂度。在Swift里，我们可以使用函数和泛型来达到同样的目的。因此，在C和ObjC的复杂的宏在Swift里不可用。</p>

<h4>编译配置</h4>

<p>Swift和ObjC代码通过不同的方式编译。Swift代码可以根据编译配置的值来条件编译。编译配置包含了字面的true和false，命令行flag，还有下面的平台检测函数。我们可以使用-D &lt;#flag#>。</p>

<pre><code>函数                  参数
os()                  OS X,iOS
arch()                x86_64,arm,arm64,i386


注意
arch(arm)的结果对于arm64的设备返回是false。arch(i386)对于32位iOS模拟器返回true。
</code></pre>

<p>一个简单的条件编译：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="cp">#if build configuration</span>
</span><span class='line'>    <span class="n">statements</span>
</span><span class='line'><span class="cp">#else</span>
</span><span class='line'>    <span class="n">statements</span>
</span><span class='line'><span class="cp">#endif</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们也可以使用||，&amp;&amp;，和 ！来写出复杂的条件编译。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="cp">#if build configuration &amp;&amp; !build configuration</span>
</span><span class='line'>    <span class="n">statements</span>
</span><span class='line'><span class="cp">#elseif build configuration</span>
</span><span class='line'>    <span class="n">statements</span>
</span><span class='line'><span class="cp">#else</span>
</span><span class='line'>    <span class="n">statements</span>
</span><span class='line'><span class="cp">#endif</span>
</span></code></pre></td></tr></table></div></figure>


<p>和C里的条件编译不一样，Swift里条件编译的代码部分必须是完整独立且语法正确的代码块。因为所有的Swift代码都会做语法检查，即使它在条件编译的时候不会编译。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using Swift With Cocoa and Objective-C: Interoperability-Adopting Cocoa Design Patterns]]></title>
    <link href="http://zxhfirefox.github.io/blog/2014/11/17/using-swift-with-objc-interoperability-y-adopting-cocoa-design-patterns/"/>
    <updated>2014-11-17T23:18:39+08:00</updated>
    <id>http://zxhfirefox.github.io/blog/2014/11/17/using-swift-with-objc-interoperability-y-adopting-cocoa-design-patterns</id>
    <content type="html"><![CDATA[<p>使用Cocoa已经建立好的设计模式可以帮助我们写出良好设计的app。许多的这种模式都依赖ObjC里定义的类。因为Swift和ObjC可以互相调用，所以我们可以在Swift里使用ObjC的模式。在很多情况下，我们可以使用Swift的特性来简化或扩展现有的Cocoa模式，让他们更加强大，更加有用。</p>

<!-- more -->


<h3>代理</h3>

<p>在Swift和ObjC里，代理通常使用一个定义了一些要求的协议和一个实现了协议的代理属性来表达。和在ObjC里一样，在我们给一个可能不存在的代理发消息时，我们询问代理是否响应这个selector。在Swift里，我们可以用optional链条来调用一个可能是nil的对象上的一个可选的方法，然后用if-let语法来检查返回的结果。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">class</span> <span class="nl">MyDelegate</span><span class="p">:</span> <span class="bp">NSObject</span><span class="p">,</span> <span class="n">NSWindowDelegate</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">func</span> <span class="n">window</span><span class="p">(</span><span class="n">NSWindow</span><span class="p">,</span> <span class="n">willUseFullScreenContentSize</span> <span class="nl">proposedSize</span><span class="p">:</span> <span class="n">NSSize</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NSSize</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">proposedSize</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">var</span> <span class="nl">myDelegate</span><span class="p">:</span> <span class="n">NSWindowDelegate</span><span class="o">?</span> <span class="o">=</span> <span class="n">MyDelegate</span><span class="p">()</span>
</span><span class='line'><span class="k">if</span> <span class="n">let</span> <span class="n">fullScreenSize</span> <span class="o">=</span> <span class="n">myDelegate</span><span class="o">?</span><span class="p">.</span><span class="n">window</span><span class="o">?</span><span class="p">(</span><span class="n">myWindow</span><span class="p">,</span> <span class="nl">willUseFullScreenContentSize</span><span class="p">:</span> <span class="n">mySize</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="n">NSStringFromSize</span><span class="p">(</span><span class="n">fullScreenSize</span><span class="p">))</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们先检查myDelegate是不是nil，检查myDelegate是否实现了window:willUseFullScreenContentSize:方法，如果都是true，调用方法，返回一个对象叫fullScreenSize。</p>

<h3>错误报告</h3>

<p>Swift里错误报告的模式和ObjC的一样，使用可选的返回值。在最简单的情况下，我们返回Bool值来表示函数调用成功与否。如果我们需要返回错误信息，我们添加一个out的NSError参数，类型是NSErrorPointer。这个类型基本和ObjC的 NSError** 类似，但是由额外的内存安全和optional typing。我们使用 &amp; 来传入一个optional的NSError类型给NSErrorPointer。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">var</span> <span class="nl">writeError</span><span class="p">:</span> <span class="bp">NSError</span><span class="o">?</span>
</span><span class='line'><span class="n">let</span> <span class="n">written</span> <span class="o">=</span> <span class="n">myString</span><span class="p">.</span><span class="n">writeToFile</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="nl">atomically</span><span class="p">:</span> <span class="nb">false</span><span class="p">,</span>
</span><span class='line'>    <span class="nl">encoding</span><span class="p">:</span> <span class="n">NSUTF8StringEncoding</span><span class="p">,</span>
</span><span class='line'>    <span class="nl">error</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">writeError</span><span class="p">)</span>
</span><span class='line'><span class="k">if</span> <span class="o">!</span><span class="n">written</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">let</span> <span class="n">error</span> <span class="o">=</span> <span class="n">writeError</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">println</span><span class="p">(</span><span class="s">&quot;write failure: \(error.localizedDescription)&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>当我们自己实现函数，需要提供错误报告时，我们把一个NSError对象设置到NSErrorPointer的memory属性。确保调用者给我们传入了一个不是nil的NSErrorPointer对象：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">func</span> <span class="nf">contentsForType</span><span class="p">(</span><span class="nl">typeName</span><span class="p">:</span> <span class="n">String</span><span class="o">!</span><span class="p">,</span> <span class="nl">error</span><span class="p">:</span> <span class="n">NSErrorPointer</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AnyObject</span><span class="o">!</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">cannotProduceContentsForType</span><span class="p">(</span><span class="n">typeName</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="n">error</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">error</span><span class="p">.</span><span class="n">memory</span> <span class="o">=</span> <span class="bp">NSError</span><span class="p">(</span><span class="nl">domain</span><span class="p">:</span> <span class="n">domain</span><span class="p">,</span> <span class="nl">code</span><span class="p">:</span> <span class="n">code</span><span class="p">,</span> <span class="nl">userInfo</span><span class="p">:</span> <span class="p">[</span><span class="o">:</span><span class="p">])</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">return</span> <span class="nb">nil</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="c1">// ...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>KVO</h3>

<p>KVO是一种可以让对象在其他对象某个属性变化时接到通知的一种方式。只要我们的Swift类继承自NSObject，我们就能在这个类上使用KVO。我们需要三步来实现KVO。</p>

<ol>
<li>在我们想观察的属性前面加上dynamic。</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">class</span> <span class="nl">MyObjectToObserve</span><span class="p">:</span> <span class="bp">NSObject</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">dynamic</span> <span class="n">var</span> <span class="n">myDate</span> <span class="o">=</span> <span class="bp">NSDate</span><span class="p">()</span>
</span><span class='line'>    <span class="n">func</span> <span class="n">updateDate</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">myDate</span> <span class="o">=</span> <span class="bp">NSDate</span><span class="p">()</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ol>
<li>创建一个全局的private的上下文变量。</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">private</span> <span class="n">var</span> <span class="n">myContext</span> <span class="o">=</span> <span class="mi">0</span>
</span></code></pre></td></tr></table></div></figure>


<ol>
<li>添加一个观察者，重写observeValueForKeyPath:ofObject:change:context:，然后在deinit里移除观察者。</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">class</span> <span class="nl">MyObserver</span><span class="p">:</span> <span class="bp">NSObject</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">var</span> <span class="n">objectToObserve</span> <span class="o">=</span> <span class="n">MyObjectToObserve</span><span class="p">()</span>
</span><span class='line'>    <span class="n">override</span> <span class="n">init</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="nb">super</span><span class="p">.</span><span class="n">init</span><span class="p">()</span>
</span><span class='line'>        <span class="n">objectToObserve</span><span class="p">.</span><span class="n">addObserver</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="nl">forKeyPath</span><span class="p">:</span> <span class="s">&quot;myDate&quot;</span><span class="p">,</span> <span class="nl">options</span><span class="p">:</span> <span class="p">.</span><span class="n">New</span><span class="p">,</span> <span class="nl">context</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">myContext</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">override</span> <span class="n">func</span> <span class="n">observeValueForKeyPath</span><span class="p">(</span><span class="nl">keyPath</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span> <span class="n">ofObject</span> <span class="nl">object</span><span class="p">:</span> <span class="n">AnyObject</span><span class="p">,</span> <span class="nl">change</span><span class="p">:</span> <span class="p">[</span><span class="nl">NSObject</span><span class="p">:</span> <span class="n">AnyObject</span><span class="p">],</span> <span class="nl">context</span><span class="p">:</span> <span class="n">UnsafeMutablePointer</span><span class="o">&lt;</span><span class="n">Void</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="n">context</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">myContext</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">println</span><span class="p">(</span><span class="s">&quot;Date changed: \(change[NSKeyValueChangeNewKey])&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>            <span class="nb">super</span><span class="p">.</span><span class="n">observeValueForKeyPath</span><span class="p">(</span><span class="n">keyPath</span><span class="p">,</span> <span class="nl">ofObject</span><span class="p">:</span> <span class="n">object</span><span class="p">,</span> <span class="nl">change</span><span class="p">:</span> <span class="n">change</span><span class="p">,</span> <span class="nl">context</span><span class="p">:</span> <span class="n">context</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">deinit</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">objectToObserve</span><span class="p">.</span><span class="n">removeObserver</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="nl">forKeyPath</span><span class="p">:</span> <span class="s">&quot;myDate&quot;</span><span class="p">,</span> <span class="nl">context</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">myContext</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>目标-动作</h3>

<p>目标-动作是一种通用的模式，他可以让一个对象在某个特定事件发生时给另外一个对象发消息。它在ObjC和Swift里是很相似的。在Swift里，我们用Selector类型来代表ObjC的selectors。</p>

<h3>Introspection(自省)</h3>

<p>在ObjC里，我们用isKindOfClass:来检查一个对象是否是某个类以及它子类的实例(注：这里，苹果文档是错的= =)，用conformsToProtocol:来检查对象是否实现了某个协议。在Swift里，我们用is 来检查类型，用 as? 来向下转换一个类型。</p>

<p>我们用is来检查一个实例是否是一个类的实例：(注：这里不明确是类本身还是子类也可以，所以我做了实现，是子类也可以。应该说成，用 is 来判断一个比较广泛的类的实例是否是这个广泛类的某一个子类的实例)。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">if</span> <span class="n">object</span> <span class="n">is</span> <span class="bp">UIButton</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// object is of type UIButton</span>
</span><span class='line'><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// object is not of type UIButton</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>注：下面是我测试的代码。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">import</span> <span class="n">UIKit</span>
</span><span class='line'><span class="k">class</span> <span class="nl">ParentView</span> <span class="p">:</span> <span class="bp">UIView</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">class</span> <span class="nl">ChildView</span> <span class="p">:</span> <span class="n">ParentView</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">let</span> <span class="nl">view</span> <span class="p">:</span> <span class="bp">UIView</span> <span class="o">=</span> <span class="n">ChildView</span><span class="p">()</span> <span class="c1">//我们必须给出view的类型，如果自动推导，它就是ChildView类型，下面的代码就会报错。</span>
</span><span class='line'><span class="k">if</span> <span class="n">view</span> <span class="n">is</span> <span class="n">ParentView</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="c1">// true</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">if</span> <span class="n">view</span> <span class="n">is</span> <span class="n">ChildView</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="c1">// true</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们也可以用 as? 来尝试把一个实例向下转换到一个子类的类型。as?返回一个optional的对象，然后用if-let语句来检查结果。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">if</span> <span class="n">let</span> <span class="n">button</span> <span class="o">=</span> <span class="n">object</span> <span class="n">as</span><span class="o">?</span> <span class="bp">UIButton</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// object is successfully cast to type UIButton and bound to button</span>
</span><span class='line'><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// object could not be cast to type UIButton</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>检查是否实现协议和检查是否是类的实例是一样的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">if</span> <span class="n">let</span> <span class="n">dataSource</span> <span class="o">=</span> <span class="n">object</span> <span class="n">as</span><span class="o">?</span> <span class="bp">UITableViewDataSource</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// object conforms to UITableViewDataSource and is bound to dataSource</span>
</span><span class='line'><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// object not conform to UITableViewDataSource</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意，上面的dataSource是UITableViewDataSource的对象，如果我想调用它的其他方法(不是UITableViewDataSource定义的方法)，我们需要把它们在转换到其他类型来调用。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using Swift With Cocoa and Objective-C: Interoperability-Working With Cocoa Data Types]]></title>
    <link href="http://zxhfirefox.github.io/blog/2014/11/17/using-swift-with-objc-interoperability-x-working-with-cocoa-data-types/"/>
    <updated>2014-11-17T23:17:29+08:00</updated>
    <id>http://zxhfirefox.github.io/blog/2014/11/17/using-swift-with-objc-interoperability-x-working-with-cocoa-data-types</id>
    <content type="html"><![CDATA[<p>作为与ObjC互用性的一部分，Swift提供了方便和高效的方法来处理Cocoa的数据类型。</p>

<p>Swift自动的在Swift和ObjC之间互相转换一些类型。还有一些类型是Swift和ObjC通用的。这两种数据类型一般叫做桥接数据类型(bridged data types)。例如，我们可以把Array传递给一个需要NSArray的方法。我们也可以在桥接类型之间互相转换，用 as 或是直接给出变量或常量的值。</p>

<p>Swift也提供了一些方便的包裹来使得我们可以方便，统一和Foundation的数据类型交互。</p>

<!-- more -->


<h3>字符串</h3>

<p>Swift会自动在String和NSString之间转换。这意味着在任何时候你需要一个NSString的时候，你都可以直接给一个String。这样我们即可以使用Swift的字符串插入(string interpolation)，也可以使用Swift和NSString提供的众多API。所以，我们基本上不需要在我们的代码里使用NSString。事实上，当Swift导入ObjC的API时，它把所有的NSString都替换成了String，而当ObjC使用Swift时，所有的String都替换成了NSString。</p>

<p>要打开字符串桥接(bridging)，只需要导入Foundation。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">import</span> <span class="n">Foundation</span>
</span><span class='line'><span class="n">let</span> <span class="n">greeting</span> <span class="o">=</span> <span class="s">&quot;hello, world!&quot;</span>
</span><span class='line'><span class="n">let</span> <span class="n">capitalizedGreeting</span> <span class="o">=</span> <span class="n">greeting</span><span class="p">.</span><span class="n">capitalizedString</span>
</span><span class='line'><span class="c1">// capitalizedGreeting: String = Hello, World!</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果我们确实需要使用NSString对象，我们可以把一个String转换到NSString。因为String和NSString总是可以互相转换，所以我们不需要使用 as?，而是直接使用 as。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">import</span> <span class="n">Foundation</span>
</span><span class='line'><span class="n">let</span> <span class="nl">myString</span><span class="p">:</span> <span class="bp">NSString</span> <span class="o">=</span> <span class="s">&quot;123&quot;</span>
</span><span class='line'><span class="k">if</span> <span class="n">let</span> <span class="n">integerValue</span> <span class="o">=</span> <span class="p">(</span><span class="n">myString</span> <span class="n">as</span> <span class="n">String</span><span class="p">).</span><span class="n">toInt</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="s">&quot;\(myString) is the integer \(integerValue)&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>本地化</h4>

<p>在ObjC里，我们使用NSLocalizedString系列的宏来本地化字符串。这一系列宏包括了NSLocalizedString，NSLocalizedStringFromTable，NSLocalizedStringFromTableInBundle，NSLocalizedStringWithDefaultValue。在Swift里，我们使用一个函数来处理所有这些：NSLocalizedString(key:tableName:bundle:value:comment:)。这个函数的tableName，bundle，value有默认值。</p>

<h3>数字</h3>

<p>Swift自动在特定的数字类型之间互相桥接。例如Int，Float和NSNumber。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">let</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">42</span>
</span><span class='line'><span class="n">let</span> <span class="nl">m</span><span class="p">:</span> <span class="bp">NSNumber</span> <span class="o">=</span> <span class="n">n</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们也可以在需要NSNumber的地方传入一个Int。注意，因为NSNumber可以包含很多类型的值，所以我们不能随便传递其他类型的值。</p>

<p>下面的类型都会自动桥接到NSNumber：
    *   Int
    *   UInt
    *   Float
    *   Double
    *   Bool</p>

<h3>集合类</h3>

<p>Swift自动把NSArray和NSDictionary和他们Swift对应的相互转换。这样我们就即可以使用Swift的优秀算法和语法，也可以使用Foundation和Swift的集合互相交互。</p>

<h4>数组</h4>

<p>Swift自动在Array和NSArray之间互相转换。当我们把NSArray转换到Swift数组时，结果的类型是[AnyObject]。一个AnyObject的对象和OjbC或Swift的对象都兼容，或者可以被桥接到另外一个。我们可以把任何NSArray对象桥接到Swift数组，因为所有的ObjC对象都和AnyObject兼容。因为这个，所以Swift编译器在导入ObjC的API时会把所有NSArray替换成[AnyObject]。</p>

<p>在我们把NSArray桥接到Swift数组后，我们可以进一步把它向下转换到特定的类型。不像把NSArray转换到[AnyObject]，把AnyObject转换到特定类型不是一定成功的。编译器知道运行时才能确定数组里的元素是否能成功转换到特定类型。所以，把[AnyObject]转换到[SomeType]返回一个optional的值。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">let</span> <span class="n">swiftArray</span> <span class="o">=</span> <span class="n">foundationArray</span> <span class="n">as</span> <span class="p">[</span><span class="n">AnyObject</span><span class="p">]</span>
</span><span class='line'><span class="k">if</span> <span class="n">let</span> <span class="n">downcastedSwiftArray</span> <span class="o">=</span> <span class="n">swiftArray</span> <span class="n">as</span><span class="o">?</span> <span class="p">[</span><span class="bp">UIView</span><span class="p">]</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// downcastedSwiftArray contains only UIView objects</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们也可以在for-in循环里直接转换：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">for</span> <span class="n">aView</span> <span class="k">in</span> <span class="n">foundationArray</span> <span class="n">as</span> <span class="p">[</span><span class="bp">UIView</span><span class="p">]</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// aView is of type UIView</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<pre><code>注意
这里是强制转换，如果不成功，会造成运行时错误。
</code></pre>

<p>当我们把一个Swift数组转换到NSArray时，Swift数组的元素必须是AnyObject兼容的类型。例如，一个数组[Int],包含Int，但是Int不是类，所以和AnyObject不兼容，但是，Int会自动桥接到NSNumber，所以最后Int是AnyObject兼容的。因此，我们可以把一个[Int]的数组转换到NSArray。如果一个Swift数组里的元素不是AnyObject兼容的，那么转换时会造成运行时错误。</p>

<p>我们也可以直接从Swift数组字面量来创建一个NSArray，这种方式也遵循上面的规则。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">let</span> <span class="nl">schoolSupplies</span><span class="p">:</span> <span class="bp">NSArray</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;Pencil&quot;</span><span class="p">,</span> <span class="s">&quot;Eraser&quot;</span><span class="p">,</span> <span class="s">&quot;Notebook&quot;</span><span class="p">]</span>
</span><span class='line'><span class="c1">// schoolSupplies is an NSArray object containing NSString objects</span>
</span></code></pre></td></tr></table></div></figure>


<p>当我们在ObjC中使用Swift的类或协议时，导入器会把所有的Swift数组类型转换到NSArray。如果给Swift的API提供了一个NSArray，但是元素类型不对，会造成运行时错误，如果一个Swift的API返回一个Swift的数组，却不能转换到NSArray，也会造成运行时错误。</p>

<h4>字典</h4>

<p>除了数组，Swift还会在Dictionary和NSDictionary之间互相转换。当我们把一个NSDictionary转换到Dictionary的时候，结果的类型是[NSObject: AnyObject]。我们可以把任何的NSDictionary转换到Dictionary，因为所有的ObjC的类都是AnyObject兼容的。注意，一个对象是AnyObject兼容的意思是他是一个ObjC或Swift的类，或者它可以被转到一个这样的。所有的NSDictionary都可以转到Dictionary，所以Swift编译器在导入ObjC的API时把所有的NSDictionary都转到了[NSObject: AnyObject]。相似的，当我们在ObjC中使用Swift的类或协议时，导入器也会把所有的Swift字典转换到NSDictionary。</p>

<p>在把一个NSDictionary转到到Swift的字典后，我们可以进一步向下转换到一个更具体的类型。就和向下转换数组一样，向下转换字典不保证一定成功。所以向下转换[NSObject: AnyObject]返回的时一个optional。</p>

<p>当我们做反向转换时，就是把Swift转到ObjC。key和value都必须是类的实例，或是可以转到一个类的实例。</p>

<p>我们也可以使用Swift的字典字面量来创建NSDctionary，和上面的规则一样。</p>

<h3>Foundation数据类型</h3>

<p>Swift定义了一个方便的封装让我们来使用Foundation的数据类型。我们使用这一层封装来使用类似于NSSize和NSPoint的类型，语法和Swift其他部分的语法自然且统一。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">let</span> <span class="n">size</span> <span class="o">=</span> <span class="n">NSSize</span><span class="p">(</span><span class="nl">width</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span> <span class="nl">height</span><span class="p">:</span> <span class="mi">40</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>这层封装让我们调用方法也很自然：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">let</span> <span class="n">rect</span> <span class="o">=</span> <span class="bp">CGRect</span><span class="p">(</span><span class="nl">x</span><span class="p">:</span> <span class="mi">50</span><span class="p">,</span> <span class="nl">y</span><span class="p">:</span> <span class="mi">50</span><span class="p">,</span> <span class="nl">width</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span> <span class="nl">height</span><span class="p">:</span> <span class="mi">100</span><span class="p">)</span>
</span><span class='line'><span class="n">let</span> <span class="n">width</span> <span class="o">=</span> <span class="n">rect</span><span class="p">.</span><span class="n">width</span>    <span class="c1">// equivalent of CGRectGetWidth(rect)</span>
</span><span class='line'><span class="n">let</span> <span class="n">maxY</span> <span class="o">=</span> <span class="n">rect</span><span class="p">.</span><span class="n">maxY</span>      <span class="c1">// equivalent of CGRectGetMaxY(rect)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Swift把NSUInteger和NSInteger都转到Int。Foundation里的这两个类型都转到了Int。在Swift里使用Int是保持一致性，但是需要的时候我们也可以用UInt。</p>

<h3>Foundation函数</h3>

<p>NSLog函数在Swift依然可用，打印到系统console。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">NSLog</span><span class="p">(</span><span class="s">&quot;%.7f&quot;</span><span class="p">,</span><span class="n">pi</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Swift也还有print和println函数。这些函数也很简单，强大，而且因为Swift的字符串插入而更通用。他们不会打印到系统的console但是可以用于更通用的打印需求。</p>

<p>NSAssert，在Swift不能使用，相反，我们使用assert函数。</p>

<h3>Core Foundation</h3>

<p>Core Foundation类型会被自动导入为完整的Swift类。由于内存管理注解已经给出，Swift会自动管理Core Foundation的对象的内存，包括我们自己创建的Core Foundation对象。在Swift里，我们可以使用Foundation和Core Foundation互相桥接的对象。我们也可以把Core Foundation的一些对象先转换到Foundation对象，再转换到Swift标准库的对象。</p>

<h4>重新映射的类型</h4>

<p>当Swift导入Core Foundation的对象的时候，编译器会重新映射他们的名字。编译器去掉了名字后面的Ref，因为Swift类本来就是引用类型。</p>

<p>Core Foundation的CFTypeRef完全的被重新映射到AnyObject。所有我们使用CFTypeRef的地方，我们都应该使用AnyObject。</p>

<h4>内存被管理的对象</h4>

<p>从有注解的API返回的Core Foundation对象的内存由Swift管理，我们不需要去调用CFRetain，CFRealease或者CFAutorelease。如果我们自己的C函数或ObjC方法放回了Core Foundation对象，我们必须要函数或方法注解为CF_RETURNS_RETAINED或者CF_RETURNS_NOT_RETAINED。这样，编译器就能自动为我们插入正确的内存管理函数。如果我们仅仅使用有注解的API，那下面的部分就可以略过，否则，我们需要继续学习内存未被管理的对象。</p>

<h4>内存未被管理的对象</h4>

<p>当Swift导入的API没有被注解，那么编译器就无法插入正确的内存管理代码。Swift会把这些返回的Core Foundation对象封装到一个Unmanaged<T>的结构体。所有的非直接返回Core Foundation对象的也都是内存未被管理的。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">//ObjC</span>
</span><span class='line'><span class="n">CFStringRef</span> <span class="n">StringByAddingTwoStrings</span><span class="p">(</span><span class="n">CFStringRef</span> <span class="n">string1</span><span class="p">,</span> <span class="n">CFStringRef</span> <span class="n">string2</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Swift会把它导入为：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">func</span> <span class="n">StringByAddingTwoStrings</span><span class="p">(</span><span class="n">CFString</span><span class="o">!</span><span class="p">,</span> <span class="n">CFString</span><span class="o">!</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Unmanaged</span><span class="o">&lt;</span><span class="n">CFString</span><span class="o">&gt;!</span>
</span></code></pre></td></tr></table></div></figure>


<p>当我们碰到了一个内存尾部管理的对象，我们在使用之前应该把它转换为内存被管理的对象。这样，我们就不用管理内存了。Unmanaged<T>有两个方法来把未被管理的对象转换到被管理的对象takeUnretainedValue()和takeRetainedValue()。两个方法都返回了原始的对象，我们根据我们调用的API是否返回一个unretained或是retained的对象。</p>

<p>假设上面的例子里的函数在返回时没有retain返回值。在使用之前，我们就该调用takeUnretainedValue()来拿到原始值。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">let</span> <span class="n">memoryManagedResult</span> <span class="o">=</span> <span class="n">StringByAddingTwoStrings</span><span class="p">(</span><span class="n">str1</span><span class="p">,</span> <span class="n">str2</span><span class="p">).</span><span class="n">takeUnretainedValue</span><span class="p">()</span>
</span><span class='line'><span class="c1">// memoryManagedResult is a memory managed CFString</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们也可以在一个内存未被管理的对象上调用retain()，release()，autorealease()，但是这样并不推荐。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using Swift With Cocoa and Objective-C: Interoperability-Writing Swift Classes With ObjC Behavior]]></title>
    <link href="http://zxhfirefox.github.io/blog/2014/11/17/using-swift-with-objc-interoperability-writing-swift-class-with-objc-behavior/"/>
    <updated>2014-11-17T23:16:04+08:00</updated>
    <id>http://zxhfirefox.github.io/blog/2014/11/17/using-swift-with-objc-interoperability-writing-swift-class-with-objc-behavior</id>
    <content type="html"><![CDATA[<p>互用性(Interoperability)让我们可以定义包含ObjC行为的Swift类。我们在定义Swift类时，可以继承ObjC的类，可以实现ObjC的协议，可以使用ObjC其他的功能。这意味着我们可以以类为基础来创建ObjC行为相似的类，并且使用Swift现代的，强大的特性来加强我们的类。</p>

<!-- more -->


<h3>从ObjC的类继承</h3>

<p>在Swift里，我们可以定义ObjC类的子类。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">import</span> <span class="n">UIKit</span>
</span><span class='line'><span class="k">class</span> <span class="nl">MySwiftViewController</span><span class="p">:</span> <span class="bp">UIViewController</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// define the class</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们将获得父类所有的功能。但是当我们需要重写父类的方法时，记得添加override。</p>

<h3>实现协议</h3>

<p>在Swift里，我们可以实现定义在ObjC的协议。和Swift协议一样，任何的ObjC的协议都写在父类的列表里，用逗号隔开。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">class</span> <span class="nl">MySwiftViewController</span><span class="p">:</span> <span class="bp">UIViewController</span><span class="p">,</span> <span class="bp">UITableViewDelegate</span><span class="p">,</span> <span class="bp">UITableViewDataSource</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// define the class</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>ObjC的协议在导入Swift时，会变成Swift的协议。如果我们想在Swift代码里引用协议UITableViewDelegate，我们直接写成UITableViewDelegate，而不是像ObjC写成id<UITableViewDelegate> 。</p>

<p>因为Swift里的类和协议的命名空间是统一的，所以ObjC的NSObject协议对应到Swift变成了NSObjectProtocol。</p>

<h3>写初始化函数和反初始化函数</h3>

<p>Swift编译器确保我们的初始化函数不会留下未初始化的属性，这样增加了代码的安全性和可预判性(predictability)。另外，和ObjC不一样，Swift没有额外的内存分配调用。即使我们在使用ObjC类型，我们也使用Swift的语法来创建对象，Swift会把ObjC的初始化函数转化为Swift的初始化函数。</p>

<p>当我们需要在类实例被销毁时想执行更多的清理工作，我们实现deinit而不是dealloc方法。Swift反初始化会在对象被销毁前自动调用。Swift在结束我们本身的反初始化函数后也会自动调用父类反初始化函数。当我们使用ObjC的类，或是我们继承自ObjC的类，Swift也会自动调用对应的dealloc方法。</p>

<h3>整合 InterfaceBuilder</h3>

<p>Swift编译器包含了一些标记可以在Swift类里打开IB的特性。我们可以像在ObjC中一样，在Swift里使用outlet，action和实施渲染(live rendering)。</p>

<h4>使用 Outlet 和 Action</h4>

<p>Outlet和Action让我们在IB里可以把界面元素和我们的代码连结起来。我们需要在属性和方法前面加上 @IBOutlet 和 @IBAction来使用。我们在数组前面标记 @IBOutlet来声明一个outlet集合(outlet collection)。</p>

<p>当我们在Swift声明outlet时，我们应该把属性的类型声明为自动解包的optional。这样，我们就可以让故事板(storyboard)来在运行时连接这些outlet。当我们的类从故事版或xib初始化时，我们可以认为属性已经连接好的。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">class</span> <span class="nl">MyViewController</span><span class="p">:</span> <span class="bp">UIViewController</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">@</span><span class="kt">IBOutlet</span> <span class="k">weak</span> <span class="n">var</span> <span class="nl">button</span><span class="p">:</span> <span class="bp">UIButton</span><span class="o">!</span>
</span><span class='line'>    <span class="p">@</span><span class="kt">IBOutlet</span> <span class="n">var</span> <span class="nl">textFields</span><span class="p">:</span> <span class="p">[</span><span class="bp">UITextField</span><span class="p">]</span><span class="o">!</span>
</span><span class='line'>    <span class="p">@</span><span class="kt">IBAction</span> <span class="n">func</span> <span class="n">buttonTapped</span><span class="p">(</span><span class="n">AnyObject</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">println</span><span class="p">(</span><span class="s">&quot;button tapped!&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>实时渲染</h4>

<p>我们可以使用 @IBDesignable 和 @IBInspectable 来在IB里打开实时，交互的视图设计。当我们从UIView或者NSView继承时，我们可以把子类标记为@ IBDesignable。这样，当我们在IB中加入自定义的类时，IB会把我们类渲染出来。</p>

<p>我们也可以在属性前面添加@IBInspectable来让我们在IB设计界面时，可以实时调整这些属性的值。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">@</span><span class="n">IBDesignable</span>
</span><span class='line'><span class="k">class</span> <span class="nl">MyCustomView</span><span class="p">:</span> <span class="bp">UIView</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">@</span><span class="n">IBInspectable</span> <span class="n">var</span> <span class="nl">textColor</span><span class="p">:</span> <span class="bp">UIColor</span>
</span><span class='line'>    <span class="p">@</span><span class="n">IBInspectable</span> <span class="n">var</span> <span class="nl">iconHeight</span><span class="p">:</span> <span class="n">CGFloat</span>
</span><span class='line'>    <span class="cm">/* ... */</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>明确属性(Property)特性(Attribute)</h3>

<p>在ObjC里，属性可以有一系列的特性来给出关于属性的额外信息。在Swift，这些信息需要用其他方式给出。</p>

<h4>强引用和弱引用</h4>

<p>Swift默认提供强引用，用weak关键字来说明弱引用。这个关键字只能用于那些类型是optional的类的属性。</p>

<h4>读写和只读</h4>

<p>在Swift里，我们没有readwrite和readonly特性，我们用let来表示只读，用var来表示可读可写。当声明计算属性时，我们如果只给出getter，那就是只读，如果给出了getter和setter，那就是可读可写。</p>

<h4>拷贝</h4>

<p>在Swift里，ObjC的copy属性特性被翻译为了@NSCopying。这个属性的类型必须实现NSCopying协议。</p>

<h3>实现 Core Data 的管理对象(Managed Object)的子类</h3>

<p>Core Data为 NSManagedObject 的子类的属性提供了底层存储和实现。我们需要在我们的管理对象(Managed Object)的子类的每一个属性或是每一个关系前加 @NSManaged标记。它和Objc的@dynamic一样，告诉Swift编译器这些属性的存储和实现会在运行时给出。然而，和@dynamic不一样，@NSManaged只给Core Data提供支持。</p>

<p>Swift类是有命名空间的，就是他们的模块，一般就是所在的项目。我们在使用NSManagedObject的Swift子类和Core Data模型时，需要在类名检查器前面加上模块的名字。</p>

<h3>和ObjC的API一起使用Swift的类名</h3>

<p>Swift的类有基于他们编译进的模块的命名空间，即使是在ObjC里使用的时候。和ObjC不同，ObjC的所有的名字都在一个全局的命名空间里，所以不能有重名，Swift的类可以在不同的模块里有相同的名字，而不会造成混淆。例如，在Swift里MyFramework的MyClass的全称是MyFramework. MyClass。一个Swift的app的目标就是模块，所以一个app名叫MyGreatApp里的一个名叫Observer的类的全名叫MyGreatApp.Observer。</p>

<p>为了在ObjC中使用Swift类时保留命名空间，Swift类在暴露给ObjC时暴露的全名。因此，当我们使用字符串表示Swift类名的时候，我们必须给出全名。例如，我们在做一个基于文档的app，我们需要在Info.plist里给出文档类的名字。在Swift里，我们必须使用全名，包括app的模块名字。</p>

<p>下面的例子，NSClassFromString通过一个字符串来获取一个类的引用。如果要得到一个Swift类，必须给出全名。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">let</span> <span class="nl">myPersonClass</span><span class="p">:</span> <span class="n">AnyClass</span> <span class="o">=</span> <span class="n">NSClassFromString</span><span class="p">(</span><span class="s">&quot;MyGreatApp.Person&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using Swift With Cocoa and Objective-C: Interoperability-Interacting With ObjC APIs]]></title>
    <link href="http://zxhfirefox.github.io/blog/2014/11/17/using-swift-with-objc-interoperability-interact-with-objc/"/>
    <updated>2014-11-17T23:13:44+08:00</updated>
    <id>http://zxhfirefox.github.io/blog/2014/11/17/using-swift-with-objc-interoperability-interact-with-objc</id>
    <content type="html"><![CDATA[<p>互用性（Interoperability）是说Swift和ObjC之间互相提供接口的能力，让我们可以从一个语言访问另外一个语言的部分代码。当我们开始用Swift来开发时，我们需要理解如何使用互用性（Interoperability）来重新定义，改进我们制作app的方法。</p>

<p>互用性（Interoperability）一个重要的方面就是在我们写Swift代码时可以使用ObjC的API。在我们导入ObjC的框架后，我们可以使用Swift的语法来创建这些类型的实例并和他们交互。</p>

<!-- more -->


<h3>初始化</h3>

<p>我们在Swift里创建ObjC类的实例时，我们用Swift语法调用类的一个初始化函数。当ObjC的init方法转换到Swift时，他们使用了Swift初始化函数的语法。init被删掉了作为了关键字。对于init方法由initWith开头的，With也被删掉了。剩下的部分的第一个字母变成小写成为了参数名字，其他的参数都一一对应过来。selector的每一部分都变成了参数。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">//ObjC</span>
</span><span class='line'><span class="bp">UITableView</span> <span class="o">*</span><span class="n">myTableView</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">UITableView</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithFrame</span><span class="p">:</span><span class="n">CGRectZero</span> <span class="nl">style</span><span class="p">:</span><span class="n">UITableViewStyleGrouped</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">//Swift</span>
</span><span class='line'><span class="n">let</span> <span class="nl">myTableView</span><span class="p">:</span> <span class="bp">UITableView</span> <span class="o">=</span> <span class="bp">UITableView</span><span class="p">(</span><span class="nl">frame</span><span class="p">:</span> <span class="n">CGRectZero</span><span class="p">,</span> <span class="nl">style</span><span class="p">:</span> <span class="p">.</span><span class="n">Grouped</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们不需要调用alloc；Swift会调用。注意在Swift，init不会出现。</p>

<p>我们可以给出类型，也可以让Swift自动推导类型。</p>

<p>为了简单和保持一致，ObjC的工厂方法映射到了Swift得便利初始化函数。这样映射可以保证他们在使用时有一致，清晰的语法。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">//ObjC</span>
</span><span class='line'><span class="bp">UIColor</span> <span class="o">*</span><span class="n">color</span> <span class="o">=</span> <span class="p">[</span><span class="bp">UIColor</span> <span class="nl">colorWithRed</span><span class="p">:</span><span class="mf">0.5</span> <span class="nl">green</span><span class="p">:</span><span class="mf">0.0</span> <span class="nl">blue</span><span class="p">:</span><span class="mf">0.5</span> <span class="nl">alpha</span><span class="p">:</span><span class="mf">1.0</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">//Swift</span>
</span><span class='line'><span class="n">let</span> <span class="n">color</span> <span class="o">=</span> <span class="bp">UIColor</span><span class="p">(</span><span class="nl">red</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">,</span> <span class="nl">green</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span> <span class="nl">blue</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">,</span> <span class="nl">alpha</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h4>可失败的初始化</h4>

<p>在ObjC里，初始化函数直接返回他们初始化后的对象。为了表示初始化失败，初始化函数直接返回nil。在Swift里，这种模式被增加到了语言级别，叫做可失败的初始化（failable initialization）。许多iOS和MacOS的ObjC初始化函数都被修改来表示他们可能失败。这些函数如果不能失败，会被导入为init(&hellip;)，如果可能失败，会被导入为init?(&hellip;)。我们自己的类，和系统类库里还没有修改的初始化会导入为init!(&hellip;)。</p>

<p>例如，NSString(contentsOfFile:) 可能失败，如果文件不存在。我们使用optional绑定来查看初始化是否成功。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">if</span> <span class="n">let</span> <span class="n">fileContents</span> <span class="o">=</span> <span class="bp">NSString</span><span class="p">(</span><span class="nl">contentsOfFile</span><span class="p">:</span> <span class="s">&quot;MyFile.txt&quot;</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="n">fileContents</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>访问属性</h3>

<p>访问和设置ObjC对象的属性使用 . 语法。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">myTextField</span><span class="p">.</span><span class="n">textColor</span> <span class="o">=</span> <span class="bp">UIColor</span><span class="p">.</span><span class="n">darkGrayColor</span><span class="p">()</span>
</span><span class='line'><span class="n">myTextField</span><span class="p">.</span><span class="n">text</span> <span class="o">=</span> <span class="s">&quot;Hello world&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>在访问或设置属性时，直接用属性的名字，不需要加括号。上面的darkGrayColor是一个类方法，而不是属性。</p>

<p>ObjC里，如果一个方法返回一个值，没有任何参数可以被当做一个隐式的getter，也可以使用 . 来直接访问。但是在Swift里不是，Swift里只有在ObjC中使用@property定义的属性被导入后能作为属性使用。</p>

<h3>调用方法</h3>

<p>当我们在Swift里调用ObjC方法时，使用 . 语法。</p>

<p>当ObjC的方法被导入到Swift时，selector的第一部分成为了方法的名字，第一个参数没有名字，selector的其他部分都作为参数。selector的所有部分在调用时都是需要的。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">//ObjC</span>
</span><span class='line'><span class="p">[</span><span class="n">myTableView</span> <span class="nl">insertSubview</span><span class="p">:</span><span class="n">mySubview</span> <span class="nl">atIndex</span><span class="p">:</span><span class="mi">2</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">//Swift</span>
</span><span class='line'><span class="n">myTableView</span><span class="p">.</span><span class="n">insertSubview</span><span class="p">(</span><span class="n">mySubview</span><span class="p">,</span> <span class="nl">atIndex</span><span class="p">:</span> <span class="mi">2</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果调用的方法没有参数，我们也要写上()。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">myTableView</span><span class="p">.</span><span class="n">layoutIfNeeded</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<h3>id 兼容性</h3>

<p>Swift使用一个协议，AnyObject来表示任何类型的对象，就好像ObjC里的id。AnyObject协议确保你写出类型安全的代码，又可以保留一个无类型对象的灵活性。因为这些额外的安全性，Swift会把id转化为AnyObject。</p>

<p>例如，我们可以把任何对象附值给AnyObject类型的变量或常量。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">var</span> <span class="nl">myObject</span><span class="p">:</span> <span class="n">AnyObject</span> <span class="o">=</span> <span class="bp">UITableViewCell</span><span class="p">()</span>
</span><span class='line'><span class="n">myObject</span> <span class="o">=</span> <span class="bp">NSDate</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们可以不用转换，直接调用任何的ObjC方法和属性。这包括标记为@objc的兼容方法。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">let</span> <span class="n">futureDate</span> <span class="o">=</span> <span class="n">myObject</span><span class="p">.</span><span class="n">dateByAddingTimeInterval</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</span><span class='line'><span class="n">let</span> <span class="n">timeSinceNow</span> <span class="o">=</span> <span class="n">myObject</span><span class="p">.</span><span class="n">timeIntervalSinceNow</span>
</span></code></pre></td></tr></table></div></figure>


<p>然而，因为AnyObject的具体类型在运行时是不知道的，所以很容易写出不安全的代码。和ObjC中一样，如果我们调用或访问一个AnyObject事实上不存在的方法或属性，这都会造成运行时错误。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">myObject</span><span class="p">.</span><span class="n">characterAtIndex</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</span><span class='line'><span class="c1">// crash, myObject doesn&#39;t respond to that method</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们可以使用optional来去除这种在ObjC中常见的错误。当我们调用AnyObject类型对象的ObjC方法时，这个方法调用实际上像一个自动解包的optional。我们也可以使用optional链条来调用AnyObject的方法或属性。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">let</span> <span class="n">myCount</span> <span class="o">=</span> <span class="n">myObject</span><span class="p">.</span><span class="n">count</span><span class="o">?</span>
</span><span class='line'><span class="n">let</span> <span class="n">myChar</span> <span class="o">=</span> <span class="n">myObject</span><span class="p">.</span><span class="n">characterAtIndex</span><span class="o">?</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</span><span class='line'><span class="k">if</span> <span class="n">let</span> <span class="n">fifthCharacter</span> <span class="o">=</span> <span class="n">myObject</span><span class="p">.</span><span class="n">characterAtIndex</span><span class="o">?</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="s">&quot;Found \(fifthCharacter) at index 5&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>和Swift里所有的向下转换一样，把AnyObject向下转换不一定成功。因此会返回一个optional。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">let</span> <span class="n">userDefaults</span> <span class="o">=</span> <span class="bp">NSUserDefaults</span><span class="p">.</span><span class="n">standardUserDefaults</span><span class="p">()</span>
</span><span class='line'><span class="n">let</span> <span class="nl">lastRefreshDate</span><span class="p">:</span> <span class="n">AnyObject</span><span class="o">?</span> <span class="o">=</span> <span class="n">userDefaults</span><span class="p">.</span><span class="n">objectForKey</span><span class="p">(</span><span class="s">&quot;LastRefreshDate&quot;</span><span class="p">)</span>
</span><span class='line'><span class="k">if</span> <span class="n">let</span> <span class="n">date</span> <span class="o">=</span> <span class="n">lastRefreshDate</span> <span class="n">as</span><span class="o">?</span> <span class="bp">NSDate</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="s">&quot;\(date.timeIntervalSinceReferenceDate)&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>当然，如果我们确定类型，可以使使用as。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">let</span> <span class="n">myDate</span> <span class="o">=</span> <span class="n">lastRefreshDate</span> <span class="n">as</span> <span class="bp">NSDate</span>
</span><span class='line'><span class="n">let</span> <span class="n">timeInterval</span> <span class="o">=</span> <span class="n">myDate</span><span class="p">.</span><span class="n">timeIntervalSinceReferenceDate</span>
</span></code></pre></td></tr></table></div></figure>


<h3>使用 nil</h3>

<p>在ObjC离，我们使用引用到对象是原始指针，它的值可能是NULL，在ObjC里也叫nil。在Swift里，所有值，包括结构体和类引用，都保证有值。相反，我们把可能没有值的对象包裹在一个optional里，当它的值不存在的时候，用nil表示。</p>

<p>因为ObjC并不会保证一个对象不是nil，Swift会把ObjC导入的API里的类类型包裹在一个自动解包的optional里。在使用一个ObjC对象前，我们应该检查对象是否存在。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">//ObjC</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="bp">NSDate</span> <span class="o">*</span><span class="p">)</span><span class="nf">dueDateForProject:</span><span class="p">(</span><span class="n">Project</span> <span class="o">*</span><span class="p">)</span><span class="nv">project</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>导入到Swift变成了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">//Swift</span>
</span><span class='line'><span class="n">func</span> <span class="n">dueDateForProject</span><span class="p">(</span><span class="nl">project</span><span class="p">:</span> <span class="n">Project</span><span class="o">!</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">NSDate</span><span class="o">!</span>
</span></code></pre></td></tr></table></div></figure>


<p>在某些情况下，你可以确保一个ObjC的方法或属性绝对不会返回nil。为了在这种情况下使用方便，Swift把它们导入为自动解包的optional。</p>

<h3>扩展</h3>

<p>Swift的扩展有点类似ObjC的类别。扩展可以扩展现有的类，结构体，枚举，包括那些定义在ObjC里的。我们可以扩展系统的或是我们自己定义的类型。直接导入模块，然后引用对应的类，结构体或枚举就可以了。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">extension</span> <span class="bp">UIBezierPath</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">convenience</span> <span class="n">init</span><span class="p">(</span><span class="nl">triangleSideLength</span><span class="p">:</span> <span class="n">Float</span><span class="p">,</span> <span class="nl">origin</span><span class="p">:</span> <span class="bp">CGPoint</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">init</span><span class="p">()</span>
</span><span class='line'>        <span class="n">let</span> <span class="n">squareRoot</span> <span class="o">=</span> <span class="n">Float</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">3.0</span><span class="p">))</span>
</span><span class='line'>        <span class="n">let</span> <span class="n">altitude</span> <span class="o">=</span> <span class="p">(</span><span class="n">squareRoot</span> <span class="o">*</span> <span class="n">triangleSideLength</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
</span><span class='line'>        <span class="n">moveToPoint</span><span class="p">(</span><span class="n">origin</span><span class="p">)</span>
</span><span class='line'>        <span class="n">addLineToPoint</span><span class="p">(</span><span class="bp">CGPoint</span><span class="p">(</span><span class="nl">x</span><span class="p">:</span> <span class="n">triangleSideLength</span><span class="p">,</span> <span class="nl">y</span><span class="p">:</span> <span class="n">origin</span><span class="p">.</span><span class="n">x</span><span class="p">))</span>
</span><span class='line'>        <span class="n">addLineToPoint</span><span class="p">(</span><span class="bp">CGPoint</span><span class="p">(</span><span class="nl">x</span><span class="p">:</span> <span class="n">triangleSideLength</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="nl">y</span><span class="p">:</span> <span class="n">altitude</span><span class="p">))</span>
</span><span class='line'>        <span class="n">closePath</span><span class="p">()</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们可以通过扩展添加属性（包括类和静态属性），但是，这些属性都必须是计算的，不能添加存储的属性。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">extension</span> <span class="bp">CGRect</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">var</span> <span class="nl">area</span><span class="p">:</span> <span class="n">CGFloat</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">width</span> <span class="o">*</span> <span class="n">height</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">let</span> <span class="n">rect</span> <span class="o">=</span> <span class="bp">CGRect</span><span class="p">(</span><span class="nl">x</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span> <span class="nl">y</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span> <span class="nl">width</span><span class="p">:</span> <span class="mf">10.0</span><span class="p">,</span> <span class="nl">height</span><span class="p">:</span> <span class="mf">50.0</span><span class="p">)</span>
</span><span class='line'><span class="n">let</span> <span class="n">area</span> <span class="o">=</span> <span class="n">rect</span><span class="p">.</span><span class="n">area</span>
</span><span class='line'><span class="c1">// area: CGFloat = 500.0</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们可以使用扩展一个类来实现协议，而不用子类。如果协议定义在Swift，我们还可以让枚举和结构体实现协议，不管它们是定义在Swift还是ObjC。</p>

<p>我们不能用扩展来重写ObjC类型已有的方法和属性。</p>

<h3>闭包</h3>

<p>ObjC的blocks自动导入为Swift的闭包。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">//ObjC</span>
</span><span class='line'><span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">completionBlock</span><span class="p">)(</span><span class="bp">NSData</span> <span class="o">*</span><span class="p">,</span> <span class="bp">NSError</span> <span class="o">*</span><span class="p">)</span> <span class="o">=</span> <span class="o">^</span><span class="p">(</span><span class="bp">NSData</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="bp">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span><span class="cm">/* ... */</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">//Swift</span>
</span><span class='line'><span class="n">let</span> <span class="nl">completionBlock</span><span class="p">:</span> <span class="p">(</span><span class="bp">NSData</span><span class="p">,</span> <span class="bp">NSError</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Void</span> <span class="o">=</span> <span class="p">{</span><span class="n">data</span><span class="p">,</span> <span class="n">error</span> <span class="k">in</span> <span class="cm">/* ... */</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Swift的闭包和ObjC的block是互相兼容的，所以我们可以ObjC的方法传递Swift的闭包。Swift闭包和函数有着相同的类型，所以我们也可以传递Swift函数。</p>

<p>闭包和blocks有着相似的捕获行为，但有一点不同： <em>变量是可变的，而不是拷贝的</em>。换句话说，ObjC的 __block 行为在Swift是默认的。</p>

<h3>对象比较</h3>

<p>在Swift里比较对象有两种方式，第一个，相等性(equality)==，比较的是两个对象的内容。第二个，相同性(identity)===，比较两个引用是否指向一个对象实例。</p>

<p>Swift和ObjC对象通常在Swift里使用 == 和 === 来比较。Swift为NSObject的子类自动提供了一个实现。在这个实现里，Swift会调用NSObject的isEqual:方法，NSObject仅仅是相同性检查，所以我们需要自己实现isEqual:方法。因为我们可能把Swift的对象传递给ObjC，但是这些事例可能不是继承NSObject，所以需要在ObjC里做比较，就需要在这些类型里实现isEqual:方法。</p>

<p>作为实现相等性的一部分，我们需要确保实现hash属性。另外，如果我们打算把类型作为字典的key来使用，还需要实现Hashable协议，并给出hashValue属性。</p>

<h3>Swift类型兼容性</h3>

<p>当我们继承从一个ObjC的类继承一个类时，这个类的属性，方法，角标和初始化函数都自动在ObjC可以使用。在某些时候，我们需要更细粒度的控制我们Swift的API如何暴露给ObjC。</p>

<p>我们可以使用 @objc 来标记一个不是继承自ObjC类型的类，来使它在ObjC中可用。或是我们想改变一个符号暴露给ObjC之后的名字。当我们正在使用类似于KVO的API，我们也可使用dynamic修饰符来要求成员的访问由ObjC运行时动态分发，这样可以动态替换一个方法的实现。</p>

<h4>暴露Swift的接口给ObjC</h4>

<p>当我们从NSObject或是任何其他ObjC的类继承来定义一个Swift类的时候，这个类自动会和ObjC的类兼容。这部分所说的所有内容，Swift编译器都会替我们做好。如果我们永远都不会在ObjC中导入一个Swift的类，这部分的内容我们也不用考虑。但是，如果我们的Swift类不是继承自NSObject或其他ObjC的类，我们还希望在ObjC中使用它，那么我就需要使用 @objc。</p>

<p>@objc 标记，可以使我们的Swift API在ObjC和ObjC运行时可用。换句话说，我们可以把 @objc 加在任何的方法，属性，角标，初始化函数，类的前面，让他们可以在ObjC中可用。如果我们的类继承自ObjC的类，编译器会帮我们添加 @objc标记，编译器也会把类的成员都加上@objc标记。当我们添加@IBOutlet，@IBAction或者@NSManaged标记，@objc也会自动加上。当我们使用ObjC的selector来实现目标-动作(target-action)模式的时候，@objc也很有用。</p>

<pre><code>注意
编译器并不会给private的成员自动添加@objc。
</code></pre>

<p>当我们在ObjC中使用Swift时，编译器会做一次翻译。例如，Swift的函数func playSong(name: String)会被导入为- (void)playSong:(NSString <em>)name。然而，这里有个区别，当我们使用Swift的初始化函数时，编译器会在函数前加 initWith，例如，init (songName: String, artist: String) 会被导入为(instancetype)initWithSongName:(NSString </em>)songName artist:(NSString *)artist。</p>

<p>Swift还允许给出一系列的名字，来给出@objc标记的内容在ObjC中得名字。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">@</span><span class="n">objc</span><span class="p">(</span><span class="n">Squirrel</span><span class="p">)</span>
</span><span class='line'><span class="k">class</span> <span class="err">Белка</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">@</span><span class="n">objc</span><span class="p">(</span><span class="nl">initWithName</span><span class="p">:)</span>
</span><span class='line'>    <span class="n">init</span> <span class="p">(</span><span class="err">имя</span><span class="o">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/*...*/</span> <span class="p">}</span>
</span><span class='line'>    <span class="p">@</span><span class="n">objc</span><span class="p">(</span><span class="nl">hideNuts</span><span class="p">:</span><span class="nl">inTree</span><span class="p">:)</span>
</span><span class='line'>    <span class="n">func</span> <span class="err">прячьОрехи</span><span class="p">(</span><span class="n">Int</span><span class="p">,</span> <span class="err">вДереве</span><span class="o">:</span> <span class="err">Дерево</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/*...*/</span> <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>当我们在一个Swift类上用@objc(&lt;#name#>)时，这个类会在ObjC中出现，并且没有任何命名空间。另外，这个属性，在我们从ObjC类迁移到Swift时候也很有用，因为归档的对象会在归档里存储类名，我们也需要使用@objc(&lt;#name#>)来给出名字，这样旧的类名可以被Swift解析出来。</p>

<h4>要求动态分发</h4>

<p>尽管@objc标记可以把Swift的API暴露给ObjC，但是它不能保证属性，方法，角标和初始化函数时动态分发的。Swift编译器还是有可能为了优化性能去虚拟化(devirtualize)或是而把这些访问变成inline的，而不通过ObjC运行时。当我们把一个成员标记为dynamic，这个成员的访问就永远是动态分发的。因此，标记为dynamic自然也是@objc的。</p>

<p>我们很少需要动态分发。但是，如果我们需要，就必须标记为dynamic。因为我们可能使用ObjC运行时的函数method_exchangeImplementations来在app运行时替换实现，但是如果Swift编译器把函数inline或是去虚拟化，那么替换的实现就不会被调用。</p>

<h3>ObjC Selector</h3>

<p>ObjC的Selector是一种可以用来引用ObjC方法的类型。在Swift里，ObjC的selector类型使用Selector结构体表达。我们可以使用一个字符串字面量来创建一个Selector，例如 let mySelector: Selector = &ldquo;tappedButton:&rdquo;.因为字符串字面量可以自动的转换到selector。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">import</span> <span class="n">UIKit</span>
</span><span class='line'><span class="k">class</span> <span class="nl">MyViewController</span><span class="p">:</span> <span class="bp">UIViewController</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">myButton</span> <span class="o">=</span> <span class="bp">UIButton</span><span class="p">(</span><span class="nl">frame</span><span class="p">:</span> <span class="bp">CGRect</span><span class="p">(</span><span class="nl">x</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nl">y</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nl">width</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span> <span class="nl">height</span><span class="p">:</span> <span class="mi">50</span><span class="p">))</span>
</span><span class='line'>    <span class="n">init</span><span class="p">(</span><span class="n">nibName</span> <span class="nl">nibNameOrNil</span><span class="p">:</span> <span class="n">String</span><span class="o">?</span><span class="p">,</span> <span class="n">bundle</span> <span class="nl">nibBundleOrNil</span><span class="p">:</span> <span class="bp">NSBundle</span><span class="o">?</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nb">super</span><span class="p">.</span><span class="n">init</span><span class="p">(</span><span class="nl">nibName</span><span class="p">:</span> <span class="n">nibNameOrNil</span><span class="p">,</span> <span class="nl">bundle</span><span class="p">:</span> <span class="n">nibBundleOrNil</span><span class="p">)</span>
</span><span class='line'>        <span class="n">myButton</span><span class="p">.</span><span class="n">addTarget</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="nl">action</span><span class="p">:</span> <span class="s">&quot;tappedButton:&quot;</span><span class="p">,</span> <span class="nl">forControlEvents</span><span class="p">:</span> <span class="p">.</span><span class="n">TouchUpInside</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">func</span> <span class="n">tappedButton</span><span class="p">(</span><span class="nl">sender</span><span class="p">:</span> <span class="bp">UIButton</span><span class="o">!</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">println</span><span class="p">(</span><span class="s">&quot;tapped button&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<pre><code>注意
performSelector:和类似的方法在Swift里都没有实现，因为这些方法其实是不安全的。
</code></pre>

<p>如果我们的Swift类继承自ObjC的类，这个类的所有方法和属性都在ObjC作为selector使用。否则，我们需要添加@objc。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using Swift With Cocoa and Objective-C: Getting Started-Basic Setup]]></title>
    <link href="http://zxhfirefox.github.io/blog/2014/11/17/using-swift-with-objc-getting-started-basic-setup/"/>
    <updated>2014-11-17T23:11:42+08:00</updated>
    <id>http://zxhfirefox.github.io/blog/2014/11/17/using-swift-with-objc-getting-started-basic-setup</id>
    <content type="html"><![CDATA[<p>Swift从设计开始就保证了和Cocoa以及ObjC的无缝兼容。我们可以在Swift里使用ObjC的API，不论是系统提供的框架还是我们自己写得代码；我们也可以在ObjC中使用Swift。这样我们可以很轻松的把Swift加入到我们现在的App开发流程中。</p>

<p>整个这篇文档从三个重要的方面来讲述兼容性。
    *   互用性（Interoperability），让我们可以在Swift和ObjC之间交互，让我们在ObjC中使用Swift类，还可以在Swift使用Cococa的框架和模式。
    *   混合与匹配（Mix and Match），告诉我们如何同时在一个app内使用Swift和ObjC。
    *   迁移（Migration），在互用性和混合与匹配的基础上，从现有的ObjC代码迁移到Swift就会比较简单。</p>

<p>在我们开始之前，我们需要先做一些准备工作，来配置我们的开发环境。</p>

<!-- more -->


<h3>配置Swift环境</h3>

<p>我们需要从Xcode项目模板中选择一个，然后创建一个Swift的项目工程。</p>

<p>Swift的项目工程结构和ObjC的基本一样，但是有一个重要的区别：Swift文件没有头文件。在接口和实现没有明显的区别，都放在一个文件里。</p>

<h3>理解Swift的Import过程</h3>

<p>在配置好Xcode工程之后，我们可以导入任何来自Cocoa的框架。</p>

<p>所有的ObjC框架和C类库在Swift里都以模块（module）的形式被导入。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">import</span> <span class="n">Foundation</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个命令导入了Foundation所有的API，包括NSDate，NSURL等等他们的方法，属性，类别，这些都直接可以在Swift内使用。</p>

<p>导入的过程非常直接，ObjC框架把它们的API放到头文件里。Swift里，这些头文件被编译到ObjC模块，然后被导入到Swift里。这个构成决定了ObjC里的函数，类，方法如何出现在Swift里。对于函数和方法，参数类型和返回值类型可能受到影响。对于类型，可能发生下面的改变：
    *   把ObjC特定的类型转到Swift里对应的类型。例如，id到AnyObject
    *   把ObjC的核心类型转到Swift里对应的类型。例如，NSString到String。
    *   把ObjC里的概念转到Swift里对应的概念。例如，指针到引用。</p>

<p>把Swift导入ObjC的模型和把ObjC导入到Swift的模型非常相似。Swift把它的API表达成Swift模块（module）。这些模块会生成ObjC的头文件。这些头文件就可以在ObjC中使用。有一些Swift的API不能映射到ObjC，因为有些概念在ObjC中不存在。</p>

<pre><code>注意
我们不能在Swift中直接使用C++，必须使用ObjC来包裹C++代码。
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Language Guide: Conclusion]]></title>
    <link href="http://zxhfirefox.github.io/blog/2014/10/26/language-guide-h-conclusion/"/>
    <updated>2014-10-26T23:28:48+08:00</updated>
    <id>http://zxhfirefox.github.io/blog/2014/10/26/language-guide-h-conclusion</id>
    <content type="html"><![CDATA[<p>从9月14号开始翻译到今天（10月26号），终于很粗糙的把苹果关于Swift的第一篇文档（The Swift Programming Language）的重要部分（Welcome to Swift 和 Language Guie）翻译完毕。</p>

<p>关于语言参考（Language Reference）部分，我不打算翻译了，因为这些是一些语法定义的细节。大部分都是我们在工作不需要的，但是有一些部分是我们在使用Swift一些高级特性时最好知道的细节，所以，以后也许会单独的翻译那些细节。</p>

<p>在翻译过程中的一些问题需要在这里总结出来。</p>

<!-- more -->


<h4>特殊语境内，专业名词的翻译。</h4>

<p>对于这一个，我在翻译时有很多地方很纠结。有些专用的词我们应该给出比较专业的翻译，而我其实水平是达不到的。。。</p>

<p>想到的解决办法就是，首先，要有一个索引，来指出文章中的特殊的英文单词和我们翻译后的单词的对照。其次，在文章中使用到这个翻译的地方，同时给出原有英文。</p>

<h4>按照原文翻译，还是加入我们自己的理解</h4>

<p>这也是一个问题，开始很多地方，本来是想着按照原文的意思来翻译。后来发现有时候不太好表达，有时候原文很多废话，最后我也就会加入一些我自己的理解，并且直接忽略了一些无用的废话。</p>

<h4>最后</h4>

<p>看完这些，可能会觉得这次的翻译，对于我自己很有帮助，但是如果真的给别人去读，可能帮助并不大。。。</p>

<p>所以，这次的翻译，作为给读者的建议：</p>

<p>如果你能阅读原文，最好阅读原文。</p>

<p>如果你不能阅读原文，最好也参照原文来读。</p>

<h4>最最后</h4>

<p>苹果关于Swift总共2篇主要的文档，那么下面自然是要继续翻译下一篇。</p>

<p>Using Swift with Cocoa and Objective-C</p>

<p>这次，我会尽量改进前面说到的两个问题，不过也许可能大概改进不了多少= =</p>

<p>如果你读到了任何错误，请告诉我，谢谢。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Language Guide: Advanced Operators]]></title>
    <link href="http://zxhfirefox.github.io/blog/2014/10/26/language-guide-h-advanced-operators/"/>
    <updated>2014-10-26T23:28:03+08:00</updated>
    <id>http://zxhfirefox.github.io/blog/2014/10/26/language-guide-h-advanced-operators</id>
    <content type="html"><![CDATA[<p>除了在基础操作符里提到的那些操作符，Swift还提供了一些高级操作符。这些包含了位操作符。</p>

<p>和C里算数操作符不一样，Swift的算数操作符不会溢出。溢出行为会被捕获并报错。如果不想要这种行为，可以使用另外一套操作符，默认是会溢出的。所有这种操作符都是新加一个 &amp; 。</p>

<p>当我们定义自定义类时，我们可以提供一些Swift里的一些标准操作符。Swift简化了这一过程。</p>

<p>我们并不被限制在已有的操作符。Swift里我们可以定义任意的中缀，前缀和后缀，附值操作符，还可以自定义优先级和关联度。这些操作符可以在代码像已有操作符一样使用，我们甚至可以扩展已有操作符来支持自定义操作符。</p>

<!-- more -->


<h3>位操作符</h3>

<p>位操作符让我们可以处理数据结构里的单个原始数据，经常用于底层变成，例如，图形编程和设备驱动制作。位操作符在我们处理外来原始数据时也很有用，例如自定义协议的编码和解码。</p>

<p>Swift支持所有C定义的位操作符。</p>

<h4>按位取反</h4>

<p>~ 反转一个数字的所有位。</p>

<pre><code>    Input 00001111
          11110000 Result
</code></pre>

<p>按位取反操作符是前缀操作符，出现在操作数前，没有空格。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">let</span> <span class="nl">initialBits</span><span class="p">:</span> <span class="kt">UInt8</span> <span class="o">=</span> <span class="mi">0</span><span class="n">b00001111</span>
</span><span class='line'><span class="n">let</span> <span class="n">invertedBits</span> <span class="o">=</span> <span class="o">~</span><span class="n">initialBits</span>  <span class="c1">// equals 11110000</span>
</span></code></pre></td></tr></table></div></figure>


<h4>按位与</h4>

<p>&amp; 把两个数组按位组合，结果的值只有两个参数都是1是才是1，其他都是0。</p>

<pre><code>    Input1 11111100
           00111100 Result
    Input2 00111111      
</code></pre>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">let</span> <span class="nl">firstSixBits</span><span class="p">:</span> <span class="kt">UInt8</span> <span class="o">=</span> <span class="mi">0</span><span class="n">b11111100</span>
</span><span class='line'><span class="n">let</span> <span class="nl">lastSixBits</span><span class="p">:</span> <span class="kt">UInt8</span>  <span class="o">=</span> <span class="mi">0</span><span class="n">b00111111</span>
</span><span class='line'><span class="n">let</span> <span class="n">middleFourBits</span> <span class="o">=</span> <span class="n">firstSixBits</span> <span class="o">&amp;</span> <span class="n">lastSixBits</span>  <span class="c1">// equals 00111100</span>
</span></code></pre></td></tr></table></div></figure>


<h4>按位或</h4>

<p>| 把两个数组按位组合，结果的值只要有1个参数都是1是就是1，其他都是0。</p>

<pre><code>    Input1 10110010
           11111110 Result
    Input2 01011110
</code></pre>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">let</span> <span class="nl">someBits</span><span class="p">:</span> <span class="kt">UInt8</span> <span class="o">=</span> <span class="mi">0</span><span class="n">b10110010</span>
</span><span class='line'><span class="n">let</span> <span class="nl">moreBits</span><span class="p">:</span> <span class="kt">UInt8</span> <span class="o">=</span> <span class="mi">0</span><span class="n">b01011110</span>
</span><span class='line'><span class="n">let</span> <span class="n">combinedbits</span> <span class="o">=</span> <span class="n">someBits</span> <span class="o">|</span> <span class="n">moreBits</span>  <span class="c1">// equals 11111110</span>
</span></code></pre></td></tr></table></div></figure>


<h4>按位异或</h4>

<p>^ 操作符，组合两个数字，当两个数字位的值相同时，结果是0，不相同时是1。</p>

<pre><code>    Input1 00010100
           00010001 Result
    Input2 00000101
</code></pre>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">let</span> <span class="nl">firstBits</span><span class="p">:</span> <span class="kt">UInt8</span> <span class="o">=</span> <span class="mi">0</span><span class="n">b00010100</span>
</span><span class='line'><span class="n">let</span> <span class="nl">otherBits</span><span class="p">:</span> <span class="kt">UInt8</span> <span class="o">=</span> <span class="mi">0</span><span class="n">b00000101</span>
</span><span class='line'><span class="n">let</span> <span class="n">outputBits</span> <span class="o">=</span> <span class="n">firstBits</span> <span class="o">^</span> <span class="n">otherBits</span>  <span class="c1">// equals 00010001</span>
</span></code></pre></td></tr></table></div></figure>


<h4>按位左移和右移操作符</h4>

<p>&lt;&lt; 和 >> 分别把一个数字的所有位向左和向右移动特定数字位。</p>

<p>按位移动操作符相当于对数字做乘以2的指数幂或除以2指数幂。往左一位相当于乘以2，往右相当于除以2.</p>

<h4>无符号整数的位移</h4>

<ol>
<li>现有位移动到指定的位置。</li>
<li>任何超出边界的位都被遗弃。</li>
<li>剩余空位补0.</li>
</ol>


<p>这种叫做逻辑位移。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">let</span> <span class="nl">shiftBits</span><span class="p">:</span> <span class="kt">UInt8</span> <span class="o">=</span> <span class="mi">4</span>   <span class="c1">// 00000100 in binary</span>
</span><span class='line'><span class="n">shiftBits</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span>             <span class="c1">// 00001000</span>
</span><span class='line'><span class="n">shiftBits</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span>             <span class="c1">// 00010000</span>
</span><span class='line'><span class="n">shiftBits</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span>             <span class="c1">// 10000000</span>
</span><span class='line'><span class="n">shiftBits</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span>             <span class="c1">// 00000000</span>
</span><span class='line'><span class="n">shiftBits</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span>             <span class="c1">// 00000001</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们可以使用位移来编码和解码。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">let</span> <span class="nl">pink</span><span class="p">:</span> <span class="kt">UInt32</span> <span class="o">=</span> <span class="mh">0xCC6699</span>
</span><span class='line'><span class="n">let</span> <span class="n">redComponent</span> <span class="o">=</span> <span class="p">(</span><span class="n">pink</span> <span class="o">&amp;</span> <span class="mh">0xFF0000</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span>    <span class="c1">// redComponent is 0xCC, or 204</span>
</span><span class='line'><span class="n">let</span> <span class="n">greenComponent</span> <span class="o">=</span> <span class="p">(</span><span class="n">pink</span> <span class="o">&amp;</span> <span class="mh">0x00FF00</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span>   <span class="c1">// greenComponent is 0x66, or 102</span>
</span><span class='line'><span class="n">let</span> <span class="n">blueComponent</span> <span class="o">=</span> <span class="n">pink</span> <span class="o">&amp;</span> <span class="mh">0x0000FF</span>           <span class="c1">// blueComponent is 0x99, or 153</span>
</span></code></pre></td></tr></table></div></figure>


<h4>有符号整数的位移</h4>

<p>有符号的位移要比无符号数的位移复杂许多，主要是和有符号数在内存的表示方式有关。</p>

<p>有符号数使用第一位来作为符号位，标示正数还是负数。0是正数，1是负数。</p>

<p>剩余的位是值位，正数就是按照整数本身来存储的。</p>

<pre><code>    0 000 0100 = 4
</code></pre>

<p>负数，就不一样了，他们存储的是他们值的绝对值减掉2的n次幂，n是值位的个数。如果是Int8，那么n就是7，减去的就是128。</p>

<pre><code>    1 111 1100 = -4
    0 111 1100 = 124
</code></pre>

<p>负数的编码叫做补码。它有一些优点。</p>

<p>首先做加法时，我们可以直接加，包括符号位，然后舍弃任何超出范围的位。</p>

<pre><code>    0 1111 1100 = -4
+   0 1111 1111 = -1
=   1 1111 1011 = -5
</code></pre>

<p>其次，使用补码，我们在位移时可以像处理正数一样。但是有个额外的规则。
    *   在右移时，补位用符号位而不是0。</p>

<pre><code>    1111111         01111111
    11111111        001111111
</code></pre>

<p>这样就确保了在位移后，数字的符号位不会变化，叫做算数位移。</p>

<p>因为正数和负数存储的特殊方式，右移他们都是把它们向0靠近。保留符号位意味着负数还是负数，同时更加接近0。</p>

<h3>溢出操作符</h3>

<p>如果我们尝试把一个超出存储范围的数字附值给一个常量或变量，Swift会报错。</p>

<p>例如，Int16的值的范围是-32768到32767。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">var</span> <span class="n">potentialOverflow</span> <span class="o">=</span> <span class="n">Int16</span><span class="p">.</span><span class="n">max</span>
</span><span class='line'><span class="c1">// potentialOverflow equals 32767, which is the largest value an Int16 can hold</span>
</span><span class='line'><span class="n">potentialOverflow</span> <span class="o">+=</span> <span class="mi">1</span>
</span><span class='line'><span class="c1">// this causes an error</span>
</span></code></pre></td></tr></table></div></figure>


<p>在这种时候，我们需要提供错误处理。
    *   加   &amp;+
    *   减   &amp;-
    *   乘   &amp;*
    *   除   &amp;/
    *   取余 &amp;%</p>

<h4>值上溢出</h4>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">var</span> <span class="n">willOverflow</span> <span class="o">=</span> <span class="kt">UInt8</span><span class="p">.</span><span class="n">max</span>
</span><span class='line'><span class="c1">// willOverflow equals 255, which is the largest value a UInt8 can hold</span>
</span><span class='line'><span class="n">willOverflow</span> <span class="o">=</span> <span class="n">willOverflow</span> <span class="o">&amp;+</span> <span class="mi">1</span>
</span><span class='line'><span class="c1">// willOverflow is now equal to 0</span>
</span></code></pre></td></tr></table></div></figure>


<pre><code>    0 1111 1111 = 255
&amp;+  0 0000 0001 =   1
=   1 0000 0000 =   0
</code></pre>

<h4>值下溢出</h4>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">var</span> <span class="n">willUnderflow</span> <span class="o">=</span> <span class="kt">UInt8</span><span class="p">.</span><span class="n">min</span>
</span><span class='line'><span class="c1">// willUnderflow equals 0, which is the smallest value a UInt8 can hold</span>
</span><span class='line'><span class="n">willUnderflow</span> <span class="o">=</span> <span class="n">willUnderflow</span> <span class="o">&amp;-</span> <span class="mi">1</span>
</span><span class='line'><span class="c1">// willUnderflow is now equal to 255</span>
</span></code></pre></td></tr></table></div></figure>


<pre><code>    0000 0000 = 0
&amp;-  0000 0001 = 1
=   1111 1111 = 255
</code></pre>

<p>有符号数也会发生下溢出。符号数减法时，所有位都参与，包括符号位。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">var</span> <span class="n">signedUnderflow</span> <span class="o">=</span> <span class="n">Int8</span><span class="p">.</span><span class="n">min</span>
</span><span class='line'><span class="c1">// signedUnderflow equals -128, which is the smallest value an Int8 can hold</span>
</span><span class='line'><span class="n">signedUnderflow</span> <span class="o">=</span> <span class="n">signedUnderflow</span> <span class="o">&amp;-</span> <span class="mi">1</span>
</span><span class='line'><span class="c1">// signedUnderflow is now equal to 127</span>
</span></code></pre></td></tr></table></div></figure>


<pre><code>    1000 0000 = -128
&amp;-  0000 0001 = 1
=   0111 1111 = 127
</code></pre>

<p>上面的这些溢出的结构，都是在最大值后回到了最小值，或者最小值后回到了最大值。</p>

<h4>除以0</h4>

<p>当我们尝试除以0或者对0取余时，会报错。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
</span><span class='line'><span class="n">let</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">/</span> <span class="mi">0</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后如果用溢出操作符时，返回0.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
</span><span class='line'><span class="n">let</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&amp;/</span> <span class="mi">0</span>
</span><span class='line'><span class="c1">// y is equal to 0</span>
</span></code></pre></td></tr></table></div></figure>


<h3>优先级和关联性</h3>

<p>操作符的优先级是说某些操作符优先于其他操作符进行计算。</p>

<p>操作符的关联性是说，如果两个相同优先级的操作符在一起时，是算到左边还是右边。这样想，他们和他们左边的表达式在一起，或者他们和他们右边的表达式在一起。</p>

<p>当我们考虑表达式如果计算时，优先级和关联性很重要。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">%</span> <span class="mi">5</span>
</span><span class='line'><span class="c1">// this equals 4</span>
</span></code></pre></td></tr></table></div></figure>


<pre><code>注意
Swift的操作符优先级和关联性和C，ObjC中得很相似，并且更可预测。但是这意味着他不一样，所以在使用时需要注意。
</code></pre>

<h3>操作符函数</h3>

<p>类和结构体可以提供现有操作符的自定义实现，这叫做操作符重载。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">struct</span> <span class="n">Vector2D</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">var</span> <span class="n">x</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mf">0.0</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">func</span> <span class="o">+</span> <span class="p">(</span><span class="nl">left</span><span class="p">:</span> <span class="n">Vector2D</span><span class="p">,</span> <span class="nl">right</span><span class="p">:</span> <span class="n">Vector2D</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Vector2D</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">Vector2D</span><span class="p">(</span><span class="nl">x</span><span class="p">:</span> <span class="n">left</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">right</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="nl">y</span><span class="p">:</span> <span class="n">left</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">right</span><span class="p">.</span><span class="n">y</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个操作符函数被定义为全局函数，函数名和操作符匹配。因为是中缀操作符，所以有两个参数。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">let</span> <span class="n">vector</span> <span class="o">=</span> <span class="n">Vector2D</span><span class="p">(</span><span class="nl">x</span><span class="p">:</span> <span class="mf">3.0</span><span class="p">,</span> <span class="nl">y</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">)</span>
</span><span class='line'><span class="n">let</span> <span class="n">anotherVector</span> <span class="o">=</span> <span class="n">Vector2D</span><span class="p">(</span><span class="nl">x</span><span class="p">:</span> <span class="mf">2.0</span><span class="p">,</span> <span class="nl">y</span><span class="p">:</span> <span class="mf">4.0</span><span class="p">)</span>
</span><span class='line'><span class="n">let</span> <span class="n">combinedVector</span> <span class="o">=</span> <span class="n">vector</span> <span class="o">+</span> <span class="n">anotherVector</span>
</span><span class='line'><span class="c1">// combinedVector is a Vector2D instance with values of (5.0, 5.0)</span>
</span></code></pre></td></tr></table></div></figure>


<h4>前缀和后缀操作符</h4>

<p>上面的例子是一个中缀操作符，类和结构体也可以提供一元操作符，可以区分前缀和后缀。</p>

<p>我们需要在函数前面写上 prefix 或 postfix来表示操作符是前缀还是后缀。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">prefix</span> <span class="n">func</span> <span class="o">-</span> <span class="p">(</span><span class="nl">vector</span><span class="p">:</span> <span class="n">Vector2D</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Vector2D</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">Vector2D</span><span class="p">(</span><span class="nl">x</span><span class="p">:</span> <span class="o">-</span><span class="n">vector</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="nl">y</span><span class="p">:</span> <span class="o">-</span><span class="n">vector</span><span class="p">.</span><span class="n">y</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">let</span> <span class="n">positive</span> <span class="o">=</span> <span class="n">Vector2D</span><span class="p">(</span><span class="nl">x</span><span class="p">:</span> <span class="mf">3.0</span><span class="p">,</span> <span class="nl">y</span><span class="p">:</span> <span class="mf">4.0</span><span class="p">)</span>
</span><span class='line'><span class="n">let</span> <span class="n">negative</span> <span class="o">=</span> <span class="o">-</span><span class="n">positive</span>
</span><span class='line'><span class="c1">// negative is a Vector2D instance with values of (-3.0, -4.0)</span>
</span><span class='line'><span class="n">let</span> <span class="n">alsoPositive</span> <span class="o">=</span> <span class="o">-</span><span class="n">negative</span>
</span><span class='line'><span class="c1">// alsoPositive is a Vector2D instance with values of (3.0, 4.0)</span>
</span></code></pre></td></tr></table></div></figure>


<h4>组合附值操作符</h4>

<p>组合附值操作符把附值操作符（=）和其他操作符组合起来。例如，+=是说把加法和附值操作符合为一个操作符。我们实现时需要把一个参数定义为 inout。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">func</span> <span class="o">+=</span> <span class="p">(</span><span class="k">inout</span> <span class="nl">left</span><span class="p">:</span> <span class="n">Vector2D</span><span class="p">,</span> <span class="nl">right</span><span class="p">:</span> <span class="n">Vector2D</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">left</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="n">right</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">var</span> <span class="n">original</span> <span class="o">=</span> <span class="n">Vector2D</span><span class="p">(</span><span class="nl">x</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="nl">y</span><span class="p">:</span> <span class="mf">2.0</span><span class="p">)</span>
</span><span class='line'><span class="n">let</span> <span class="n">vectorToAdd</span> <span class="o">=</span> <span class="n">Vector2D</span><span class="p">(</span><span class="nl">x</span><span class="p">:</span> <span class="mf">3.0</span><span class="p">,</span> <span class="nl">y</span><span class="p">:</span> <span class="mf">4.0</span><span class="p">)</span>
</span><span class='line'><span class="n">original</span> <span class="o">+=</span> <span class="n">vectorToAdd</span>
</span><span class='line'><span class="c1">// original now has values of (4.0, 6.0)</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们可以把前缀或后缀与组合附值操作符结合使用。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">prefix</span> <span class="n">func</span> <span class="o">++</span> <span class="p">(</span><span class="k">inout</span> <span class="nl">vector</span><span class="p">:</span> <span class="n">Vector2D</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Vector2D</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">vector</span> <span class="o">+=</span> <span class="n">Vector2D</span><span class="p">(</span><span class="nl">x</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="nl">y</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">)</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">vector</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">var</span> <span class="n">toIncrement</span> <span class="o">=</span> <span class="n">Vector2D</span><span class="p">(</span><span class="nl">x</span><span class="p">:</span> <span class="mf">3.0</span><span class="p">,</span> <span class="nl">y</span><span class="p">:</span> <span class="mf">4.0</span><span class="p">)</span>
</span><span class='line'><span class="n">let</span> <span class="n">afterIncrement</span> <span class="o">=</span> <span class="o">++</span><span class="n">toIncrement</span>
</span><span class='line'><span class="c1">// toIncrement now has values of (4.0, 5.0)</span>
</span><span class='line'><span class="c1">// afterIncrement also has values of (4.0, 5.0)</span>
</span></code></pre></td></tr></table></div></figure>


<pre><code>注意
我们无法重载默认的附值操作符（=）。另外，三元条件操作符（a?b:c）也不能被重载。
</code></pre>

<h4>相等操作符</h4>

<p>自定义的类和结构体，默认并会有 == 和 != 操作符。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">func</span> <span class="o">==</span> <span class="p">(</span><span class="nl">left</span><span class="p">:</span> <span class="n">Vector2D</span><span class="p">,</span> <span class="nl">right</span><span class="p">:</span> <span class="n">Vector2D</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Bool</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">(</span><span class="n">left</span><span class="p">.</span><span class="n">x</span> <span class="o">==</span> <span class="n">right</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">left</span><span class="p">.</span><span class="n">y</span> <span class="o">==</span> <span class="n">right</span><span class="p">.</span><span class="n">y</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">func</span> <span class="o">!=</span> <span class="p">(</span><span class="nl">left</span><span class="p">:</span> <span class="n">Vector2D</span><span class="p">,</span> <span class="nl">right</span><span class="p">:</span> <span class="n">Vector2D</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Bool</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="n">left</span> <span class="o">==</span> <span class="n">right</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们实现了 == 之后，在实现 != 时只需要取反即可。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">let</span> <span class="n">twoThree</span> <span class="o">=</span> <span class="n">Vector2D</span><span class="p">(</span><span class="nl">x</span><span class="p">:</span> <span class="mf">2.0</span><span class="p">,</span> <span class="nl">y</span><span class="p">:</span> <span class="mf">3.0</span><span class="p">)</span>
</span><span class='line'><span class="n">let</span> <span class="n">anotherTwoThree</span> <span class="o">=</span> <span class="n">Vector2D</span><span class="p">(</span><span class="nl">x</span><span class="p">:</span> <span class="mf">2.0</span><span class="p">,</span> <span class="nl">y</span><span class="p">:</span> <span class="mf">3.0</span><span class="p">)</span>
</span><span class='line'><span class="k">if</span> <span class="n">twoThree</span> <span class="o">==</span> <span class="n">anotherTwoThree</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="s">&quot;These two vectors are equivalent.&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">// prints &quot;These two vectors are equivalent.&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<h3>自定义操作符</h3>

<p>我们可以自定义和实现一些操作符。</p>

<p>新的操作符，定义在全局范围，使用 operator 关键字，标示为 prefix，infix或者postfix。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">prefix</span> <span class="n">operator</span> <span class="o">+++</span> <span class="p">{}</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们定义了一个 +++ 操作符，它对于Swift没有任何意义。所以可以被用于Vector2D。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">prefix</span> <span class="n">func</span> <span class="o">+++</span> <span class="p">(</span><span class="k">inout</span> <span class="nl">vector</span><span class="p">:</span> <span class="n">Vector2D</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Vector2D</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">vector</span> <span class="o">+=</span> <span class="n">vector</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">vector</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">var</span> <span class="n">toBeDoubled</span> <span class="o">=</span> <span class="n">Vector2D</span><span class="p">(</span><span class="nl">x</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="nl">y</span><span class="p">:</span> <span class="mf">4.0</span><span class="p">)</span>
</span><span class='line'><span class="n">let</span> <span class="n">afterDoubling</span> <span class="o">=</span> <span class="o">+++</span><span class="n">toBeDoubled</span>
</span><span class='line'><span class="c1">// toBeDoubled now has values of (2.0, 8.0)</span>
</span><span class='line'><span class="c1">// afterDoubling also has values of (2.0, 8.0)</span>
</span></code></pre></td></tr></table></div></figure>


<h4>自定义中缀操作符的优先级和关联性</h4>

<p>我们自定义中缀操作符时，还需要给出优先级和关联性。</p>

<p>关联性可以是，left，right或none。默认是none。优先级默认是100。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">infix</span> <span class="n">operator</span> <span class="o">+-</span> <span class="p">{</span> <span class="n">associativity</span> <span class="n">left</span> <span class="n">precedence</span> <span class="mi">140</span> <span class="p">}</span>
</span><span class='line'><span class="n">func</span> <span class="o">+-</span> <span class="p">(</span><span class="nl">left</span><span class="p">:</span> <span class="n">Vector2D</span><span class="p">,</span> <span class="nl">right</span><span class="p">:</span> <span class="n">Vector2D</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Vector2D</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">Vector2D</span><span class="p">(</span><span class="nl">x</span><span class="p">:</span> <span class="n">left</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">right</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="nl">y</span><span class="p">:</span> <span class="n">left</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">right</span><span class="p">.</span><span class="n">y</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">let</span> <span class="n">firstVector</span> <span class="o">=</span> <span class="n">Vector2D</span><span class="p">(</span><span class="nl">x</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="nl">y</span><span class="p">:</span> <span class="mf">2.0</span><span class="p">)</span>
</span><span class='line'><span class="n">let</span> <span class="n">secondVector</span> <span class="o">=</span> <span class="n">Vector2D</span><span class="p">(</span><span class="nl">x</span><span class="p">:</span> <span class="mf">3.0</span><span class="p">,</span> <span class="nl">y</span><span class="p">:</span> <span class="mf">4.0</span><span class="p">)</span>
</span><span class='line'><span class="n">let</span> <span class="n">plusMinusVector</span> <span class="o">=</span> <span class="n">firstVector</span> <span class="o">+-</span> <span class="n">secondVector</span>
</span><span class='line'><span class="c1">// plusMinusVector is a Vector2D instance with values of (4.0, -2.0)</span>
</span></code></pre></td></tr></table></div></figure>


<pre><code>注意
我们在定义前缀和后缀操作符时，不需要给出优先级。但是如果我们一个操作数同时使用前缀和后缀操作符时，后缀操作符优先执行。
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Language Guide: Access Controll]]></title>
    <link href="http://zxhfirefox.github.io/blog/2014/10/26/language-guide-h-access-contoll/"/>
    <updated>2014-10-26T23:27:07+08:00</updated>
    <id>http://zxhfirefox.github.io/blog/2014/10/26/language-guide-h-access-contoll</id>
    <content type="html"><![CDATA[<p>访问控制限制了我们从其他源文件和模块的代码访问我们代码能力。这一特性可以让你隐藏你实现的细节，并且给出一个预先定义的接口来暴露可以被访问的代码。</p>

<p>我们可以把访问控制添加到类型级别（类，结构体，枚举），也可以添加到单独的属性，方法，初始化函数和角标。协议可以被限制到特性的上下文，就像全局常量，变量和函数。</p>

<p>除了增加不同程度的访问限制，Swift通过特定环境给出特定默认访问级别来减少了需要明确给出访问级别的代码。事实上，如果我们在写一个单目标（single-target）的app，我们或许永远都不需要明确给出访问限制。</p>

<pre><code>注意
我们代码里可以被添加访问限制的内容（属性，类型，方法等等）在下文中都被引用为“个体”（entity）。
</code></pre>

<!-- more -->


<h3>模块和源文件</h3>

<p>Swift的访问控制模型是基于模块和源文件的概念。</p>

<p>一个模块（module）是代码分发的一个单一单元，一个框架或一个app可以作为一个单一单元编译，它可以被其他模块使用import来导入。</p>

<p>在Xcode里的每一个编译目标都在Swift里作为分开的模块对待。如果我们把我们app的部分代码分开组织成一个独立的框架（或许是为了封装，然后可以在多个app里使用），那么所有在这个框架内的定义都会作为这个独立模块的一部分，然后就可以被导入到这个app和其他app内使用。</p>

<p>一个源文件是在一个模块里的一个单独的Swift源代码文件。尽管我们一般在一个源文件里只定义一个类型，但是单个源文件可以定义多个类型。</p>

<h3>访问级别</h3>

<p>Swift提供了三种访问级别。这些级别和个体（entity）定义的源文件有关，也和这些源文件属于的模块有关。
    *   public，允许在他们自己定义的模块里的任何源文件都可以使用，并且那些导入了这个模块的任何模块也能使用。通常，我们使用public来提供框架的公开API。
    *   internal，允许在他们自己定义的模块里的任何源文件都可以使用，但是不能被模块外的源文件使用。通常，我们使用interval来提供app或框架内部使用的结构。
    *   private，限制了只有在同一个源文件内可以使用。使用private来保护代码的实现细节。</p>

<p>public是最高的访问级别，private是最低的访问级别</p>

<h4>访问级别指引原则</h4>

<p>Swift的访问级别有一个总领的原则：没有个体的访问级别可以定义成其他的更低的访问级别。</p>

<p>例如：
    *   一个public的变量不能被定义成一个internal或private类型。因为这个类型或许不能在所有地方被访问到。
    *   一个函数不能有比他们参数和返回值更高的访问街边，因为函数可能在他的组成类型不可用的时候被调用。</p>

<h4>默认访问级别</h4>

<p>所有的个体（除了极少数），在你不明确给出访问级别时，默认的访问级别都是internal。这样，很多情况下你都不用给出访问级别。</p>

<h4>单目标app的访问级别</h4>

<p>当我们在写一个单目标的app时，所有app内的代码应该只能在app内访问。默认的访问级别internal已经满足这一要求。所以，我们不用特别给出访问级别。但是，我们或许在某些地方需要把一些实现定义为private。</p>

<h4>框架的访问级别</h4>

<p>当我们开发框架时，我们需要把框架的公开API定义成public的。</p>

<pre><code>注意
任何的框架内的实现都还是默认的internal，或是private。我们仅仅把公开的API设定为public
</code></pre>

<h3>访问控制语法</h3>

<p>我们使用public，internal，private关键字来表示访问控制。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">public</span> <span class="k">class</span> <span class="n">SomePublicClass</span> <span class="p">{}</span>
</span><span class='line'><span class="n">internal</span> <span class="k">class</span> <span class="n">SomeInternalClass</span> <span class="p">{}</span>
</span><span class='line'><span class="n">private</span> <span class="k">class</span> <span class="n">SomePrivateClass</span> <span class="p">{}</span>
</span><span class='line'>
</span><span class='line'><span class="n">public</span> <span class="n">var</span> <span class="n">somePublicVariable</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'><span class="n">internal</span> <span class="n">let</span> <span class="n">someInternalConstant</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'><span class="n">private</span> <span class="n">func</span> <span class="n">somePrivateFunction</span><span class="p">()</span> <span class="p">{}</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果我们不需要特别给出，使用默认的internal时，我们就可以不写。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">class</span> <span class="n">SomeInternalClass</span> <span class="p">{}</span>              <span class="c1">// implicitly internal</span>
</span><span class='line'><span class="n">var</span> <span class="n">someInternalConstant</span> <span class="o">=</span> <span class="mi">0</span>            <span class="c1">// implicitly internal</span>
</span></code></pre></td></tr></table></div></figure>


<h3>自定义类型</h3>

<p>当我们需要给自定义类型设置访问控制级别时，在定义时的时候给出即可，这样这些类型就可以在访问控制允许的地方被使用。</p>

<p>类型的访问控制级别也会影响它的成员（属性，方法，初始化函数，角标）的默认访问级别。如果类型的访问级别是private，那么所有成员都是private。如果类型的访问级别是internal或public，成员的默认访问级别就是internal。</p>

<pre><code>注意
如上所述，public的类型的方法默认是internal的，不是public的。如果我们希望某个成员是public，需要明确指出。
</code></pre>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">public</span> <span class="k">class</span> <span class="n">SomePublicClass</span> <span class="p">{</span>          <span class="c1">// explicitly public class</span>
</span><span class='line'>    <span class="n">public</span> <span class="n">var</span> <span class="n">somePublicProperty</span> <span class="o">=</span> <span class="mi">0</span>    <span class="c1">// explicitly public class member</span>
</span><span class='line'>    <span class="n">var</span> <span class="n">someInternalProperty</span> <span class="o">=</span> <span class="mi">0</span>         <span class="c1">// implicitly internal class member</span>
</span><span class='line'>    <span class="n">private</span> <span class="n">func</span> <span class="n">somePrivateMethod</span><span class="p">()</span> <span class="p">{}</span>  <span class="c1">// explicitly private class member</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">class</span> <span class="n">SomeInternalClass</span> <span class="p">{</span>               <span class="c1">// implicitly internal class</span>
</span><span class='line'>    <span class="n">var</span> <span class="n">someInternalProperty</span> <span class="o">=</span> <span class="mi">0</span>         <span class="c1">// implicitly internal class member</span>
</span><span class='line'>    <span class="n">private</span> <span class="n">func</span> <span class="n">somePrivateMethod</span><span class="p">()</span> <span class="p">{}</span>  <span class="c1">// explicitly private class member</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">private</span> <span class="k">class</span> <span class="n">SomePrivateClass</span> <span class="p">{</span>        <span class="c1">// explicitly private class</span>
</span><span class='line'>    <span class="n">var</span> <span class="n">somePrivateProperty</span> <span class="o">=</span> <span class="mi">0</span>          <span class="c1">// implicitly private class member</span>
</span><span class='line'>    <span class="n">func</span> <span class="n">somePrivateMethod</span><span class="p">()</span> <span class="p">{}</span>          <span class="c1">// implicitly private class member</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>元组类型</h4>

<p>元组的访问级别是它的所有元素中访问级别最低的元素的访问级别。例如，如果一个元组含有2个不同类型的元素，一个internal，一个private，那么这个元组的访问级别就是private。</p>

<pre><code>注意
元组的访问级别并不和类，结构体，枚举，函数一样是单独定义的。它的访问级别实在使用时推断出来的，不能显式的定义。
</code></pre>

<h4>函数类型</h4>

<p>函数的访问级别是通过计算它的参数和返回值类型的最低访问级别决定的。如果函数计算后的访问级别和上下文默认的不一致，我们需要明确给出函数的访问级别。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">func</span> <span class="nf">someFunction</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">SomeInternalClass</span><span class="p">,</span> <span class="n">SomePrivateClass</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// function implementation goes here</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个全局函数，没有明确给出访问级别，如果我们认为他是internal的，那就错了，事实上，这段代码无法编译。</p>

<p>这个函数的返回类型是一个元组，元组的元素一个是internal的类，一个是private的类。那么元组的访问级别就是private。</p>

<p>因为元组的访问级别是private的，我们需要把函数标示为private才能编译通过。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">private</span> <span class="n">func</span> <span class="nf">someFunction</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">SomeInternalClass</span><span class="p">,</span> <span class="n">SomePrivateClass</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// function implementation goes here</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们不能把这个函数标记为public或是默认的internal。因为这个函数使用者无法使用private的返回值。</p>

<h4>枚举类型</h4>

<p>枚举的各种情况自动和枚举的访问级别一致。我们没法给枚举的case单独给出访问级别。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">public</span> <span class="k">enum</span> <span class="n">CompassPoint</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">North</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">South</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">East</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">West</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面定义这个枚举和他的case都是公开的。</p>

<h4>原始值和关联值</h4>

<p>枚举使用任何原始值和关联值的访问级别都必须枚举的访问级别要高。我们不能在一个internal的枚举里使用private的原始值或关联值。</p>

<h4>嵌套类型</h4>

<p>定义在private里的嵌套类型默认是private的。</p>

<p>定义在public里的嵌套类型默认是internal的。</p>

<p>如果我们希望一个在public里的嵌套类型是public的，我们明确给出。</p>

<h3>子类</h3>

<p>我们可以继承从当前上下文可以访问的任何类。子类的访问级别不会高于父类的，例如，我们无法继承自一个internal的，自身是public得类。</p>

<p>另外，我们可以重写任何的在上下文可以访问的父类的成员（方法，属性，初始化函数，角标）。</p>

<p>重写可以让子类的元素比父类更加可被访问。下面的例子里，public的类A，定义了private的方法someMethod，但是，子类B把someMethod重写成了internal。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">public</span> <span class="k">class</span> <span class="n">A</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">private</span> <span class="n">func</span> <span class="n">someMethod</span><span class="p">()</span> <span class="p">{}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">internal</span> <span class="k">class</span> <span class="nl">B</span><span class="p">:</span> <span class="n">A</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">override</span> <span class="n">internal</span> <span class="n">func</span> <span class="n">someMethod</span><span class="p">()</span> <span class="p">{}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>甚至于子类的成员可以去调用父类的更低的访问许可的成员，只要这个父类的调用在上下文里是允许的（意思是，在一个源文件里，调用父类的private犯法，或是在一个模块里，调用父类的internal方法）。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">public</span> <span class="k">class</span> <span class="n">A</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">private</span> <span class="n">func</span> <span class="n">someMethod</span><span class="p">()</span> <span class="p">{}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">internal</span> <span class="k">class</span> <span class="nl">B</span><span class="p">:</span> <span class="n">A</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">override</span> <span class="n">internal</span> <span class="n">func</span> <span class="n">someMethod</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="nb">super</span><span class="p">.</span><span class="n">someMethod</span><span class="p">()</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>因为类A和B定义在一个源文件里，所以B的someMethod可以调用A的private的someMethod。</p>

<h3>常量，变量，属性和角标</h3>

<p>一个常量，变量，属性不能比他们的类型更加的公开。例如，我们不能给一个public的属性写一个private类型。同时，角标也不能比索引类型或返回类型更加公开。</p>

<p>如果一个常量，变量，属性或角标使用了private的类型，那么他们自己也必须是private的。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">private</span> <span class="n">var</span> <span class="n">privateInstance</span> <span class="o">=</span> <span class="n">SomePrivateClass</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<h4>Getter和Setter</h4>

<p>常量，变量，属性和角标的Getter和Setter自动的和他们属于的常量，变量，属性和角标的访问级别一样。</p>

<p>我们可以给变量，属性，角标比他们的对应的getter更低的setter来限制写。通过在var和subscript前面写internal(set)和private(set)。</p>

<pre><code>注意
注意规则既可以在存储属性上使用，也可以在计算属性上使用。即使我们没有给存储属性明确的给出一个getter和setter。Swift会自动生成他们。
</code></pre>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">struct</span> <span class="n">TrackedString</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">private</span><span class="p">(</span><span class="n">set</span><span class="p">)</span> <span class="n">var</span> <span class="n">numberOfEdits</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'>    <span class="n">var</span> <span class="nl">value</span><span class="p">:</span> <span class="n">String</span> <span class="o">=</span> <span class="s">&quot;&quot;</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">didSet</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">numberOfEdits</span><span class="o">++</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>TrackedString结构体的存储属性numberOfEdits被设置为private(set)。而value和TrackedString本身都是默认的internal。numberOfEdits的getter依然是默认的internal。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">var</span> <span class="n">stringToEdit</span> <span class="o">=</span> <span class="n">TrackedString</span><span class="p">()</span>
</span><span class='line'><span class="n">stringToEdit</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="s">&quot;This string will be tracked.&quot;</span>
</span><span class='line'><span class="n">stringToEdit</span><span class="p">.</span><span class="n">value</span> <span class="o">+=</span> <span class="s">&quot; This edit will increment numberOfEdits.&quot;</span>
</span><span class='line'><span class="n">stringToEdit</span><span class="p">.</span><span class="n">value</span> <span class="o">+=</span> <span class="s">&quot; So will this one.&quot;</span>
</span><span class='line'><span class="n">println</span><span class="p">(</span><span class="s">&quot;The number of edits is \(stringToEdit.numberOfEdits)&quot;</span><span class="p">)</span>
</span><span class='line'><span class="c1">// prints &quot;The number of edits is 3&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>事实上，如果需要我们可以显式给出getter和setter的访问级别。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">public</span> <span class="k">struct</span> <span class="n">TrackedString</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">public</span> <span class="n">private</span><span class="p">(</span><span class="n">set</span><span class="p">)</span> <span class="n">var</span> <span class="n">numberOfEdits</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'>    <span class="n">public</span> <span class="n">var</span> <span class="nl">value</span><span class="p">:</span> <span class="n">String</span> <span class="o">=</span> <span class="s">&quot;&quot;</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">didSet</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">numberOfEdits</span><span class="o">++</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">public</span> <span class="n">init</span><span class="p">()</span> <span class="p">{}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>初始化函数</h3>

<p>自定义的初始化函数的访问级别必须少于或等于他们的类型。除了需要的初始化函数，一个需要的初始化函数必须和它的类型有着同样的访问级别。</p>

<p>和函数和方法一样，初始化函数的参数的访问级别不能比初始化函数更低。</p>

<h4>默认初始化函数</h4>

<p>Swift会给任何的结构体和基类提供一个没有任何参数的默认初始化函数，只要这些结构体或基类的所有属性都有默认值，并且自己没有定义任何的初始化函数。</p>

<p>默认初始化函数的访问级别和类型的一致，除非类型是public的。如果类型是public的，默认初始化函数就是internal的。如果我们需要一个public的，我们需要自己定义。</p>

<h3>协议</h3>

<p>我们可以给协议也设置访问级别，这样可以限制实现协议的类型。</p>

<p>协议里所有的要求的访问级别和协议一致。</p>

<pre><code>注意
如果我们把协议定义为public，那协议的所有要求都必须是public的实现。这一点和其他类型不一样，一个public的类型可能有internal的成员。
</code></pre>

<h4>协议继承</h4>

<p>如果我们继承一个协议，那么新的协议至少要和已有协议一样的访问限制。我们不能继承一个internal的协议而定义成public的。</p>

<h4>协议实现</h4>

<p>类型可以实现比自己访问级别更低的协议。例如，我们定义一个public类型，然后可以实现一些internal的协议。</p>

<p>类型实现协议后的上下文是类型访问级别和协议访问级别的最小值。例如，如果类型是public，协议是internal，那么类型的协议实现就是internal。</p>

<p>如果我们写或者扩展一个类型来实现一个协议，我们必须确保类型对于协议要求的实现至少要和类型对于协议实现的访问级别一致。例如，如果一个public类型要实现一个internal的协议，那这个类型对于协议要求的实现至少要是internal的。</p>

<pre><code>注意
在Swift，和ObjC一样，协议实现是全局的，我们不可能在一个程序里，让一个类型通过两种不同的方式实现一个协议。
</code></pre>

<h3>扩展</h3>

<p>我们可以在当一个类，结构体，枚举可以被访问的时候扩展他们。在扩展里添加的任何成员都和原始成员一样有默认的访问级别。例如，如果我们扩展一个public类型，任何新添加的成员的默认访问级别都是internal。</p>

<p>但是，我们可以给扩展设置一个访问级别来修改所有扩展里添加的成员的访问级别。这个新设置的访问级别依然可以被单个成员的访问级别所覆盖。</p>

<h4>在扩展中实现协议</h4>

<p>如果一个扩展是用来实现协议，那么我们不能在这样扩展中重新给出扩展的访问级别。相反，协议本身的访问级别被用来给扩展里的新成员提供默认访问级别。</p>

<h3>泛型</h3>

<p>泛型函数和泛型类型的访问级别是他们本身和类型参数的访问级别的最小值。</p>

<h3>类型别名</h3>

<p>对于访问级别，任何的类型别名都被认为是独立的类型。一个类型别名可以有比原始类型更低或相等的访问级别。例如，一个私有类型别名可以作为一个private，internal，public的类型的别名，但是一个public的类型别名不能做为一个internal或private的类型的别名。</p>

<pre><code>注意
这一规则在实现协议时使用的关联类型同样适用。
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Language Guide: Generics]]></title>
    <link href="http://zxhfirefox.github.io/blog/2014/10/26/language-guide-generics/"/>
    <updated>2014-10-26T23:25:21+08:00</updated>
    <id>http://zxhfirefox.github.io/blog/2014/10/26/language-guide-generics</id>
    <content type="html"><![CDATA[<p>泛型可以帮助我们写出灵活的，可重用的函数和类型，他们可以使用任何类型来满足我们的要求。我们可以写出目的明确，抽象清晰的代码。</p>

<p>泛型是Swift最强大的几个特性之一，并且Swift的标准库很多都是用泛型来做的。事实上，我们可能没有意识到，但是我们已经一直在用泛型了。例如，Array和Dictionary类型都是泛型集合。我们可以创建一个元素为Int的数组，也可以创建一个元素为String的数组，或者其他任何Swift的类型。相同的，我们也可以创建不同类型的字典。</p>

<!-- more -->


<h3>泛型所解决的问题</h3>

<p>下面是交换2个Int的一个函数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">func</span> <span class="nf">swapTwoInts</span><span class="p">(</span><span class="k">inout</span> <span class="nl">a</span><span class="p">:</span> <span class="n">Int</span><span class="p">,</span> <span class="k">inout</span> <span class="nl">b</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">temporaryA</span> <span class="o">=</span> <span class="n">a</span>
</span><span class='line'>    <span class="n">a</span> <span class="o">=</span> <span class="n">b</span>
</span><span class='line'>    <span class="n">b</span> <span class="o">=</span> <span class="n">temporaryA</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们使用他们来交换2个整数。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">var</span> <span class="n">someInt</span> <span class="o">=</span> <span class="mi">3</span>
</span><span class='line'><span class="n">var</span> <span class="n">anotherInt</span> <span class="o">=</span> <span class="mi">107</span>
</span><span class='line'><span class="n">swapTwoInts</span><span class="p">(</span><span class="o">&amp;</span><span class="n">someInt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">anotherInt</span><span class="p">)</span>
</span><span class='line'><span class="n">println</span><span class="p">(</span><span class="s">&quot;someInt is now \(someInt), and anotherInt is now \(anotherInt)&quot;</span><span class="p">)</span>
</span><span class='line'><span class="c1">// prints &quot;someInt is now 107, and anotherInt is now 3&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>swapTwoInts是可用的，但是他只能交换两个Int，如果我们需要交换两个String，或者Double，我们就需要再写更多的方法，例如swapTwoStrings和swapTwoDoubles。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">func</span> <span class="nf">swapTwoStrings</span><span class="p">(</span><span class="k">inout</span> <span class="nl">a</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span> <span class="k">inout</span> <span class="nl">b</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">temporaryA</span> <span class="o">=</span> <span class="n">a</span>
</span><span class='line'>    <span class="n">a</span> <span class="o">=</span> <span class="n">b</span>
</span><span class='line'>    <span class="n">b</span> <span class="o">=</span> <span class="n">temporaryA</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">func</span> <span class="nf">swapTwoDoubles</span><span class="p">(</span><span class="k">inout</span> <span class="nl">a</span><span class="p">:</span> <span class="n">Double</span><span class="p">,</span> <span class="k">inout</span> <span class="nl">b</span><span class="p">:</span> <span class="n">Double</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">temporaryA</span> <span class="o">=</span> <span class="n">a</span>
</span><span class='line'>    <span class="n">a</span> <span class="o">=</span> <span class="n">b</span>
</span><span class='line'>    <span class="n">b</span> <span class="o">=</span> <span class="n">temporaryA</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们可以发现，这三个函数的函数体是很相似的，唯一不同的就是处理的参数类型。</p>

<p>如果我们可以写出一个函数，他可以交换任意两个类型，那么我们的代码就会很简洁，而泛型就是为了这一目的而存在的语言特性。</p>

<pre><code>注意
上面三个函数，有一个隐含的要求，就是a和b的类型是一样的，如果他们的类型不一样，也就不可能交换他们的值。
</code></pre>

<h3>泛型函数</h3>

<p>泛型函数可以使用任何值。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">func</span> <span class="n">swapTwoValues</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="k">inout</span> <span class="nl">a</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="k">inout</span> <span class="nl">b</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">temporaryA</span> <span class="o">=</span> <span class="n">a</span>
</span><span class='line'>    <span class="n">a</span> <span class="o">=</span> <span class="n">b</span>
</span><span class='line'>    <span class="n">b</span> <span class="o">=</span> <span class="n">temporaryA</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>swapTwoValues的函数体和swapTwoInts的完全一样，但是，函数的第一行区别很大。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">func</span> <span class="n">swapTwoInts</span><span class="p">(</span><span class="k">inout</span> <span class="nl">a</span><span class="p">:</span> <span class="n">Int</span><span class="p">,</span> <span class="k">inout</span> <span class="nl">b</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span>
</span><span class='line'><span class="n">func</span> <span class="n">swapTwoValues</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="k">inout</span> <span class="nl">a</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="k">inout</span> <span class="nl">b</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>泛型的版本，有一个占位符类型（这里是 T），而不是特定的某个类型（例如Int，String）。占位符类型没有说任何关于类型的信息，但是却表示了a和b必须是同一类型。真正的类型会在调用时决定。</p>

<p>另一个不同是泛型函数的名字后面跟着占位符类型，包裹在一个尖括号里。尖括号告诉Swift T是一个类型名字的占位符，因为他是占位符，Swift不会去寻找真实的T类型。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">var</span> <span class="n">someInt</span> <span class="o">=</span> <span class="mi">3</span>
</span><span class='line'><span class="n">var</span> <span class="n">anotherInt</span> <span class="o">=</span> <span class="mi">107</span>
</span><span class='line'><span class="n">swapTwoValues</span><span class="p">(</span><span class="o">&amp;</span><span class="n">someInt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">anotherInt</span><span class="p">)</span>
</span><span class='line'><span class="c1">// someInt is now 107, and anotherInt is now 3</span>
</span><span class='line'><span class="n">var</span> <span class="n">someString</span> <span class="o">=</span> <span class="s">&quot;hello&quot;</span>
</span><span class='line'><span class="n">var</span> <span class="n">anotherString</span> <span class="o">=</span> <span class="s">&quot;world&quot;</span>
</span><span class='line'><span class="n">swapTwoValues</span><span class="p">(</span><span class="o">&amp;</span><span class="n">someString</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">anotherString</span><span class="p">)</span>
</span><span class='line'><span class="c1">// someString is now &quot;world&quot;, and anotherString is now &quot;hello&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们可以给swapTwoValues传递Int或String或任何类型。</p>

<pre><code>注意
swapTwoValues的名字来自于Swift的标准库的swap函数。如果我们需要，可以直接使用。
</code></pre>

<h3>类型参数</h3>

<p>在上面的例子里，T是一个类型参数。类型参数表示了一个占位符类型，紧跟着函数名，包裹在尖括号里。</p>

<p>我们表明一个类型参数之后，我们就可以定义这个类型的参数（例子里的a和b），或者返回值类型，或者在函数体里使用。不论如何，这个占位符类型都会被调用时的实际类型所取代。</p>

<p>我们可以提供多个类型参数，都写在尖括号里，逗号隔开。</p>

<h3>命名类型参数</h3>

<p>简单的情况下，泛型函数和泛型类型只会用到一个类型参数（例如上面的例子和Array），传统上就使用T来表示。然而我们可以使用任何符合规则的标示符。</p>

<p>如果我们在写比较复杂的泛型函数和泛型类型，他们需要多个类型参数，那么给类型参数一些有意义的名字就非常有意义了。例如，Swift的Dictionay类型，有两个类型参数，分别是Key和Value。</p>

<pre><code>注意
类型参数的名字应该是首字母大写的驼峰格式，这样说明他是一个类型的占位符。
</code></pre>

<h3>泛型类型</h3>

<p>除了泛型函数，Swift还允许我们定义自己的泛型类型。这些自定义的类，结构体，枚举可以使用任何类型作为类型参数，就和Array，Dictionary一样。</p>

<p>这部分我们将实现一个泛型的集合，栈。栈是一个有序的集合，和数组很像。但存取方式有很大区别，数组允许在任意地方存取，而栈，只能从最顶部的元素存取。</p>

<pre><code>注意
UINavigationController的push和pop，就是栈的一个很好的例子。在你需要后进先出得时候，就应该使用栈。
</code></pre>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">struct</span> <span class="n">IntStack</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">var</span> <span class="n">items</span> <span class="o">=</span> <span class="p">[</span><span class="n">Int</span><span class="p">]()</span>
</span><span class='line'>    <span class="n">mutating</span> <span class="n">func</span> <span class="n">push</span><span class="p">(</span><span class="nl">item</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">items</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">mutating</span> <span class="n">func</span> <span class="n">pop</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Int</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">items</span><span class="p">.</span><span class="n">removeLast</span><span class="p">()</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这是一个非泛型的栈的定义。我们用一个数组来作为内部存数的容器，然后实现push和pop。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">struct</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">var</span> <span class="n">items</span> <span class="o">=</span> <span class="p">[</span><span class="n">T</span><span class="p">]()</span>
</span><span class='line'>    <span class="n">mutating</span> <span class="n">func</span> <span class="n">push</span><span class="p">(</span><span class="nl">item</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">items</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">mutating</span> <span class="n">func</span> <span class="n">pop</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">T</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">items</span><span class="p">.</span><span class="n">removeLast</span><span class="p">()</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>IntStack只能处理Int类型，我们把它改写为泛型之后，就可以处理任何类型。</p>

<p>注意，占位符类型T，在三个地方使用：
    *   创建一个items的属性，是T类型的一个空数组
    *   标明push函数接受的参数必须是T类型
    *   标明pop函数返回的类型是T类型</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">var</span> <span class="n">stackOfStrings</span> <span class="o">=</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="p">()</span>
</span><span class='line'><span class="n">stackOfStrings</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="s">&quot;uno&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">stackOfStrings</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="s">&quot;dos&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">stackOfStrings</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="s">&quot;tres&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">stackOfStrings</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="s">&quot;cuatro&quot;</span><span class="p">)</span>
</span><span class='line'><span class="c1">// the stack now contains 4 strings</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">let</span> <span class="n">fromTheTop</span> <span class="o">=</span> <span class="n">stackOfStrings</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
</span><span class='line'><span class="c1">// fromTheTop is equal to &quot;cuatro&quot;, and the stack now contains 3 strings</span>
</span></code></pre></td></tr></table></div></figure>


<h3>扩展一个泛型类型</h3>

<p>当我们扩展一个泛型类型时，我们不需要在扩展定义时给出类型参数列表。原始类型的类型参数列表在我们的扩展内自动可见的，类型参数的名字也和原始类型一致。</p>

<p>下面，我们扩展Stack类型，添加一个返回顶部元素的只读的计算属性。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">extension</span> <span class="n">Stack</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">var</span> <span class="nl">topItem</span><span class="p">:</span> <span class="n">T</span><span class="o">?</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">items</span><span class="p">.</span><span class="n">isEmpty</span> <span class="o">?</span> <span class="nb">nil</span> <span class="o">:</span> <span class="n">items</span><span class="p">[</span><span class="n">items</span><span class="p">.</span><span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意，没有这里扩展没有给出类型参数，而是直接使用了Stack原始定义时的T。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">if</span> <span class="n">let</span> <span class="n">topItem</span> <span class="o">=</span> <span class="n">stackOfStrings</span><span class="p">.</span><span class="n">topItem</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="s">&quot;The top item on the stack is \(topItem).&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">// prints &quot;The top item on the stack is tres.&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<h3>类型限制</h3>

<p>swapTwoValues和Stack可以使用任何类型，但是，有时候我们需要限定只有特殊的类型才可以作为参数传递给泛型函数和泛型类型。类型限制就表明了类型参数必须是继承自某个类，或是必须实现了某个协议或协议组。</p>

<p>例如，Swift的Dictionary类型就限制了可以作为键的类型，这个类型必须是可以哈希的。也就是说，必须可以给出一种方式来使得自己是唯一的。而字典使用这个哈希来检查是否已经有相同的key存在，如果没有这个限制，字典就无法知道是否改插入还是替换某一个键，也无法根据键来找到对应的值。</p>

<p>这个要求是强制在Dictionary的键的类型上，必须实现Hashable协议。Swift的所有基础类型（Int，String，Double，Bool）都实现了这一协议。</p>

<p>我们可以定义自己的类型限制。像Hashable这样的抽象帮我们定义了一些概念上的特性，而不是特定的类型。</p>

<h4>类型限制语法</h4>

<p>我们在类型参数列表里的参数后面加上冒号，跟着需要继承的类或需要实现的协议来定义类型限制。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">func</span> <span class="n">someFunction</span><span class="o">&lt;</span><span class="nl">T</span><span class="p">:</span> <span class="n">SomeClass</span><span class="p">,</span> <span class="nl">U</span><span class="p">:</span> <span class="n">SomeProtocol</span><span class="o">&gt;</span><span class="p">(</span><span class="nl">someT</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="nl">someU</span><span class="p">:</span> <span class="n">U</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// function body goes here</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的函数，定义了两个类型参数，T和U，他们两个分别需要继承自SomeClass和实现SomeProtocol。</p>

<h4>类型限制实践</h4>

<p>下面是一个非泛型的函数，来在一个数组里查找某个值第一次出现的索引。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">func</span> <span class="nf">findStringIndex</span><span class="p">(</span><span class="nl">array</span><span class="p">:</span> <span class="p">[</span><span class="n">String</span><span class="p">],</span> <span class="nl">valueToFind</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Int</span><span class="o">?</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="k">in</span> <span class="n">enumerate</span><span class="p">(</span><span class="n">array</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="n">valueToFind</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="n">index</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="nb">nil</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">let</span> <span class="n">strings</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;cat&quot;</span><span class="p">,</span> <span class="s">&quot;dog&quot;</span><span class="p">,</span> <span class="s">&quot;llama&quot;</span><span class="p">,</span> <span class="s">&quot;parakeet&quot;</span><span class="p">,</span> <span class="s">&quot;terrapin&quot;</span><span class="p">]</span>
</span><span class='line'><span class="k">if</span> <span class="n">let</span> <span class="n">foundIndex</span> <span class="o">=</span> <span class="n">findStringIndex</span><span class="p">(</span><span class="n">strings</span><span class="p">,</span> <span class="s">&quot;llama&quot;</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="s">&quot;The index of llama is \(foundIndex)&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">// prints &quot;The index of llama is 2&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>这种查找，不单对于String需要，其他类型也会需要。所以我们应该写成泛型的。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">func</span> <span class="n">findIndex</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nl">array</span><span class="p">:</span> <span class="p">[</span><span class="n">T</span><span class="p">],</span> <span class="nl">valueToFind</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Int</span><span class="o">?</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="k">in</span> <span class="n">enumerate</span><span class="p">(</span><span class="n">array</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="n">valueToFind</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="n">index</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="nb">nil</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们这么写后，并没有办法编译，因为在我们检查value == valueToFind的时候，不是所有的Swift类型都定义了 == 操作符。比如我们自己定义的类型，相等的意义并不是Swift可以给我们提供的。所以我们无法保证每个T都满足要求。</p>

<p>尽管如此，Swift标准科定义了一个Equatable的协议，它需要任何实现的类型提供 == 和 != 操作符用来比较。所有的Swift标准类型都实现了这一协议。</p>

<p>那么所有的实现了Equatable得类型都是在findIndex中使用，这样我们就需要限制我们的类型必须是实现了Equatable协议的类型。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">func</span> <span class="n">findIndex</span><span class="o">&lt;</span><span class="nl">T</span><span class="p">:</span> <span class="n">Equatable</span><span class="o">&gt;</span><span class="p">(</span><span class="nl">array</span><span class="p">:</span> <span class="p">[</span><span class="n">T</span><span class="p">],</span> <span class="nl">valueToFind</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Int</span><span class="o">?</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="k">in</span> <span class="n">enumerate</span><span class="p">(</span><span class="n">array</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="n">valueToFind</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="n">index</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="nb">nil</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">let</span> <span class="n">doubleIndex</span> <span class="o">=</span> <span class="n">findIndex</span><span class="p">([</span><span class="mf">3.14159</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">],</span> <span class="mf">9.3</span><span class="p">)</span>
</span><span class='line'><span class="c1">// doubleIndex is an optional Int with no value, because 9.3 is not in the array</span>
</span><span class='line'><span class="n">let</span> <span class="n">stringIndex</span> <span class="o">=</span> <span class="n">findIndex</span><span class="p">([</span><span class="s">&quot;Mike&quot;</span><span class="p">,</span> <span class="s">&quot;Malcolm&quot;</span><span class="p">,</span> <span class="s">&quot;Andrea&quot;</span><span class="p">],</span> <span class="s">&quot;Andrea&quot;</span><span class="p">)</span>
</span><span class='line'><span class="c1">// stringIndex is an optional Int containing a value of 2</span>
</span></code></pre></td></tr></table></div></figure>


<h3>关联的类型</h3>

<p>当我们定义协议的时候，可以声明一个或多个关联的类型来作为协议定义的一部分。一个关联的类型就是给定一个类型的占位符，然后可以在协议定义中使用。真实的类型，直到协议被真实实现的时候才会确定。关联的类型由 typealias 关键字声明。</p>

<h4>关联类型实践</h4>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">protocol</span> <span class="n">Container</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">typealias</span> <span class="n">ItemType</span>
</span><span class='line'>    <span class="n">mutating</span> <span class="n">func</span> <span class="n">append</span><span class="p">(</span><span class="nl">item</span><span class="p">:</span> <span class="n">ItemType</span><span class="p">)</span>
</span><span class='line'>    <span class="n">var</span> <span class="nl">count</span><span class="p">:</span> <span class="n">Int</span> <span class="p">{</span> <span class="n">get</span> <span class="p">}</span>
</span><span class='line'>    <span class="n">subscript</span><span class="p">(</span><span class="nl">i</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ItemType</span> <span class="p">{</span> <span class="n">get</span> <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们定义了一个Container协议，里面关联了一个ItemType。</p>

<p>Container协议定义了一个方法来追加元素，一个属性来获取元素数量，一个角标来访问元素。</p>

<p>它没有说明，元素是如何存储的，也没有说明元素的类型是什么。一个实现这个协议的类型，只需要实现上面三点要求即可。</p>

<p>任何实现Container协议的类型必须可以说明它存储的元素类型。确切来讲，就是他必须保证只有正确的类型可以被添加到容器内，或者被访问。</p>

<p>为了描述这种要求，Container协议需要一种方法来说明容器元素的类型，但是它又不需要知道是什么类型。</p>

<p>为了达到这点要求，Container声明了一个关联类型ItemType。Container协议没有定义ItemType，而是把ItemType作为一种方式来表示容器内的元素类型，并在协议定义中使用它来确保协议的行为是正确的。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">struct</span> <span class="nl">IntStack</span><span class="p">:</span> <span class="n">Container</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// original IntStack implementation</span>
</span><span class='line'>    <span class="n">var</span> <span class="n">items</span> <span class="o">=</span> <span class="p">[</span><span class="n">Int</span><span class="p">]()</span>
</span><span class='line'>    <span class="n">mutating</span> <span class="n">func</span> <span class="n">push</span><span class="p">(</span><span class="nl">item</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">items</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">mutating</span> <span class="n">func</span> <span class="n">pop</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Int</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">items</span><span class="p">.</span><span class="n">removeLast</span><span class="p">()</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="c1">// conformance to the Container protocol</span>
</span><span class='line'>    <span class="n">typealias</span> <span class="n">ItemType</span> <span class="o">=</span> <span class="n">Int</span>
</span><span class='line'>    <span class="n">mutating</span> <span class="n">func</span> <span class="n">append</span><span class="p">(</span><span class="nl">item</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">var</span> <span class="nl">count</span><span class="p">:</span> <span class="n">Int</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">items</span><span class="p">.</span><span class="n">count</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">subscript</span><span class="p">(</span><span class="nl">i</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Int</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">items</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这是一个非泛型的Container协议的实现。它把ItemType定义为了Int。</p>

<p>因为Swift强大的类型推导，我们其实可以不写 typealias ItemType = Int，因为通过append方法，就可以推导出容器元素的类型了。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">struct</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;:</span> <span class="n">Container</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// original Stack&lt;T&gt; implementation</span>
</span><span class='line'>    <span class="n">var</span> <span class="n">items</span> <span class="o">=</span> <span class="p">[</span><span class="n">T</span><span class="p">]()</span>
</span><span class='line'>    <span class="n">mutating</span> <span class="n">func</span> <span class="n">push</span><span class="p">(</span><span class="nl">item</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">items</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">mutating</span> <span class="n">func</span> <span class="n">pop</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">T</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">items</span><span class="p">.</span><span class="n">removeLast</span><span class="p">()</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="c1">// conformance to the Container protocol</span>
</span><span class='line'>    <span class="n">mutating</span> <span class="n">func</span> <span class="n">append</span><span class="p">(</span><span class="nl">item</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">var</span> <span class="nl">count</span><span class="p">:</span> <span class="n">Int</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">items</span><span class="p">.</span><span class="n">count</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">subscript</span><span class="p">(</span><span class="nl">i</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">items</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这一次，我们用泛型的方式来实现Container容器，因为我们用T来作为append方法的参数的类型,Swift会把ItemType关联到T。</p>

<h4>扩展一个已有类型来给出关联类型</h4>

<p>我们可以通过扩展类型来增加协议的实现。这也包括了还有关联类型的协议。</p>

<p>Swift的Array已经提供了append方法，count属性和角标。这些正好满足了Container协议。这样我们就可以简单的写一个扩展来让Array实现Container协议。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">extension</span> <span class="nl">Array</span><span class="p">:</span> <span class="n">Container</span> <span class="p">{}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Array已有的append方法和角标会告诉Swift如何正确的推导ItemType的类型。</p>

<h3>Where分句</h3>

<p>类型限制，可以让我们定义关联到泛型函数和泛型类型的类型参数的要求。</p>

<p>有时候我们需要能给关联类型也定义要求。我们可以通过在类型参数列表上添加where分句来做到这一点。where分句使得我们可以要求一个关联的类型必须实现某个协议，或者某个类型参数和关联的类型必须一样。我们把where分句就写在类型参数列表的后面。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">func</span> <span class="n">allItemsMatch</span><span class="o">&lt;</span>
</span><span class='line'>    <span class="nl">C1</span><span class="p">:</span> <span class="n">Container</span><span class="p">,</span> <span class="nl">C2</span><span class="p">:</span> <span class="n">Container</span>
</span><span class='line'>    <span class="n">where</span> <span class="n">C1</span><span class="p">.</span><span class="n">ItemType</span> <span class="o">==</span> <span class="n">C2</span><span class="p">.</span><span class="n">ItemType</span><span class="p">,</span><span class="n">C1</span><span class="p">.</span><span class="nl">ItemType</span><span class="p">:</span> <span class="n">Equatable</span><span class="o">&gt;</span>
</span><span class='line'>    <span class="p">(</span><span class="nl">someContainer</span><span class="p">:</span> <span class="n">C1</span><span class="p">,</span><span class="nl">anotherContainer</span><span class="p">:</span> <span class="n">C2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Bool</span> <span class="p">{</span>
</span><span class='line'>         <span class="c1">// check that both containers contain the same number of items</span>
</span><span class='line'>        <span class="k">if</span> <span class="n">someContainer</span><span class="p">.</span><span class="n">count</span> <span class="o">!=</span> <span class="n">anotherContainer</span><span class="p">.</span><span class="n">count</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="nb">false</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="c1">// check each pair of items to see if they are equivalent</span>
</span><span class='line'>        <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mf">0.</span><span class="p">.</span><span class="o">&lt;</span><span class="n">someContainer</span><span class="p">.</span><span class="n">count</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">if</span> <span class="n">someContainer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">anotherContainer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">{</span>
</span><span class='line'>                <span class="k">return</span> <span class="nb">false</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>         <span class="c1">// all items match, so return true</span>
</span><span class='line'>        <span class="k">return</span> <span class="nb">true</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>allItemsMatch的函数有2个参数，他们都是实现了Container协议的容器，这里我们使用where分句添加了一些限制，使得整个参数的要求变成了：
    *   C1和C2都必须实现Container协议
    *   C1的ItemType和C2的ItemType必须一致
    *   C1的ItemType必须实现Equatable协议，因为C1和C2的ItemType一致，所以C2的ItemType也是实现了Equatable的。</p>

<p>第二，三个要求是由where分句增加的。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">var</span> <span class="n">stackOfStrings</span> <span class="o">=</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="p">()</span>
</span><span class='line'><span class="n">stackOfStrings</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="s">&quot;uno&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">stackOfStrings</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="s">&quot;dos&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">stackOfStrings</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="s">&quot;tres&quot;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="n">var</span> <span class="n">arrayOfStrings</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;uno&quot;</span><span class="p">,</span> <span class="s">&quot;dos&quot;</span><span class="p">,</span> <span class="s">&quot;tres&quot;</span><span class="p">]</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="n">allItemsMatch</span><span class="p">(</span><span class="n">stackOfStrings</span><span class="p">,</span> <span class="n">arrayOfStrings</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="s">&quot;All items match.&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="s">&quot;Not all items match.&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">// prints &quot;All items match.&quot;</span>
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Language Guide: Protocols]]></title>
    <link href="http://zxhfirefox.github.io/blog/2014/10/25/language-guide-w-protocols/"/>
    <updated>2014-10-25T10:26:20+08:00</updated>
    <id>http://zxhfirefox.github.io/blog/2014/10/25/language-guide-w-protocols</id>
    <content type="html"><![CDATA[<p>一个协议定义了一系列满足某些特定需要的方法，属性和其他要求的一个蓝图。协议本身并不提供这些要求的具体实现，它只负责描述这些要求。然后，协议可以被类，结构体，枚举来实现提供这些要求的真正实现。</p>

<p>协议可以要求实现协议的类型有特殊的实例属性，实例方法，类型方法，操作符和角标。</p>

<!-- more -->


<h3>协议语法</h3>

<p>定义协议和定义类，结构体，枚举很相似。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">protocol</span> <span class="n">SomeProtocol</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// protocol definition goes here</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>当类型实现协议时，把协议写在类型名字后面，由冒号隔开，多个协议之间由逗号分开。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">struct</span> <span class="nl">SomeStructure</span><span class="p">:</span> <span class="n">FirstProtocol</span><span class="p">,</span> <span class="n">AnotherProtocol</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// structure definition goes here</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果类有父类，要把父类写在协议的前面。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">class</span> <span class="nl">SomeClass</span><span class="p">:</span> <span class="n">SomeSuperclass</span><span class="p">,</span> <span class="n">FirstProtocol</span><span class="p">,</span> <span class="n">AnotherProtocol</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// class definition goes here</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>属性要求</h3>

<p>协议可以要求实现的类型提供实例属性或类属性。协议并不表明是存储属性还是计算属性，它只给出类型和名字，同时说明是只读的还是可读可写的。</p>

<p>如果一个协议规定的属性是可读可写的，那么实现类型不就能通过常量存储属性或只读计算属性来满足。如果协议规定的属性是只读的，那么实现类型可以通过任何属性来实现，就算你在实现时同时给出了setter也是可以的。</p>

<p>属性要求总是写成变量形式的。getter和setter用 set 和 get 标示。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">protocol</span> <span class="n">SomeProtocol</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">var</span> <span class="nl">mustBeSettable</span><span class="p">:</span> <span class="n">Int</span> <span class="p">{</span> <span class="n">get</span> <span class="n">set</span> <span class="p">}</span>
</span><span class='line'>    <span class="n">var</span> <span class="nl">doesNotNeedToBeSettable</span><span class="p">:</span> <span class="n">Int</span> <span class="p">{</span> <span class="n">get</span> <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>类型属性总是用class 来标示，即使实现的类型是值类型，具体实现里用的是 static。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">protocol</span> <span class="n">AnotherProtocol</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">class</span> <span class="n">var</span> <span class="nl">someTypeProperty</span><span class="p">:</span> <span class="n">Int</span> <span class="p">{</span> <span class="n">get</span> <span class="n">set</span> <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>下面的例子:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">protocol</span> <span class="n">FullyNamed</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">var</span> <span class="nl">fullName</span><span class="p">:</span> <span class="n">String</span> <span class="p">{</span> <span class="n">get</span> <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>只定义了一个属性要求。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">struct</span> <span class="nl">Person</span><span class="p">:</span> <span class="n">FullyNamed</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">var</span> <span class="nl">fullName</span><span class="p">:</span> <span class="n">String</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">let</span> <span class="n">john</span> <span class="o">=</span> <span class="n">Person</span><span class="p">(</span><span class="nl">fullName</span><span class="p">:</span> <span class="s">&quot;John Appleseed&quot;</span><span class="p">)</span>
</span><span class='line'><span class="c1">// john.fullName is &quot;John Appleseed&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Person实现了协议，通过一个存储的属性。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">class</span> <span class="nl">Starship</span><span class="p">:</span> <span class="n">FullyNamed</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">var</span> <span class="nl">prefix</span><span class="p">:</span> <span class="n">String</span><span class="o">?</span>
</span><span class='line'>    <span class="n">var</span> <span class="nl">name</span><span class="p">:</span> <span class="n">String</span>
</span><span class='line'>    <span class="n">init</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span> <span class="nl">prefix</span><span class="p">:</span> <span class="n">String</span><span class="o">?</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">prefix</span> <span class="o">=</span> <span class="n">prefix</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">var</span> <span class="nl">fullName</span><span class="p">:</span> <span class="n">String</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="p">(</span><span class="n">prefix</span> <span class="o">!=</span> <span class="nb">nil</span> <span class="o">?</span> <span class="n">prefix</span><span class="o">!</span> <span class="o">+</span> <span class="s">&quot; &quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">name</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">var</span> <span class="n">ncc1701</span> <span class="o">=</span> <span class="n">Starship</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="s">&quot;Enterprise&quot;</span><span class="p">,</span> <span class="nl">prefix</span><span class="p">:</span> <span class="s">&quot;USS&quot;</span><span class="p">)</span>
</span><span class='line'><span class="c1">// ncc1701.fullName is &quot;USS Enterprise&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Starship也实现了这个协议，通过一个计算属性。</p>

<h3>方法要求</h3>

<p>协议可以要求实现类型去实现特定的实例方法和类型方法。这些方法在协议里的定义和他们实现时一模一样，只是没有大括号和函数体。变长参数也是可以的，规则和普通方法一样。</p>

<pre><code>注意
协议定义的方法和普通方法语法一样，但是不能允许给出参数默认值。
</code></pre>

<p>和类型属性要求一样，在类型方法要求前面添加 class 关键字。即使是值类型去实现这个方法。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">protocol</span> <span class="n">SomeProtocol</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">class</span> <span class="n">func</span> <span class="n">someTypeMethod</span><span class="p">()</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">protocol</span> <span class="n">RandomNumberGenerator</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">func</span> <span class="n">random</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Double</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面是两个协议，一个定义了一个类型方法，一个定义了一个实例方法。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">class</span> <span class="nl">LinearCongruentialGenerator</span><span class="p">:</span> <span class="n">RandomNumberGenerator</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">var</span> <span class="n">lastRandom</span> <span class="o">=</span> <span class="mf">42.0</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">m</span> <span class="o">=</span> <span class="mf">139968.0</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">a</span> <span class="o">=</span> <span class="mf">3877.0</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">c</span> <span class="o">=</span> <span class="mf">29573.0</span>
</span><span class='line'>    <span class="n">func</span> <span class="n">random</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Double</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">lastRandom</span> <span class="o">=</span> <span class="p">((</span><span class="n">lastRandom</span> <span class="o">*</span> <span class="n">a</span> <span class="o">+</span> <span class="n">c</span><span class="p">)</span> <span class="o">%</span> <span class="n">m</span><span class="p">)</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">lastRandom</span> <span class="o">/</span> <span class="n">m</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">let</span> <span class="n">generator</span> <span class="o">=</span> <span class="n">LinearCongruentialGenerator</span><span class="p">()</span>
</span><span class='line'><span class="n">println</span><span class="p">(</span><span class="s">&quot;Here&#39;s a random number: \(generator.random())&quot;</span><span class="p">)</span>
</span><span class='line'><span class="c1">// prints &quot;Here&#39;s a random number: 0.37464991998171&quot;</span>
</span><span class='line'><span class="n">println</span><span class="p">(</span><span class="s">&quot;And another one: \(generator.random())&quot;</span><span class="p">)</span>
</span><span class='line'><span class="c1">// prints &quot;And another one: 0.729023776863283&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<h3>可变方法要求</h3>

<p>如果我们定义协议实例方法需要修改实例本身，我们也需要在协议定义中，给方法加上 mutating 关键字。这样使得结构体和枚举可以实现协议。</p>

<pre><code>注意
如果我们在协议定义时，给出 mutating，当我们用一个类实现协议时，就不用写 mutating，但是如果是结构体和枚举，是必须要写得。
</code></pre>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">protocol</span> <span class="n">Togglable</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">mutating</span> <span class="n">func</span> <span class="n">toggle</span><span class="p">()</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们定义了一个协议，包含一个mutating的方法。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">enum</span> <span class="nl">OnOffSwitch</span><span class="p">:</span> <span class="n">Togglable</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">Off</span><span class="p">,</span> <span class="n">On</span>
</span><span class='line'>    <span class="n">mutating</span> <span class="n">func</span> <span class="n">toggle</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">switch</span> <span class="nb">self</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">case</span> <span class="nl">Off</span><span class="p">:</span>
</span><span class='line'>            <span class="nb">self</span> <span class="o">=</span> <span class="n">On</span>
</span><span class='line'>        <span class="k">case</span> <span class="nl">On</span><span class="p">:</span>
</span><span class='line'>            <span class="nb">self</span> <span class="o">=</span> <span class="n">Off</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">var</span> <span class="n">lightSwitch</span> <span class="o">=</span> <span class="n">OnOffSwitch</span><span class="p">.</span><span class="n">Off</span>
</span><span class='line'><span class="n">lightSwitch</span><span class="p">.</span><span class="n">toggle</span><span class="p">()</span>
</span><span class='line'><span class="c1">// lightSwitch is now equal to .On</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们在枚举OnOffSwitch上实现了协议。</p>

<h3>初始化函数要求</h3>

<p>协议可以定义特殊的初始化函数要求。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">protocol</span> <span class="n">SomeProtocol</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">init</span><span class="p">(</span><span class="nl">someParameter</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>类实现</h4>

<p>我们可以把协议要求的初始化函数实现为指定初始化函数或便利初始化函数，但是都需要加上 required。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">class</span> <span class="nl">SomeClass</span><span class="p">:</span> <span class="n">SomeProtocol</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">required</span> <span class="n">init</span><span class="p">(</span><span class="nl">someParameter</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// initializer implementation goes here</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>使用 required 保证了我们给所有子类提供了显式的或是继承的初始化函数。</p>

<pre><code>注意
如果类是 final，则我们可以不写 required的。
</code></pre>

<p>如果一个子类重写了一个父类的指定初始化函数，并且实现了一个协议的初始化函数，required 和 override 则都需要写。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">protocol</span> <span class="n">SomeProtocol</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">init</span><span class="p">()</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">class</span> <span class="n">SomeSuperClass</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">init</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// initializer implementation goes here</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">class</span> <span class="nl">SomeSubClass</span><span class="p">:</span> <span class="n">SomeSuperClass</span><span class="p">,</span> <span class="n">SomeProtocol</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// &quot;required&quot; from SomeProtocol conformance; &quot;override&quot; from SomeSuperClass</span>
</span><span class='line'>    <span class="n">required</span> <span class="n">override</span> <span class="n">init</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// initializer implementation goes here</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>可失败的初始化函数要求</h4>

<p>协议可以定义可失败的初始化函数要求。</p>

<p>一个可失败的初始化要求可以被一个可失败的或者不可失败的初始化函数实现。一个不可失败的初始化函数可以被一个不可失败的或是一个自动解包的可失败初始化函数实现。</p>

<h3>协议也是类型</h3>

<p>协议不会提供它定义的任何要求的实现。然而，协议却可以作为一个类型来使用。</p>

<p>因为它也是类型，所以我们可以把它用在任何一个类型允许的地方。例如：
    *   作为参数或返回值
    *   作为常量，变量或属性
    *   作为字典，数组或其他集合的元素的类型</p>

<pre><code>注意
因为协议是类型，所以首字母应该大写
</code></pre>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">class</span> <span class="n">Dice</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">let</span> <span class="nl">sides</span><span class="p">:</span> <span class="n">Int</span>
</span><span class='line'>    <span class="n">let</span> <span class="nl">generator</span><span class="p">:</span> <span class="n">RandomNumberGenerator</span>
</span><span class='line'>    <span class="n">init</span><span class="p">(</span><span class="nl">sides</span><span class="p">:</span> <span class="n">Int</span><span class="p">,</span> <span class="nl">generator</span><span class="p">:</span> <span class="n">RandomNumberGenerator</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">sides</span> <span class="o">=</span> <span class="n">sides</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">generator</span> <span class="o">=</span> <span class="n">generator</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">func</span> <span class="n">roll</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Int</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">Int</span><span class="p">(</span><span class="n">generator</span><span class="p">.</span><span class="n">random</span><span class="p">()</span> <span class="o">*</span> <span class="n">Double</span><span class="p">(</span><span class="n">sides</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们定义了Dice类，它有一个RandomNumberGenerator的属性。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">var</span> <span class="n">d6</span> <span class="o">=</span> <span class="n">Dice</span><span class="p">(</span><span class="nl">sides</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span> <span class="nl">generator</span><span class="p">:</span> <span class="n">LinearCongruentialGenerator</span><span class="p">())</span>
</span><span class='line'><span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="mf">1.</span><span class="p">.</span><span class="mf">.5</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="s">&quot;Random dice roll is \(d6.roll())&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">// Random dice roll is 3</span>
</span><span class='line'><span class="c1">// Random dice roll is 5</span>
</span><span class='line'><span class="c1">// Random dice roll is 4</span>
</span><span class='line'><span class="c1">// Random dice roll is 5</span>
</span><span class='line'><span class="c1">// Random dice roll is 4</span>
</span></code></pre></td></tr></table></div></figure>


<h3>代理</h3>

<p>代理，是一种设计模式，它可以让一个类或结构体把自己的一部分责任代理给其他类型的实例。这个设计模式通过把代理过去的责任封装到一个协议里，然后实现了协议的类型就可以作为代理来提供这部分功能。代理可以用来相应某些特定的时间，或者从不知道底层类型的数据获取数据。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">protocol</span> <span class="n">DiceGame</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">var</span> <span class="nl">dice</span><span class="p">:</span> <span class="n">Dice</span> <span class="p">{</span> <span class="n">get</span> <span class="p">}</span>
</span><span class='line'>    <span class="n">func</span> <span class="n">play</span><span class="p">()</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">protocol</span> <span class="n">DiceGameDelegate</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">func</span> <span class="n">gameDidStart</span><span class="p">(</span><span class="nl">game</span><span class="p">:</span> <span class="n">DiceGame</span><span class="p">)</span>
</span><span class='line'>    <span class="n">func</span> <span class="n">game</span><span class="p">(</span><span class="nl">game</span><span class="p">:</span> <span class="n">DiceGame</span><span class="p">,</span> <span class="n">didStartNewTurnWithDiceRoll</span> <span class="nl">diceRoll</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span>
</span><span class='line'>    <span class="n">func</span> <span class="n">gameDidEnd</span><span class="p">(</span><span class="nl">game</span><span class="p">:</span> <span class="n">DiceGame</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们定义了2个协议，DiceGame和GiceGameDelegate。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">class</span> <span class="nl">SnakesAndLadders</span><span class="p">:</span> <span class="n">DiceGame</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">finalSquare</span> <span class="o">=</span> <span class="mi">25</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">dice</span> <span class="o">=</span> <span class="n">Dice</span><span class="p">(</span><span class="nl">sides</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span> <span class="nl">generator</span><span class="p">:</span> <span class="n">LinearCongruentialGenerator</span><span class="p">())</span>
</span><span class='line'>    <span class="n">var</span> <span class="n">square</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'>    <span class="n">var</span> <span class="nl">board</span><span class="p">:</span> <span class="p">[</span><span class="n">Int</span><span class="p">]</span>
</span><span class='line'>    <span class="n">init</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">board</span> <span class="o">=</span> <span class="p">[</span><span class="n">Int</span><span class="p">](</span><span class="nl">count</span><span class="p">:</span> <span class="n">finalSquare</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nl">repeatedValue</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>        <span class="n">board</span><span class="p">[</span><span class="mo">03</span><span class="p">]</span> <span class="o">=</span> <span class="o">+</span><span class="mi">08</span><span class="p">;</span> <span class="n">board</span><span class="p">[</span><span class="mo">06</span><span class="p">]</span> <span class="o">=</span> <span class="o">+</span><span class="mi">11</span><span class="p">;</span> <span class="n">board</span><span class="p">[</span><span class="mi">09</span><span class="p">]</span> <span class="o">=</span> <span class="o">+</span><span class="mi">09</span><span class="p">;</span> <span class="n">board</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="o">+</span><span class="mo">02</span>
</span><span class='line'>        <span class="n">board</span><span class="p">[</span><span class="mi">14</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">10</span><span class="p">;</span> <span class="n">board</span><span class="p">[</span><span class="mi">19</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">11</span><span class="p">;</span> <span class="n">board</span><span class="p">[</span><span class="mi">22</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mo">02</span><span class="p">;</span> <span class="n">board</span><span class="p">[</span><span class="mi">24</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">08</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">var</span> <span class="nl">delegate</span><span class="p">:</span> <span class="n">DiceGameDelegate</span><span class="o">?</span>
</span><span class='line'>    <span class="n">func</span> <span class="n">play</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">square</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'>        <span class="n">delegate</span><span class="o">?</span><span class="p">.</span><span class="n">gameDidStart</span><span class="p">(</span><span class="nb">self</span><span class="p">)</span>
</span><span class='line'>        <span class="nl">gameLoop</span><span class="p">:</span> <span class="k">while</span> <span class="n">square</span> <span class="o">!=</span> <span class="n">finalSquare</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">let</span> <span class="n">diceRoll</span> <span class="o">=</span> <span class="n">dice</span><span class="p">.</span><span class="n">roll</span><span class="p">()</span>
</span><span class='line'>            <span class="n">delegate</span><span class="o">?</span><span class="p">.</span><span class="n">game</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="nl">didStartNewTurnWithDiceRoll</span><span class="p">:</span> <span class="n">diceRoll</span><span class="p">)</span>
</span><span class='line'>            <span class="k">switch</span> <span class="n">square</span> <span class="o">+</span> <span class="n">diceRoll</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">case</span> <span class="nl">finalSquare</span><span class="p">:</span>
</span><span class='line'>                <span class="k">break</span> <span class="n">gameLoop</span>
</span><span class='line'>            <span class="k">case</span> <span class="n">let</span> <span class="n">newSquare</span> <span class="n">where</span> <span class="n">newSquare</span> <span class="o">&gt;</span> <span class="nl">finalSquare</span><span class="p">:</span>
</span><span class='line'>                <span class="k">continue</span> <span class="n">gameLoop</span>
</span><span class='line'>            <span class="k">default</span><span class="o">:</span>
</span><span class='line'>                <span class="n">square</span> <span class="o">+=</span> <span class="n">diceRoll</span>
</span><span class='line'>                <span class="n">square</span> <span class="o">+=</span> <span class="n">board</span><span class="p">[</span><span class="n">square</span><span class="p">]</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="n">delegate</span><span class="o">?</span><span class="p">.</span><span class="n">gameDidEnd</span><span class="p">(</span><span class="nb">self</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">class</span> <span class="nl">DiceGameTracker</span><span class="p">:</span> <span class="n">DiceGameDelegate</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">var</span> <span class="n">numberOfTurns</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'>    <span class="n">func</span> <span class="n">gameDidStart</span><span class="p">(</span><span class="nl">game</span><span class="p">:</span> <span class="n">DiceGame</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">numberOfTurns</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'>        <span class="k">if</span> <span class="n">game</span> <span class="n">is</span> <span class="n">SnakesAndLadders</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">println</span><span class="p">(</span><span class="s">&quot;Started a new game of Snakes and Ladders&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="n">println</span><span class="p">(</span><span class="s">&quot;The game is using a \(game.dice.sides)-sided dice&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">func</span> <span class="n">game</span><span class="p">(</span><span class="nl">game</span><span class="p">:</span> <span class="n">DiceGame</span><span class="p">,</span> <span class="n">didStartNewTurnWithDiceRoll</span> <span class="nl">diceRoll</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="o">++</span><span class="n">numberOfTurns</span>
</span><span class='line'>        <span class="n">println</span><span class="p">(</span><span class="s">&quot;Rolled a \(diceRoll)&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">func</span> <span class="n">gameDidEnd</span><span class="p">(</span><span class="nl">game</span><span class="p">:</span> <span class="n">DiceGame</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">println</span><span class="p">(</span><span class="s">&quot;The game lasted for \(numberOfTurns) turns&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">let</span> <span class="n">tracker</span> <span class="o">=</span> <span class="n">DiceGameTracker</span><span class="p">()</span>
</span><span class='line'><span class="n">let</span> <span class="n">game</span> <span class="o">=</span> <span class="n">SnakesAndLadders</span><span class="p">()</span>
</span><span class='line'><span class="n">game</span><span class="p">.</span><span class="n">delegate</span> <span class="o">=</span> <span class="n">tracker</span>
</span><span class='line'><span class="n">game</span><span class="p">.</span><span class="n">play</span><span class="p">()</span>
</span><span class='line'><span class="c1">// Started a new game of Snakes and Ladders</span>
</span><span class='line'><span class="c1">// The game is using a 6-sided dice</span>
</span><span class='line'><span class="c1">// Rolled a 3</span>
</span><span class='line'><span class="c1">// Rolled a 5</span>
</span><span class='line'><span class="c1">// Rolled a 4</span>
</span><span class='line'><span class="c1">// Rolled a 5</span>
</span><span class='line'><span class="c1">// The game lasted for 4 turns</span>
</span></code></pre></td></tr></table></div></figure>


<h3>通过扩展来实现协议</h3>

<p>我们可以通过扩展一个类型来实现协议，即使我们拿不到这个类型的源代码。扩展可以添加属性，方法，角标，也可以添加协议的实现。</p>

<pre><code>注意
已有的实例也会具有新扩展实现的协议。
</code></pre>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">protocol</span> <span class="n">TextRepresentable</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">func</span> <span class="n">asText</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">String</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">extension</span> <span class="nl">Dice</span><span class="p">:</span> <span class="n">TextRepresentable</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">func</span> <span class="n">asText</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">String</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="s">&quot;A \(sides)-sided dice&quot;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们扩展Dice来实现了TextRepresentable协议。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">let</span> <span class="n">d12</span> <span class="o">=</span> <span class="n">Dice</span><span class="p">(</span><span class="nl">sides</span><span class="p">:</span> <span class="mi">12</span><span class="p">,</span> <span class="nl">generator</span><span class="p">:</span> <span class="n">LinearCongruentialGenerator</span><span class="p">())</span>
</span><span class='line'><span class="n">println</span><span class="p">(</span><span class="n">d12</span><span class="p">.</span><span class="n">asText</span><span class="p">())</span>
</span><span class='line'><span class="c1">// prints &quot;A 12-sided dice&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们就可以使用asText方法了。</p>

<h4>通过扩展来声明协议实现</h4>

<p>如果一个类型已经实现了协议的所有要求，但是没有说明它实现了协议。我们可以通过一个扩展来说明。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">struct</span> <span class="n">Hamster</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">var</span> <span class="nl">name</span><span class="p">:</span> <span class="n">String</span>
</span><span class='line'>    <span class="n">func</span> <span class="n">asText</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">String</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="s">&quot;A hamster named \(name)&quot;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">extension</span> <span class="nl">Hamster</span><span class="p">:</span> <span class="n">TextRepresentable</span> <span class="p">{}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">let</span> <span class="n">simonTheHamster</span> <span class="o">=</span> <span class="n">Hamster</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="s">&quot;Simon&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">let</span> <span class="nl">somethingTextRepresentable</span><span class="p">:</span> <span class="n">TextRepresentable</span> <span class="o">=</span> <span class="n">simonTheHamster</span>
</span><span class='line'><span class="n">println</span><span class="p">(</span><span class="n">somethingTextRepresentable</span><span class="p">.</span><span class="n">asText</span><span class="p">())</span>
</span><span class='line'><span class="c1">// prints &quot;A hamster named Simon&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>这样，Hamster实例可以被当做TextRepresentable类型。</p>

<pre><code>注意
类型不是简单的满足协议的要求就算实现协议了，他们必须声明他们实现了协议。
</code></pre>

<h3>协议类型集合</h3>

<p>协议可以作为集合元素的类型。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">let</span> <span class="nl">things</span><span class="p">:</span> <span class="p">[</span><span class="n">TextRepresentable</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">game</span><span class="p">,</span> <span class="n">d12</span><span class="p">,</span> <span class="n">simonTheHamster</span><span class="p">]</span>
</span><span class='line'><span class="k">for</span> <span class="n">thing</span> <span class="k">in</span> <span class="n">things</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="n">thing</span><span class="p">.</span><span class="n">asText</span><span class="p">())</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">// A game of Snakes and Ladders with 25 squares</span>
</span><span class='line'><span class="c1">// A 12-sided dice</span>
</span><span class='line'><span class="c1">// A hamster named Simon</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意thing的类型是TextRepresentable，而不是具体的其他类型。然而，因为它的类型是TextRepresentable，TextRepresentable能做的任何事情，它们都可以做。</p>

<h3>协议继承</h3>

<p>协议可以从一个或多个协议继承，而且还可以在这些基础上添加新的要求。协议的继承语法和类的继承语法是一样的。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">protocol</span> <span class="nl">InheritingProtocol</span><span class="p">:</span> <span class="n">SomeProtocol</span><span class="p">,</span> <span class="n">AnotherProtocol</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// protocol definition goes here</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">protocol</span> <span class="nl">PrettyTextRepresentable</span><span class="p">:</span> <span class="n">TextRepresentable</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">func</span> <span class="n">asPrettyText</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">String</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里我们定义了一个新的协议，继承自TextRepresentable。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">extension</span> <span class="nl">SnakesAndLadders</span><span class="p">:</span> <span class="n">PrettyTextRepresentable</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">func</span> <span class="n">asPrettyText</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">String</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">var</span> <span class="n">output</span> <span class="o">=</span> <span class="n">asText</span><span class="p">()</span> <span class="o">+</span> <span class="s">&quot;:</span><span class="se">\n</span><span class="s">&quot;</span>
</span><span class='line'>        <span class="k">for</span> <span class="n">index</span> <span class="k">in</span> <span class="mf">1.</span><span class="p">..</span><span class="n">finalSquare</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">switch</span> <span class="n">board</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">case</span> <span class="n">let</span> <span class="n">ladder</span> <span class="n">where</span> <span class="n">ladder</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">:</span>
</span><span class='line'>                <span class="n">output</span> <span class="o">+=</span> <span class="s">&quot;▲ &quot;</span>
</span><span class='line'>            <span class="k">case</span> <span class="n">let</span> <span class="n">snake</span> <span class="n">where</span> <span class="n">snake</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">:</span>
</span><span class='line'>                <span class="n">output</span> <span class="o">+=</span> <span class="s">&quot;▼ &quot;</span>
</span><span class='line'>            <span class="k">default</span><span class="o">:</span>
</span><span class='line'>                <span class="n">output</span> <span class="o">+=</span> <span class="s">&quot;○ &quot;</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">output</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">println</span><span class="p">(</span><span class="n">game</span><span class="p">.</span><span class="n">asPrettyText</span><span class="p">())</span>
</span><span class='line'><span class="c1">// A game of Snakes and Ladders with 25 squares:</span>
</span><span class='line'><span class="c1">// ○ ○ ▲ ○ ○ ▲ ○ ○ ▲ ▲ ○ ○ ○ ▼ ○ ○ ○ ○ ▼ ○ ○ ▼ ○ ▼ ○</span>
</span></code></pre></td></tr></table></div></figure>


<h3>只给类的协议</h3>

<p>我们可以限制实现协议的类型只能是类，而不能是结构体和枚举。通过在协议继承列表的最前面加一个 class 来限制实现协议的类型只能是类。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">protocol</span> <span class="nl">SomeClassOnlyProtocol</span><span class="p">:</span> <span class="k">class</span><span class="p">,</span> <span class="n">SomeInheritedProtocol</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// class-only protocol definition goes here</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<pre><code>注意
仅当协议的实现需要区分值和引用的不同语意时使用只给类的协议。
</code></pre>

<h3>协议组合</h3>

<p>有时候要求一个类型同时实现多个协议是有用的。我们可以把多个协议组合成一个协议。写成protocol&lt;SomeProtocl, AnotherProtocol>。我们可以在尖括号里写任意多得协议。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">protocol</span> <span class="n">Named</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">var</span> <span class="nl">name</span><span class="p">:</span> <span class="n">String</span> <span class="p">{</span> <span class="n">get</span> <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">protocol</span> <span class="n">Aged</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">var</span> <span class="nl">age</span><span class="p">:</span> <span class="n">Int</span> <span class="p">{</span> <span class="n">get</span> <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">struct</span> <span class="nl">Person</span><span class="p">:</span> <span class="n">Named</span><span class="p">,</span> <span class="n">Aged</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">var</span> <span class="nl">name</span><span class="p">:</span> <span class="n">String</span>
</span><span class='line'>    <span class="n">var</span> <span class="nl">age</span><span class="p">:</span> <span class="n">Int</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">func</span> <span class="n">wishHappyBirthday</span><span class="p">(</span><span class="nl">celebrator</span><span class="p">:</span> <span class="n">protocol</span><span class="o">&lt;</span><span class="n">Named</span><span class="p">,</span> <span class="n">Aged</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="s">&quot;Happy birthday \(celebrator.name) - you&#39;re \(celebrator.age)!&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">let</span> <span class="n">birthdayPerson</span> <span class="o">=</span> <span class="n">Person</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="s">&quot;Malcolm&quot;</span><span class="p">,</span> <span class="nl">age</span><span class="p">:</span> <span class="mi">21</span><span class="p">)</span>
</span><span class='line'><span class="n">wishHappyBirthday</span><span class="p">(</span><span class="n">birthdayPerson</span><span class="p">)</span>
</span><span class='line'><span class="c1">// prints &quot;Happy birthday Malcolm - you&#39;re 21!&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的例子里，我们定义2个协议，由一个结构体实现2个协议。定义了一个函数接受一个组合协议的类型。</p>

<pre><code>注意
协议组合并没有定义一个新的，永久的类型。相反，是临时的定义了一个局部的组合了其他协议的协议。
</code></pre>

<h3>检查协议实现</h3>

<p>我们可以使用 is 和 as 操作符来检查协议实现和把实例转换到特定协议类型。检查协议实现和检查类型是一样的。
    *   如果实例实现了协议，is 返回true，如果没有，返回 false。
    *   as？ 返回一个optional的协议类型，如果实例没有实现协议，返回nil。
    *   as 返回一个一个特定的协议类型，如果实例没有实现协议，运行时错误。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">@</span><span class="n">objc</span> <span class="n">protocol</span> <span class="n">HasArea</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">var</span> <span class="nl">area</span><span class="p">:</span> <span class="n">Double</span> <span class="p">{</span> <span class="n">get</span> <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<pre><code>注意
如果我们要检查一个协议是否被实例实现，我们必须把协议标记上 @objc。这个标记意味着这个协议可以在ObjC代码中使用。即使你打算在ObjC中使用，你如果想对实例做检查，协议也必须标记为 @objc。

另外，标记为@objc的协议只能被类实现，而不能被结构体和枚举实现。
</code></pre>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">class</span> <span class="nl">Circle</span><span class="p">:</span> <span class="n">HasArea</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">pi</span> <span class="o">=</span> <span class="mf">3.1415927</span>
</span><span class='line'>    <span class="n">var</span> <span class="nl">radius</span><span class="p">:</span> <span class="n">Double</span>
</span><span class='line'>    <span class="n">var</span> <span class="nl">area</span><span class="p">:</span> <span class="n">Double</span> <span class="p">{</span> <span class="k">return</span> <span class="n">pi</span> <span class="o">*</span> <span class="n">radius</span> <span class="o">*</span> <span class="n">radius</span> <span class="p">}</span>
</span><span class='line'>    <span class="n">init</span><span class="p">(</span><span class="nl">radius</span><span class="p">:</span> <span class="n">Double</span><span class="p">)</span> <span class="p">{</span> <span class="nb">self</span><span class="p">.</span><span class="n">radius</span> <span class="o">=</span> <span class="n">radius</span> <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">class</span> <span class="nl">Country</span><span class="p">:</span> <span class="n">HasArea</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">var</span> <span class="nl">area</span><span class="p">:</span> <span class="n">Double</span>
</span><span class='line'>    <span class="n">init</span><span class="p">(</span><span class="nl">area</span><span class="p">:</span> <span class="n">Double</span><span class="p">)</span> <span class="p">{</span> <span class="nb">self</span><span class="p">.</span><span class="n">area</span> <span class="o">=</span> <span class="n">area</span> <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">class</span> <span class="n">Animal</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">var</span> <span class="nl">legs</span><span class="p">:</span> <span class="n">Int</span>
</span><span class='line'>    <span class="n">init</span><span class="p">(</span><span class="nl">legs</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">{</span> <span class="nb">self</span><span class="p">.</span><span class="n">legs</span> <span class="o">=</span> <span class="n">legs</span> <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">let</span> <span class="nl">objects</span><span class="p">:</span> <span class="p">[</span><span class="n">AnyObject</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
</span><span class='line'>    <span class="n">Circle</span><span class="p">(</span><span class="nl">radius</span><span class="p">:</span> <span class="mf">2.0</span><span class="p">),</span>
</span><span class='line'>    <span class="n">Country</span><span class="p">(</span><span class="nl">area</span><span class="p">:</span> <span class="mi">243</span><span class="n">_610</span><span class="p">),</span>
</span><span class='line'>    <span class="n">Animal</span><span class="p">(</span><span class="nl">legs</span><span class="p">:</span> <span class="mi">4</span><span class="p">)</span>
</span><span class='line'><span class="p">]</span>
</span><span class='line'><span class="k">for</span> <span class="n">object</span> <span class="k">in</span> <span class="n">objects</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">let</span> <span class="n">objectWithArea</span> <span class="o">=</span> <span class="n">object</span> <span class="n">as</span><span class="o">?</span> <span class="n">HasArea</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">println</span><span class="p">(</span><span class="s">&quot;Area is \(objectWithArea.area)&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">println</span><span class="p">(</span><span class="s">&quot;Something that doesn&#39;t have an area&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">// Area is 12.5663708</span>
</span><span class='line'><span class="c1">// Area is 243610.0</span>
</span><span class='line'><span class="c1">// Something that doesn&#39;t have an area</span>
</span></code></pre></td></tr></table></div></figure>


<h3>可选的协议要求</h3>

<p>我们可以在协议里定义可选的要求。这些要求可以不被实现的类型实现。可选的要求前面用 optional来标示。</p>

<p>一个可选的协议要求可以使用optional链来调用，来检查一个类型实现了协议，但没有实现可选的要求。</p>

<p>我们在可选的要求后面加？来调用。可选的属性和方法，总会返回一个optional的值。来表示是否成功访问或调用，来反映这个可选的要求是否被实现。</p>

<pre><code>注意
可选的协议要求只能在@objc的协议里。
</code></pre>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">@</span><span class="n">objc</span> <span class="n">protocol</span> <span class="n">CounterDataSource</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">optional</span> <span class="n">func</span> <span class="n">incrementForCount</span><span class="p">(</span><span class="nl">count</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Int</span>
</span><span class='line'>    <span class="n">optional</span> <span class="n">var</span> <span class="nl">fixedIncrement</span><span class="p">:</span> <span class="n">Int</span> <span class="p">{</span> <span class="n">get</span> <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<pre><code>注意
严格来说，我们可以定义一个类，实现CounterDataSource，但不给出任何实现。
</code></pre>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">@</span><span class="n">objc</span> <span class="k">class</span> <span class="n">Counter</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">var</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'>    <span class="n">var</span> <span class="nl">dataSource</span><span class="p">:</span> <span class="n">CounterDataSource</span><span class="o">?</span>
</span><span class='line'>    <span class="n">func</span> <span class="n">increment</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="n">let</span> <span class="n">amount</span> <span class="o">=</span> <span class="n">dataSource</span><span class="o">?</span><span class="p">.</span><span class="n">incrementForCount</span><span class="o">?</span><span class="p">(</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">count</span> <span class="o">+=</span> <span class="n">amount</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">let</span> <span class="n">amount</span> <span class="o">=</span> <span class="n">dataSource</span><span class="o">?</span><span class="p">.</span><span class="n">fixedIncrement</span><span class="o">?</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">count</span> <span class="o">+=</span> <span class="n">amount</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">class</span> <span class="nl">ThreeSource</span><span class="p">:</span> <span class="n">CounterDataSource</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">fixedIncrement</span> <span class="o">=</span> <span class="mi">3</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">var</span> <span class="n">counter</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">()</span>
</span><span class='line'><span class="n">counter</span><span class="p">.</span><span class="n">dataSource</span> <span class="o">=</span> <span class="n">ThreeSource</span><span class="p">()</span>
</span><span class='line'><span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="mf">1.</span><span class="p">.</span><span class="mf">.4</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">counter</span><span class="p">.</span><span class="n">increment</span><span class="p">()</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="n">counter</span><span class="p">.</span><span class="n">count</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">// 3</span>
</span><span class='line'><span class="c1">// 6</span>
</span><span class='line'><span class="c1">// 9</span>
</span><span class='line'><span class="c1">// 12</span>
</span><span class='line'><span class="k">class</span> <span class="nl">TowardsZeroSource</span><span class="p">:</span> <span class="n">CounterDataSource</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">func</span> <span class="n">incrementForCount</span><span class="p">(</span><span class="nl">count</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Int</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="mi">0</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="mi">1</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">counter</span><span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="o">-</span><span class="mi">4</span>
</span><span class='line'><span class="n">counter</span><span class="p">.</span><span class="n">dataSource</span> <span class="o">=</span> <span class="n">TowardsZeroSource</span><span class="p">()</span>
</span><span class='line'><span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="mf">1.</span><span class="p">.</span><span class="mf">.5</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">counter</span><span class="p">.</span><span class="n">increment</span><span class="p">()</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="n">counter</span><span class="p">.</span><span class="n">count</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">// -3</span>
</span><span class='line'><span class="c1">// -2</span>
</span><span class='line'><span class="c1">// -1</span>
</span><span class='line'><span class="c1">// 0</span>
</span><span class='line'><span class="c1">// 0</span>
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Language Guide: Extension]]></title>
    <link href="http://zxhfirefox.github.io/blog/2014/10/25/language-guide-v-extension/"/>
    <updated>2014-10-25T10:25:34+08:00</updated>
    <id>http://zxhfirefox.github.io/blog/2014/10/25/language-guide-v-extension</id>
    <content type="html"><![CDATA[<p>扩展可以给已有的类，结构体，枚举添加新的功能。这包括可以给我们无法获取源代码的类型添加功能。扩展和ObjC的类别很相似。（和ObjC的类别不同，Swift的扩展没有名字）</p>

<p>Swift里扩展可以：</p>

<ul>
<li>添加计算属性和静态计算属性</li>
<li>添加实例方法和类型方法</li>
<li>提供新的初始化函数</li>
<li>定义角标</li>
<li>定义和使用新的嵌套类型</li>
<li><p>实现协议</p>

<pre><code>注意
扩展只能添加功能，而不能重写已有的功能
</code></pre></li>
</ul>


<!-- more -->


<h3>语法</h3>

<p>使用 extension 关键字声明扩展：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">extension</span> <span class="n">SomeType</span><span class="p">{</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>扩展可以让一个现有类型实现一个或多个协议。这种情况下，协议的名字和对于类或者结构体是一样的。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">extension</span> <span class="nl">SomeType</span><span class="p">:</span> <span class="n">SomeProtocol</span><span class="p">,</span> <span class="n">AnotherProtocol</span><span class="p">{</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<pre><code>注意
我们使用扩展给现有类型添加功能，这些功能将对所有实例产生效果，即使是在扩展定义之前就创建的实例
</code></pre>

<h3>计算属性</h3>

<p>扩展可以给现有类型添加计算的实例属性或类属性。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">extension</span> <span class="n">Double</span><span class="p">{</span>
</span><span class='line'>    <span class="n">var</span> <span class="nl">km</span><span class="p">:</span> <span class="n">Double</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">self</span> <span class="o">*</span> <span class="mi">1</span><span class="n">_000</span><span class="mf">.0</span> <span class="p">}</span>
</span><span class='line'>    <span class="n">var</span> <span class="nl">m</span><span class="p">:</span> <span class="n">Double</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">self</span> <span class="p">}</span>
</span><span class='line'>    <span class="n">var</span> <span class="nl">cm</span><span class="p">:</span> <span class="n">Double</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">self</span> <span class="o">/</span> <span class="mf">100.0</span> <span class="p">}</span>
</span><span class='line'>    <span class="n">var</span> <span class="nl">mm</span><span class="p">:</span> <span class="n">Double</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">self</span> <span class="o">/</span> <span class="mi">1</span><span class="n">_000</span><span class="mf">.0</span> <span class="p">}</span>
</span><span class='line'>    <span class="n">var</span> <span class="nl">ft</span><span class="p">:</span> <span class="n">Double</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">self</span> <span class="o">/</span> <span class="mf">3.28084</span> <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">let</span> <span class="n">oneInch</span> <span class="o">=</span> <span class="mf">25.4</span><span class="p">.</span><span class="n">mm</span>
</span><span class='line'><span class="n">println</span><span class="p">(</span><span class="s">&quot;One inch is \(oneInch) meters&quot;</span><span class="p">)</span>
</span><span class='line'><span class="c1">// prints &quot;One inch is 0.0254 meters&quot;</span>
</span><span class='line'><span class="n">let</span> <span class="n">threeFeet</span> <span class="o">=</span> <span class="mf">3.f</span><span class="n">t</span>
</span><span class='line'><span class="n">println</span><span class="p">(</span><span class="s">&quot;Three feet is \(threeFeet) meters&quot;</span><span class="p">)</span>
</span><span class='line'><span class="c1">// prints &quot;Three feet is 0.914399970739201 meters&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>这些计算属性可以用于数值字面量。</p>

<p>他们也是只读的属性。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">let</span> <span class="n">aMarathon</span> <span class="o">=</span> <span class="mf">42.</span><span class="n">km</span> <span class="o">+</span> <span class="mf">195.</span><span class="n">m</span>
</span><span class='line'><span class="n">println</span><span class="p">(</span><span class="s">&quot;A marathon is \(aMarathon) meters long&quot;</span><span class="p">)</span>
</span><span class='line'><span class="c1">// prints &quot;A marathon is 42195.0 meters long&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<pre><code>注意
扩展可以添加计算属性，但是不能添加存储属性，也不能注册属性观察者
</code></pre>

<h3>初始化函数</h3>

<p>扩展可以给已有类型添加新的初始化函数。这样我们可以扩展一些类型让他们可以接受我们自己的初始化参数，或者增加一些原有实现没有的初始化选项。</p>

<p>扩展可以给类添加便利初始化函数，但是不能添加指定初始化函数，或者反初始化函数。这两种函数必须在原有实现上实现。</p>

<pre><code>注意
如果我们通过扩展给值类型添加一个初始化函数，而这个函数提供了所有存储属性的默认值，并且没有添加自定义的初始化函数，那么我们可以在扩展的初始化函数里调用默认初始化函数或按成员的初始化函数。

因为如果我们在值类型里定义了自定义的初始化函数，默认的初始化函数就不会提供。但是扩展里可以。
</code></pre>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">struct</span> <span class="n">Size</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">var</span> <span class="n">width</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">height</span> <span class="o">=</span> <span class="mf">0.0</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">struct</span> <span class="n">Point</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">var</span> <span class="n">x</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mf">0.0</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">struct</span> <span class="n">Rect</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">var</span> <span class="n">origin</span> <span class="o">=</span> <span class="n">Point</span><span class="p">()</span>
</span><span class='line'>    <span class="n">var</span> <span class="n">size</span> <span class="o">=</span> <span class="n">Size</span><span class="p">()</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们定义了3个结构体，他们都有默认的初始化函数和按成员的初始化函数。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">let</span> <span class="n">defaultRect</span> <span class="o">=</span> <span class="n">Rect</span><span class="p">()</span>
</span><span class='line'><span class="n">let</span> <span class="n">memberwiseRect</span> <span class="o">=</span> <span class="n">Rect</span><span class="p">(</span><span class="nl">origin</span><span class="p">:</span> <span class="n">Point</span><span class="p">(</span><span class="nl">x</span><span class="p">:</span> <span class="mf">2.0</span><span class="p">,</span> <span class="nl">y</span><span class="p">:</span> <span class="mf">2.0</span><span class="p">),</span>
</span><span class='line'>    <span class="nl">size</span><span class="p">:</span> <span class="n">Size</span><span class="p">(</span><span class="nl">width</span><span class="p">:</span> <span class="mf">5.0</span><span class="p">,</span> <span class="nl">height</span><span class="p">:</span> <span class="mf">5.0</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们添加一个扩展：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">extension</span> <span class="n">Rect</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">init</span><span class="p">(</span><span class="nl">center</span><span class="p">:</span> <span class="n">Point</span><span class="p">,</span> <span class="nl">size</span><span class="p">:</span> <span class="n">Size</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">let</span> <span class="n">originX</span> <span class="o">=</span> <span class="n">center</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="p">(</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
</span><span class='line'>        <span class="n">let</span> <span class="n">originY</span> <span class="o">=</span> <span class="n">center</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="p">(</span><span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">init</span><span class="p">(</span><span class="nl">origin</span><span class="p">:</span> <span class="n">Point</span><span class="p">(</span><span class="nl">x</span><span class="p">:</span> <span class="n">originX</span><span class="p">,</span> <span class="nl">y</span><span class="p">:</span> <span class="n">originY</span><span class="p">),</span> <span class="nl">size</span><span class="p">:</span> <span class="n">size</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们可以使用这个初始化来创建实例：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">let</span> <span class="n">centerRect</span> <span class="o">=</span> <span class="n">Rect</span><span class="p">(</span><span class="nl">center</span><span class="p">:</span> <span class="n">Point</span><span class="p">(</span><span class="nl">x</span><span class="p">:</span> <span class="mf">4.0</span><span class="p">,</span> <span class="nl">y</span><span class="p">:</span> <span class="mf">4.0</span><span class="p">),</span>
</span><span class='line'>    <span class="nl">size</span><span class="p">:</span> <span class="n">Size</span><span class="p">(</span><span class="nl">width</span><span class="p">:</span> <span class="mf">3.0</span><span class="p">,</span> <span class="nl">height</span><span class="p">:</span> <span class="mf">3.0</span><span class="p">))</span>
</span><span class='line'><span class="c1">// centerRect&#39;s origin is (2.5, 2.5) and its size is (3.0, 3.0)</span>
</span></code></pre></td></tr></table></div></figure>


<pre><code>注意
所有我们在扩展里添加的初始化函数，都依然需要保证初始化结束后，实例是完整的被初始化的。
</code></pre>

<h3>方法</h3>

<p>扩展还可以给已有类型添加实例方法或类型方法。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">extension</span> <span class="n">Int</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">func</span> <span class="n">repetitions</span><span class="p">(</span><span class="nl">task</span><span class="p">:</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="p">())</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mf">0.</span><span class="p">.</span><span class="o">&lt;</span><span class="nb">self</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">task</span><span class="p">()</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="mf">3.</span><span class="n">repetitions</span><span class="p">({</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="s">&quot;Hello!&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">})</span>
</span><span class='line'><span class="c1">// Hello!</span>
</span><span class='line'><span class="c1">// Hello!</span>
</span><span class='line'><span class="c1">// Hello!</span>
</span><span class='line'><span class="mf">3.</span><span class="n">repetitions</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="s">&quot;Goodbye!&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">// Goodbye!</span>
</span><span class='line'><span class="c1">// Goodbye!</span>
</span><span class='line'><span class="c1">// Goodbye!</span>
</span></code></pre></td></tr></table></div></figure>


<p>注：这种看起来就和Ruby的有些相似了。</p>

<h4>可变的实例方法</h4>

<p>通过扩展添加的实例方法也可以修改实例本身。结构体和枚举方法修改的自己的必须添加 mutating。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">extension</span> <span class="n">Int</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">mutating</span> <span class="n">func</span> <span class="n">square</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="nb">self</span> <span class="o">=</span> <span class="nb">self</span> <span class="o">*</span> <span class="nb">self</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">var</span> <span class="n">someInt</span> <span class="o">=</span> <span class="mi">3</span>
</span><span class='line'><span class="n">someInt</span><span class="p">.</span><span class="n">square</span><span class="p">()</span>
</span><span class='line'><span class="c1">// someInt is now 9</span>
</span></code></pre></td></tr></table></div></figure>


<h3>角标</h3>

<p>扩展也可以给给已有类型添加角标。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">extension</span> <span class="n">Int</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">subscript</span><span class="p">(</span><span class="n">var</span> <span class="nl">digitIndex</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Int</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">var</span> <span class="n">decimalBase</span> <span class="o">=</span> <span class="mi">1</span>
</span><span class='line'>        <span class="k">while</span> <span class="n">digitIndex</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">decimalBase</span> <span class="o">*=</span> <span class="mi">10</span>
</span><span class='line'>            <span class="o">--</span><span class="n">digitIndex</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">return</span> <span class="p">(</span><span class="nb">self</span> <span class="o">/</span> <span class="n">decimalBase</span><span class="p">)</span> <span class="o">%</span> <span class="mi">10</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="mi">746381295</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</span><span class='line'><span class="c1">// returns 5</span>
</span><span class='line'><span class="mi">746381295</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</span><span class='line'><span class="c1">// returns 9</span>
</span><span class='line'><span class="mi">746381295</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
</span><span class='line'><span class="c1">// returns 2</span>
</span><span class='line'><span class="mi">746381295</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span>
</span><span class='line'><span class="c1">// returns 7</span>
</span></code></pre></td></tr></table></div></figure>


<p>注：很有意思的扩展。。。</p>

<h3>嵌套类型</h3>

<p>扩展也可以在已有类型中添加新的嵌套类型。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">extension</span> <span class="n">Int</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">enum</span> <span class="n">Kind</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">case</span> <span class="n">Negative</span><span class="p">,</span> <span class="n">Zero</span><span class="p">,</span> <span class="n">Positive</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">var</span> <span class="nl">kind</span><span class="p">:</span> <span class="n">Kind</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">switch</span> <span class="nb">self</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">case</span> <span class="mi">0</span><span class="o">:</span>
</span><span class='line'>            <span class="k">return</span> <span class="p">.</span><span class="n">Zero</span>
</span><span class='line'>        <span class="k">case</span> <span class="n">let</span> <span class="n">x</span> <span class="n">where</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">:</span>
</span><span class='line'>            <span class="k">return</span> <span class="p">.</span><span class="n">Positive</span>
</span><span class='line'>        <span class="k">default</span><span class="o">:</span>
</span><span class='line'>            <span class="k">return</span> <span class="p">.</span><span class="n">Negative</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">func</span> <span class="nf">printIntegerKinds</span><span class="p">(</span><span class="nl">numbers</span><span class="p">:</span> <span class="p">[</span><span class="n">Int</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">for</span> <span class="n">number</span> <span class="k">in</span> <span class="n">numbers</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">switch</span> <span class="n">number</span><span class="p">.</span><span class="n">kind</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">case</span> <span class="p">.</span><span class="nl">Negative</span><span class="p">:</span>
</span><span class='line'>            <span class="n">print</span><span class="p">(</span><span class="s">&quot;- &quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="k">case</span> <span class="p">.</span><span class="nl">Zero</span><span class="p">:</span>
</span><span class='line'>            <span class="n">print</span><span class="p">(</span><span class="s">&quot;0 &quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="k">case</span> <span class="p">.</span><span class="nl">Positive</span><span class="p">:</span>
</span><span class='line'>            <span class="n">print</span><span class="p">(</span><span class="s">&quot;+ &quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">print</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">printIntegerKinds</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="o">-</span><span class="mi">27</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">7</span><span class="p">])</span>
</span><span class='line'><span class="c1">// prints &quot;+ + - 0 - 0 +&quot;</span>
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Language Guide: Nested Type]]></title>
    <link href="http://zxhfirefox.github.io/blog/2014/10/25/language-guide-u-nested-type/"/>
    <updated>2014-10-25T10:24:19+08:00</updated>
    <id>http://zxhfirefox.github.io/blog/2014/10/25/language-guide-u-nested-type</id>
    <content type="html"><![CDATA[<p>枚举通常被定义来帮助实现一个类和结构体。同样的，有时候为了在一个更复杂的上下文里定义和使用某一些特殊的类型是很方便的。为了达到这一点，Swift允许定义嵌套类型，这样你就可以在需要枚举，类，结构体来支持的复杂的类型里定义他们。</p>

<p>定义嵌套类型，只需要把类型定义写在大括号里面。你需要嵌套几层就嵌套几层。</p>

<!-- more -->


<h5>嵌套类型举例</h5>

<p>下面的例子定义了一个结构体，BlackjackCard，它代表了一种扑克牌。这个结构里有2个嵌套的类型，叫Suit和Rank。</p>

<p>在 Blackjack里，Ace有2个值，1或11.这个值有一个叫Values的结构体表示，这个结构体嵌套在Rank里。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">struct</span> <span class="n">BlackjackCard</span><span class="p">{</span>
</span><span class='line'>  <span class="k">enum</span> <span class="nl">Suit</span><span class="p">:</span> <span class="n">Character</span><span class="p">{</span>
</span><span class='line'>      <span class="k">case</span> <span class="n">Spades</span><span class="o">=</span><span class="s">&quot;s&quot;</span><span class="p">,</span><span class="n">Hearts</span><span class="o">=</span><span class="s">&quot;h&quot;</span><span class="p">,</span><span class="n">Diamonds</span><span class="o">=</span><span class="s">&quot;d&quot;</span><span class="p">,</span><span class="n">Clubs</span><span class="o">=</span><span class="s">&quot;c&quot;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">enum</span> <span class="nl">Rank</span><span class="p">:</span> <span class="n">Int</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">case</span> <span class="n">Two</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">Three</span><span class="p">,</span> <span class="n">Four</span><span class="p">,</span> <span class="n">Five</span><span class="p">,</span> <span class="n">Six</span><span class="p">,</span> <span class="n">Seven</span><span class="p">,</span> <span class="n">Eight</span><span class="p">,</span> <span class="n">Nine</span><span class="p">,</span> <span class="n">Ten</span>
</span><span class='line'>      <span class="k">case</span> <span class="n">Jack</span><span class="p">,</span> <span class="n">Queen</span><span class="p">,</span> <span class="n">King</span><span class="p">,</span> <span class="n">Ace</span>
</span><span class='line'>      <span class="k">struct</span> <span class="n">Values</span><span class="p">{</span>
</span><span class='line'>          <span class="n">let</span> <span class="nl">first</span><span class="p">:</span> <span class="n">Int</span><span class="p">,</span><span class="nl">second</span><span class="p">:</span> <span class="n">Int</span><span class="o">?</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>      <span class="n">var</span> <span class="nl">values</span><span class="p">:</span> <span class="n">Values</span><span class="p">{</span>
</span><span class='line'>          <span class="k">switch</span> <span class="nb">self</span><span class="p">{</span>
</span><span class='line'>          <span class="k">case</span> <span class="p">.</span><span class="nl">Ace</span><span class="p">:</span>
</span><span class='line'>              <span class="k">return</span> <span class="n">Values</span><span class="p">(</span><span class="nl">first</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span><span class="nl">second</span><span class="p">:</span><span class="mi">11</span><span class="p">)</span>
</span><span class='line'>          <span class="k">case</span> <span class="p">.</span><span class="n">Jack</span><span class="p">,</span> <span class="p">.</span><span class="n">Queen</span><span class="p">,</span> <span class="p">.</span><span class="nl">King</span><span class="p">:</span>
</span><span class='line'>              <span class="k">return</span> <span class="n">Values</span><span class="p">(</span><span class="nl">first</span><span class="p">:</span><span class="mi">10</span><span class="p">,</span><span class="nl">second</span><span class="p">:</span><span class="nb">nil</span><span class="p">)</span>
</span><span class='line'>          <span class="k">default</span><span class="o">:</span>
</span><span class='line'>              <span class="k">return</span> <span class="n">Values</span><span class="p">(</span><span class="nl">first</span><span class="p">:</span><span class="nb">self</span><span class="p">.</span><span class="n">toRaw</span><span class="p">(),</span><span class="nl">second</span><span class="p">:</span><span class="nb">nil</span><span class="p">)</span>
</span><span class='line'>          <span class="p">}</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="n">let</span> <span class="nl">rank</span><span class="p">:</span> <span class="n">Rank</span><span class="p">,</span><span class="nl">suit</span><span class="p">:</span> <span class="n">Suit</span>
</span><span class='line'>  <span class="n">var</span> <span class="nl">description</span><span class="p">:</span> <span class="n">String</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">var</span> <span class="n">output</span> <span class="o">=</span> <span class="s">&quot;suit is \(suit.toRaw(),&quot;</span>
</span><span class='line'>      <span class="n">output</span> <span class="o">+=</span> <span class="s">&quot; value is \(rank.values.first)&quot;</span>
</span><span class='line'>      <span class="k">if</span> <span class="n">let</span> <span class="n">second</span> <span class="o">=</span> <span class="n">rank</span><span class="p">.</span><span class="n">values</span><span class="p">.</span><span class="n">second</span> <span class="p">{</span>
</span><span class='line'>          <span class="n">output</span> <span class="o">+=</span> <span class="s">&quot; or \(second)&quot;</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">output</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Suit枚举定义了扑克牌里常见的四种花色。</p>

<p>Rank枚举定义了扑克牌的大小。</p>

<p>Rank还嵌套了一个类型Values来表示扑克牌一般只有一个值，除了Ace有两个值。而Values里有一个Int的first和一个optional的Int的sencond。</p>

<p>Rank还定义了一个计算的属性values，返回一个Values类型的值。</p>

<p>BlackjackCard自己有2个属性，suit和rank。还有一个计算的属性，description。</p>

<p>因为BlackjackCard没有自定义初始化函数，所以它有一个默认的成员初始化函数。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">let</span> <span class="n">theAceOfSpades</span> <span class="o">=</span> <span class="n">BlackjackCard</span><span class="p">(</span><span class="nl">rank</span><span class="p">:</span> <span class="p">.</span><span class="n">Ace</span><span class="p">,</span><span class="nl">suit</span><span class="p">:</span> <span class="p">.</span><span class="n">Spades</span><span class="p">)</span>
</span><span class='line'><span class="n">println</span><span class="p">(</span><span class="n">theAceOfSpades</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>尽管Rank和Suit是嵌套在BlackjackCard里的类型，他们的类型依然可以从上下文里推断出来。</p>

<h5>引用嵌套类型</h5>

<p>如果需要在定义上下文之外的地方使用嵌套类型，需要把外部类型的名字加在嵌套类型的名字的前面：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">let</span> <span class="n">heartsSymbol</span> <span class="o">=</span> <span class="n">BlackjackCard</span><span class="p">.</span><span class="n">Suit</span><span class="p">.</span><span class="n">Hearts</span><span class="p">.</span><span class="n">toRaw</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Language Guide: Type Casting]]></title>
    <link href="http://zxhfirefox.github.io/blog/2014/10/25/language-guide-type-cast/"/>
    <updated>2014-10-25T10:23:07+08:00</updated>
    <id>http://zxhfirefox.github.io/blog/2014/10/25/language-guide-type-cast</id>
    <content type="html"><![CDATA[<p>类型转换是一种检查实例类型的方法，并且或者把这个实例作为它的类别的父类或子类来使用。</p>

<p>Swift里类型转换用is和as操作符。这两个操作符提供了简单的方式来检查一个值的类型或者把一个值转换到另一个类型。</p>

<p>我们也可以用类型转换来检查一个类型是否实现了一个协议。</p>

<!-- more -->


<h3>定义一个类继承树</h3>

<p>我们需要在类继承里检查一个实例是否是某个类的实例，并把它转换到同一个继承树里的其他类。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">class</span> <span class="n">MediaItem</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">var</span> <span class="nl">name</span><span class="p">:</span> <span class="n">String</span>
</span><span class='line'>    <span class="n">init</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">class</span> <span class="nl">Movie</span><span class="p">:</span> <span class="n">MediaItem</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">var</span> <span class="nl">director</span><span class="p">:</span> <span class="n">String</span>
</span><span class='line'>    <span class="n">init</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span> <span class="nl">director</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">director</span> <span class="o">=</span> <span class="n">director</span>
</span><span class='line'>        <span class="nb">super</span><span class="p">.</span><span class="n">init</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="n">name</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">class</span> <span class="nl">Song</span><span class="p">:</span> <span class="n">MediaItem</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">var</span> <span class="nl">artist</span><span class="p">:</span> <span class="n">String</span>
</span><span class='line'>    <span class="n">init</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span> <span class="nl">artist</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">artist</span> <span class="o">=</span> <span class="n">artist</span>
</span><span class='line'>        <span class="nb">super</span><span class="p">.</span><span class="n">init</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="n">name</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们定义了三个类，一个父类，两个子类。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">let</span> <span class="n">library</span> <span class="o">=</span> <span class="p">[</span>
</span><span class='line'>    <span class="n">Movie</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="s">&quot;Casablanca&quot;</span><span class="p">,</span> <span class="nl">director</span><span class="p">:</span> <span class="s">&quot;Michael Curtiz&quot;</span><span class="p">),</span>
</span><span class='line'>    <span class="n">Song</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="s">&quot;Blue Suede Shoes&quot;</span><span class="p">,</span> <span class="nl">artist</span><span class="p">:</span> <span class="s">&quot;Elvis Presley&quot;</span><span class="p">),</span>
</span><span class='line'>    <span class="n">Movie</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="s">&quot;Citizen Kane&quot;</span><span class="p">,</span> <span class="nl">director</span><span class="p">:</span> <span class="s">&quot;Orson Welles&quot;</span><span class="p">),</span>
</span><span class='line'>    <span class="n">Song</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="s">&quot;The One And Only&quot;</span><span class="p">,</span> <span class="nl">artist</span><span class="p">:</span> <span class="s">&quot;Chesney Hawkes&quot;</span><span class="p">),</span>
</span><span class='line'>    <span class="n">Song</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="s">&quot;Never Gonna Give You Up&quot;</span><span class="p">,</span> <span class="nl">artist</span><span class="p">:</span> <span class="s">&quot;Rick Astley&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">]</span>
</span><span class='line'><span class="c1">// the type of &quot;library&quot; is inferred to be [MediaItem]</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们又定义了一个数组，里面包含了一些实例。注意，这个数组的类型是[MediaItem]。当我们遍历数组时，得到的对象也是MediaItem,我们需要向下转换到具体的类。</p>

<h3>检查类型</h3>

<p>使用 is 操作符来检查实例是否是某个特定类的实例。如果是就返回true，如果不是就返回false。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">var</span> <span class="n">movieCount</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'><span class="n">var</span> <span class="n">songCount</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'><span class="k">for</span> <span class="n">item</span> <span class="k">in</span> <span class="n">library</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">item</span> <span class="n">is</span> <span class="n">Movie</span> <span class="p">{</span>
</span><span class='line'>        <span class="o">++</span><span class="n">movieCount</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">item</span> <span class="n">is</span> <span class="n">Song</span> <span class="p">{</span>
</span><span class='line'>        <span class="o">++</span><span class="n">songCount</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">println</span><span class="p">(</span><span class="s">&quot;Media library contains \(movieCount) movies and \(songCount) songs&quot;</span><span class="p">)</span>
</span><span class='line'><span class="c1">// prints &quot;Media library contains 2 movies and 3 songs&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的代码，我们遍历整个数组，判断每个实例的类型，然后分别计算出有多少电影，多少歌曲。</p>

<h3>向下转换（Downcasting）</h3>

<p>一个类型的变量或常量，事实上有可能指向一个这个类的子类。我们可以尝试使用as操作符来尝试向下转换。</p>

<p>因为向下转换可能失败，所以转换操作符有两种形式。as？，返回一个optional。as，尝试转换并强制解包。</p>

<p>当我们不确定实例的类型能否转换成功时，使用as？来做。如果失败了，会返回一个nil。</p>

<p>只有当我们确认实例的类型能够转换成功时，才使用as来做。如果使用了as，却转换失败，会造成运行时错误。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">for</span> <span class="n">item</span> <span class="k">in</span> <span class="n">library</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">let</span> <span class="n">movie</span> <span class="o">=</span> <span class="n">item</span> <span class="n">as</span><span class="o">?</span> <span class="n">Movie</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">println</span><span class="p">(</span><span class="s">&quot;Movie: &#39;\(movie.name)&#39;, dir. \(movie.director)&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">let</span> <span class="n">song</span> <span class="o">=</span> <span class="n">item</span> <span class="n">as</span><span class="o">?</span> <span class="n">Song</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">println</span><span class="p">(</span><span class="s">&quot;Song: &#39;\(song.name)&#39;, by \(song.artist)&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">// Movie: &#39;Casablanca&#39;, dir. Michael Curtiz</span>
</span><span class='line'><span class="c1">// Song: &#39;Blue Suede Shoes&#39;, by Elvis Presley</span>
</span><span class='line'><span class="c1">// Movie: &#39;Citizen Kane&#39;, dir. Orson Welles</span>
</span><span class='line'><span class="c1">// Song: &#39;The One And Only&#39;, by Chesney Hawkes</span>
</span><span class='line'><span class="c1">// Song: &#39;Never Gonna Give You Up&#39;, by Rick Astley</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的代码中，我们尝试把每个实例向下转换到具体的类型。使用as？，然后使用optional绑定来使用真实的值。</p>

<pre><code>注意
转换并不会修改实例或它的值。底层的实例没有改变，只是简单的被当做另一个类型来使用。
</code></pre>

<h3>Any和AnyObject类型转到</h3>

<p>Swift提供了两种比较宽泛的类型：</p>

<ul>
<li>AnyObject可以表示任何类类型的实例</li>
<li><p>Any可以表示任何类型，包括函数类型</p>

<pre><code>注意
仅当需要时在使用Any和AnyObject，尽可能的明确出实例的类型。
</code></pre></li>
</ul>


<h4>AnyObject</h4>

<p>当使用Cocoa的API时，我们经常接收到一个数组类型是[AnyObject]的数组，这是因为ObjC没有指定类型的数组。然而，我们事实上通过API的信息是比较确定数组里元素的类型的。</p>

<p>在这种情况下，我们可以使用as来直接把数组元素向下转换到特定的类型来使用。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">let</span> <span class="nl">someObjects</span><span class="p">:</span> <span class="p">[</span><span class="n">AnyObject</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
</span><span class='line'>    <span class="n">Movie</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="s">&quot;2001: A Space Odyssey&quot;</span><span class="p">,</span> <span class="nl">director</span><span class="p">:</span> <span class="s">&quot;Stanley Kubrick&quot;</span><span class="p">),</span>
</span><span class='line'>    <span class="n">Movie</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="s">&quot;Moon&quot;</span><span class="p">,</span> <span class="nl">director</span><span class="p">:</span> <span class="s">&quot;Duncan Jones&quot;</span><span class="p">),</span>
</span><span class='line'>    <span class="n">Movie</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="s">&quot;Alien&quot;</span><span class="p">,</span> <span class="nl">director</span><span class="p">:</span> <span class="s">&quot;Ridley Scott&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>因为数组里全是Moive类型的实例，所以我们可以直接使用as。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">for</span> <span class="n">object</span> <span class="k">in</span> <span class="n">someObjects</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">movie</span> <span class="o">=</span> <span class="n">object</span> <span class="n">as</span> <span class="n">Movie</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="s">&quot;Movie: &#39;\(movie.name)&#39;, dir. \(movie.director)&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">// Movie: &#39;2001: A Space Odyssey&#39;, dir. Stanley Kubrick</span>
</span><span class='line'><span class="c1">// Movie: &#39;Moon&#39;, dir. Duncan Jones</span>
</span><span class='line'><span class="c1">// Movie: &#39;Alien&#39;, dir. Ridley Scott</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们甚至可以直接把数组向下转换到[Movie]来操作：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">for</span> <span class="n">movie</span> <span class="k">in</span> <span class="n">someObjects</span> <span class="n">as</span> <span class="p">[</span><span class="n">Movie</span><span class="p">]</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="s">&quot;Movie: &#39;\(movie.name)&#39;, dir. \(movie.director)&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">// Movie: &#39;2001: A Space Odyssey&#39;, dir. Stanley Kubrick</span>
</span><span class='line'><span class="c1">// Movie: &#39;Moon&#39;, dir. Duncan Jones</span>
</span><span class='line'><span class="c1">// Movie: &#39;Alien&#39;, dir. Ridley Scott</span>
</span></code></pre></td></tr></table></div></figure>


<h4>Any</h4>

<p>下面的例子里，我们使用Any来操作一个混合类型的数组，可以包括函数类型，和非类类型。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">var</span> <span class="n">things</span> <span class="o">=</span> <span class="p">[</span><span class="n">Any</span><span class="p">]()</span>
</span><span class='line'><span class="n">things</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span><span class='line'><span class="n">things</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
</span><span class='line'><span class="n">things</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
</span><span class='line'><span class="n">things</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mf">3.14159</span><span class="p">)</span>
</span><span class='line'><span class="n">things</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">things</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="mf">3.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">))</span>
</span><span class='line'><span class="n">things</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">Movie</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="s">&quot;Ghostbusters&quot;</span><span class="p">,</span> <span class="nl">director</span><span class="p">:</span> <span class="s">&quot;Ivan Reitman&quot;</span><span class="p">))</span>
</span><span class='line'><span class="n">things</span><span class="p">.</span><span class="n">append</span><span class="p">({</span> <span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">String</span> <span class="k">in</span> <span class="s">&quot;Hello, \(name)&quot;</span> <span class="p">})</span>
</span></code></pre></td></tr></table></div></figure>


<p>数组thing包含了两个Int，两个Double，一个String，一个元组，一个Movie，一个闭包。</p>

<p>我们可以使用is和as用一个switch来处理这个数组：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">for</span> <span class="n">thing</span> <span class="k">in</span> <span class="n">things</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">switch</span> <span class="n">thing</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="mi">0</span> <span class="n">as</span> <span class="nl">Int</span><span class="p">:</span>
</span><span class='line'>        <span class="n">println</span><span class="p">(</span><span class="s">&quot;zero as an Int&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="k">case</span> <span class="mi">0</span> <span class="n">as</span> <span class="nl">Double</span><span class="p">:</span>
</span><span class='line'>        <span class="n">println</span><span class="p">(</span><span class="s">&quot;zero as a Double&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">let</span> <span class="n">someInt</span> <span class="n">as</span> <span class="nl">Int</span><span class="p">:</span>
</span><span class='line'>        <span class="n">println</span><span class="p">(</span><span class="s">&quot;an integer value of \(someInt)&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">let</span> <span class="n">someDouble</span> <span class="n">as</span> <span class="n">Double</span> <span class="n">where</span> <span class="n">someDouble</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">:</span>
</span><span class='line'>        <span class="n">println</span><span class="p">(</span><span class="s">&quot;a positive double value of \(someDouble)&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">is</span> <span class="nl">Double</span><span class="p">:</span>
</span><span class='line'>        <span class="n">println</span><span class="p">(</span><span class="s">&quot;some other double value that I don&#39;t want to print&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">let</span> <span class="n">someString</span> <span class="n">as</span> <span class="nl">String</span><span class="p">:</span>
</span><span class='line'>        <span class="n">println</span><span class="p">(</span><span class="s">&quot;a string value of </span><span class="se">\&quot;</span><span class="s">\(someString)</span><span class="se">\&quot;</span><span class="s">&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">let</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="n">as</span> <span class="p">(</span><span class="n">Double</span><span class="p">,</span> <span class="n">Double</span><span class="p">)</span><span class="o">:</span>
</span><span class='line'>        <span class="n">println</span><span class="p">(</span><span class="s">&quot;an (x, y) point at \(x), \(y)&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">let</span> <span class="n">movie</span> <span class="n">as</span> <span class="nl">Movie</span><span class="p">:</span>
</span><span class='line'>        <span class="n">println</span><span class="p">(</span><span class="s">&quot;a movie called &#39;\(movie.name)&#39;, dir. \(movie.director)&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">let</span> <span class="n">stringConverter</span> <span class="n">as</span> <span class="n">String</span> <span class="o">-&gt;</span> <span class="nl">String</span><span class="p">:</span>
</span><span class='line'>        <span class="n">println</span><span class="p">(</span><span class="n">stringConverter</span><span class="p">(</span><span class="s">&quot;Michael&quot;</span><span class="p">))</span>
</span><span class='line'>    <span class="k">default</span><span class="o">:</span>
</span><span class='line'>        <span class="n">println</span><span class="p">(</span><span class="s">&quot;something else&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">// zero as an Int</span>
</span><span class='line'><span class="c1">// zero as a Double</span>
</span><span class='line'><span class="c1">// an integer value of 42</span>
</span><span class='line'><span class="c1">// a positive double value of 3.14159</span>
</span><span class='line'><span class="c1">// a string value of &quot;hello&quot;</span>
</span><span class='line'><span class="c1">// an (x, y) point at 3.0, 5.0</span>
</span><span class='line'><span class="c1">// a movie called &#39;Ghostbusters&#39;, dir. Ivan Reitman</span>
</span><span class='line'><span class="c1">// Hello, Michael</span>
</span></code></pre></td></tr></table></div></figure>


<pre><code>注意
在switch里我们使用as而不是as？来检查和转换类型。在switch里这样做总是安全的。
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Language Guide: Optional Chaining]]></title>
    <link href="http://zxhfirefox.github.io/blog/2014/10/25/language-guide-optional-chaining/"/>
    <updated>2014-10-25T10:22:10+08:00</updated>
    <id>http://zxhfirefox.github.io/blog/2014/10/25/language-guide-optional-chaining</id>
    <content type="html"><![CDATA[<p>Optional链条是一种在一个optional上查询，调用属性，方法和角标得时候，这个optional的值可能是nil得一种操作。如果这个optional有值，那么属性，方法，角标的调用会成功，如果optional是nil，属性，方法，角标的调用返回nil。多个查询可以链接在一起，整个链接在有任何一个地方为nil时简单的返回失败。</p>

<pre><code>注意
Optional链条有点类似于ObjC中给nil发送消息，但是它可以使用在任何类型上，而且也可以检查成功或失败。
</code></pre>

<!-- more -->


<h3>Optional链条作为强制解包的替换方案</h3>

<p>我们在我们期望的属性，方法，角标后面加？来表示optional链条。这和在一个optional值的后面加！来强制解包很相似。主要区别在于如果optional值为nil，链条会简单的失败，而强制解包会触发运行时错误。</p>

<p>为了反映optional链条可以调用在一个nil上，整个链条的返回值都是一个optional的值，即使你访问的属性，方法，角标并不是optional的。我们可以使用这个返回值来检查optional链条的调用是否成功，或者因为有nil值而没有成功。</p>

<p>特别的，optional链条调用的结果和预期的结果类型相同，包裹在一个optional里。一个返回Int的属性会返回Int？。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">class</span> <span class="n">Person</span><span class="p">{</span>
</span><span class='line'>    <span class="n">var</span> <span class="nl">residence</span><span class="p">:</span> <span class="n">Residence</span><span class="o">?</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">class</span> <span class="n">Residence</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">var</span> <span class="n">numberOfRooms</span> <span class="o">=</span> <span class="mi">1</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们定义了两个类。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">let</span> <span class="n">john</span> <span class="o">=</span> <span class="n">Person</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p>创建一个Person对象，这时候它的residence是nil。如果我们强制访问residence的numberOfRooms属性就会触发运行时错误。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">let</span> <span class="n">roomCount</span> <span class="o">=</span> <span class="n">john</span><span class="p">.</span><span class="n">residence</span><span class="o">!</span><span class="p">.</span><span class="n">numberOfRooms</span>
</span><span class='line'><span class="c1">// this triggers a runtime error</span>
</span></code></pre></td></tr></table></div></figure>


<p>然而，我们使用optional链条来处理这个：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">if</span> <span class="n">let</span> <span class="n">roomCount</span> <span class="o">=</span> <span class="n">john</span><span class="p">.</span><span class="n">residence</span><span class="o">?</span><span class="p">.</span><span class="n">numberOfRooms</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="s">&quot;John&#39;s residence has \(roomCount) room(s).&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="s">&quot;Unable to retrieve the number of rooms.&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">// prints &quot;Unable to retrieve the number of rooms.&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>因为residence是nil，所以optional链条失败，返回nil。</p>

<p>如果我们给residence附值。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">john</span><span class="p">.</span><span class="n">residence</span> <span class="o">=</span> <span class="n">Residence</span><span class="p">()</span>
</span><span class='line'><span class="k">if</span> <span class="n">let</span> <span class="n">roomCount</span> <span class="o">=</span> <span class="n">john</span><span class="p">.</span><span class="n">residence</span><span class="o">?</span><span class="p">.</span><span class="n">numberOfRooms</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="s">&quot;John&#39;s residence has \(roomCount) room(s).&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="s">&quot;Unable to retrieve the number of rooms.&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">// prints &quot;John&#39;s residence has 1 room(s).&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>optional链条就成功了，返回了正确的numberOfRooms。</p>

<h3>为optional链条定义模型类</h3>

<p>我们多层次的使用optional链条来调用属性，方法，角标。这使得你可以不断向下的访问复杂的模型类的属性，并且检查是否可以访问属性，方法，角标。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">class</span> <span class="n">Person</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">var</span> <span class="nl">residence</span><span class="p">:</span> <span class="n">Residence</span><span class="o">?</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">class</span> <span class="n">Residence</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">var</span> <span class="n">rooms</span> <span class="o">=</span> <span class="p">[</span><span class="n">Room</span><span class="p">]()</span>
</span><span class='line'>    <span class="n">var</span> <span class="nl">numberOfRooms</span><span class="p">:</span> <span class="n">Int</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">rooms</span><span class="p">.</span><span class="n">count</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">subscript</span><span class="p">(</span><span class="nl">i</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Room</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">get</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="n">rooms</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="n">set</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">rooms</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">newValue</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">func</span> <span class="n">printNumberOfRooms</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">println</span><span class="p">(</span><span class="s">&quot;The number of rooms is \(numberOfRooms)&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">var</span> <span class="nl">address</span><span class="p">:</span> <span class="n">Address</span><span class="o">?</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这次，我们的Residence有多个Room，所以numberOfRooms成为了一个计算属性。并实现了角标访问来访问或设置Room。最后，它还有一个optional的Address。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">class</span> <span class="n">Room</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">let</span> <span class="nl">name</span><span class="p">:</span> <span class="n">String</span>
</span><span class='line'>    <span class="n">init</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span> <span class="nb">self</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span> <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">class</span> <span class="n">Address</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">var</span> <span class="nl">buildingName</span><span class="p">:</span> <span class="n">String</span><span class="o">?</span>
</span><span class='line'>    <span class="n">var</span> <span class="nl">buildingNumber</span><span class="p">:</span> <span class="n">String</span><span class="o">?</span>
</span><span class='line'>    <span class="n">var</span> <span class="nl">street</span><span class="p">:</span> <span class="n">String</span><span class="o">?</span>
</span><span class='line'>    <span class="n">func</span> <span class="n">buildingIdentifier</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">String</span><span class="o">?</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="n">buildingName</span> <span class="o">!=</span> <span class="nb">nil</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="n">buildingName</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">buildingNumber</span> <span class="o">!=</span> <span class="nb">nil</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="n">buildingNumber</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="nb">nil</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们定义了Room和Address类，Address类有3个optional的属性，和一个返回optional的String的方法。</p>

<h3>通过optional链条访问属性</h3>

<p>我们可以通过optional链条来访问一个optional值的属性，并检查访问是否成功。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">let</span> <span class="n">john</span> <span class="o">=</span> <span class="n">Person</span><span class="p">()</span>
</span><span class='line'><span class="k">if</span> <span class="n">let</span> <span class="n">roomCount</span> <span class="o">=</span> <span class="n">john</span><span class="p">.</span><span class="n">residence</span><span class="o">?</span><span class="p">.</span><span class="n">numberOfRooms</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="s">&quot;John&#39;s residence has \(roomCount) room(s).&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="s">&quot;Unable to retrieve the number of rooms.&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">// prints &quot;Unable to retrieve the number of rooms.&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的例子和之前一样，因为没有residence，所以没有办法访问房间数。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">let</span> <span class="n">someAddress</span> <span class="o">=</span> <span class="n">Address</span><span class="p">()</span>
</span><span class='line'><span class="n">someAddress</span><span class="p">.</span><span class="n">buildingNumber</span> <span class="o">=</span> <span class="s">&quot;29&quot;</span>
</span><span class='line'><span class="n">someAddress</span><span class="p">.</span><span class="n">street</span> <span class="o">=</span> <span class="s">&quot;Acacia Road&quot;</span>
</span><span class='line'><span class="n">john</span><span class="p">.</span><span class="n">residence</span><span class="o">?</span><span class="p">.</span><span class="n">address</span> <span class="o">=</span> <span class="n">someAddress</span>
</span></code></pre></td></tr></table></div></figure>


<p>这次，我们通过optional链条来给属性附值，但是因为residence是nil，所以附值依然是失败的。</p>

<h3>通过optional链条调用方法</h3>

<p>我们可以用optional链条来调用一个optional值的方法，然后检查调用是否成功。即使这个方法不返回值，我们也能这么做。</p>

<p>Residence的printNumberOfRooms方法，没有给出返回值。</p>

<p>但是，没有给出返回值的方法其实是返回了Void类型，这意味着他们返回了一个空元组()。</p>

<p>如果我们把这个方法调用在optional链条时，这个方法会返回Void？，而不是Void。这样我们可以用if语句来检查我们能不能调用printNumberOfRooms方法即便方法自己没有定义返回值。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">if</span> <span class="n">john</span><span class="p">.</span><span class="n">residence</span><span class="o">?</span><span class="p">.</span><span class="n">printNumberOfRooms</span><span class="p">()</span> <span class="o">!=</span> <span class="nb">nil</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="s">&quot;It was possible to print the number of rooms.&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="s">&quot;It was not possible to print the number of rooms.&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">// prints &quot;It was not possible to print the number of rooms.&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>任何尝试通过optional链条设置属性的操作都会返回一个Void？，我们可以用来检查设置属性是否成功：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">john</span><span class="p">.</span><span class="n">residence</span><span class="o">?</span><span class="p">.</span><span class="n">address</span> <span class="o">=</span> <span class="n">someAddress</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">nil</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="s">&quot;It was possible to set the address.&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="s">&quot;It was not possible to set the address.&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">// prints &quot;It was not possible to set the address.&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<h3>通过optional链条访问角标</h3>

<p>我们可以通过在optional的值上使用optional链条来获取或设置角标的值，并且检查是否成功。</p>

<pre><code>注意
当我们使用optional链条来访问角标值的时候我们总是把？放在方括号的前面。事实上，optional链条的？总是紧跟着optional的值。
</code></pre>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">if</span> <span class="n">let</span> <span class="n">firstRoomName</span> <span class="o">=</span> <span class="n">john</span><span class="p">.</span><span class="n">residence</span><span class="o">?</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">name</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="s">&quot;The first room name is \(firstRoomName).&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="s">&quot;Unable to retrieve the first room name.&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">// prints &quot;Unable to retrieve the first room name.&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>？紧跟在residence后面，因为residence是我们要检查的optional值。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">john</span><span class="p">.</span><span class="n">residence</span><span class="o">?</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">Room</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="s">&quot;Bathroom&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>通过角标设置也是，这个操作也是失败的，因为residence是nil。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">let</span> <span class="n">johnsHouse</span> <span class="o">=</span> <span class="n">Residence</span><span class="p">()</span>
</span><span class='line'><span class="n">johnsHouse</span><span class="p">.</span><span class="n">rooms</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">Room</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="s">&quot;Living Room&quot;</span><span class="p">))</span>
</span><span class='line'><span class="n">johnsHouse</span><span class="p">.</span><span class="n">rooms</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">Room</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="s">&quot;Kitchen&quot;</span><span class="p">))</span>
</span><span class='line'><span class="n">john</span><span class="p">.</span><span class="n">residence</span> <span class="o">=</span> <span class="n">johnsHouse</span>
</span><span class='line'><span class="k">if</span> <span class="n">let</span> <span class="n">firstRoomName</span> <span class="o">=</span> <span class="n">john</span><span class="p">.</span><span class="n">residence</span><span class="o">?</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">name</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="s">&quot;The first room name is \(firstRoomName).&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="s">&quot;Unable to retrieve the first room name.&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">// prints &quot;The first room name is Living Room.&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>在我们给residence附值之后，optional链条的操作就会成功。</p>

<h4>访问optional类型的角标</h4>

<p>如果一个角标的返回值是optional，那我们在使用optional链条时需要把？放到方括号的后面。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">var</span> <span class="n">testScores</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;Dave&quot;</span><span class="o">:</span> <span class="p">[</span><span class="mi">86</span><span class="p">,</span> <span class="mi">82</span><span class="p">,</span> <span class="mi">84</span><span class="p">],</span> <span class="s">&quot;Bev&quot;</span><span class="o">:</span> <span class="p">[</span><span class="mi">79</span><span class="p">,</span> <span class="mi">94</span><span class="p">,</span> <span class="mi">81</span><span class="p">]]</span>
</span><span class='line'><span class="n">testScores</span><span class="p">[</span><span class="s">&quot;Dave&quot;</span><span class="p">]</span><span class="o">?</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">91</span>
</span><span class='line'><span class="n">testScores</span><span class="p">[</span><span class="s">&quot;Bev&quot;</span><span class="p">]</span><span class="o">?</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">++</span>
</span><span class='line'><span class="n">testScores</span><span class="p">[</span><span class="s">&quot;Brian&quot;</span><span class="p">]</span><span class="o">?</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">72</span>
</span><span class='line'><span class="c1">// the &quot;Dave&quot; array is now [91, 82, 84] and the &quot;Bev&quot; array is now [80, 94, 81]</span>
</span></code></pre></td></tr></table></div></figure>


<h3>连接多个层次的链条</h3>

<p>我们多层次的使用optional链条来访问深入访问模型的方法，属性和角标。但是，多层次的optional并不会增加多层次的optional值。</p>

<p>换句话说：</p>

<ul>
<li>如果我们获取的类型不是optional的，它会变成optional。</li>
<li>如果获取的已经是optional的，它不会变的更加optional。</li>
</ul>


<p>因此：</p>

<ul>
<li>如果我们访问的返回值是Int，返回它会返回Int？</li>
<li>如果我们访问的已经是Int？，那么返回的就是Int？</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">if</span> <span class="n">let</span> <span class="n">johnsStreet</span> <span class="o">=</span> <span class="n">john</span><span class="p">.</span><span class="n">residence</span><span class="o">?</span><span class="p">.</span><span class="n">address</span><span class="o">?</span><span class="p">.</span><span class="n">street</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="s">&quot;John&#39;s street name is \(johnsStreet).&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="s">&quot;Unable to retrieve the address.&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">// prints &quot;Unable to retrieve the address.&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里，我们连续的使用optional链条来访问street属性。而street属性本身就是String？的，所以整个链条返回的类型也是String？。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">let</span> <span class="n">johnsAddress</span> <span class="o">=</span> <span class="n">Address</span><span class="p">()</span>
</span><span class='line'><span class="n">johnsAddress</span><span class="p">.</span><span class="n">buildingName</span> <span class="o">=</span> <span class="s">&quot;The Larches&quot;</span>
</span><span class='line'><span class="n">johnsAddress</span><span class="p">.</span><span class="n">street</span> <span class="o">=</span> <span class="s">&quot;Laurel Street&quot;</span>
</span><span class='line'><span class="n">john</span><span class="p">.</span><span class="n">residence</span><span class="o">!</span><span class="p">.</span><span class="n">address</span> <span class="o">=</span> <span class="n">johnsAddress</span>
</span><span class='line'><span class="k">if</span> <span class="n">let</span> <span class="n">johnsStreet</span> <span class="o">=</span> <span class="n">john</span><span class="p">.</span><span class="n">residence</span><span class="o">?</span><span class="p">.</span><span class="n">address</span><span class="o">?</span><span class="p">.</span><span class="n">street</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="s">&quot;John&#39;s street name is \(johnsStreet).&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="s">&quot;Unable to retrieve the address.&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">// prints &quot;John&#39;s street name is Laurel Street.&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<h3>链接到有optional返回值的方法</h3>

<p>上面的例子是我们通过optional链条来尝试访问一个optional类型的属性。</p>

<p>我们也可以把一个返回optional值的方法链接到链条里。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">if</span> <span class="n">let</span> <span class="n">buildingIdentifier</span> <span class="o">=</span> <span class="n">john</span><span class="p">.</span><span class="n">residence</span><span class="o">?</span><span class="p">.</span><span class="n">address</span><span class="o">?</span><span class="p">.</span><span class="n">buildingIdentifier</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="s">&quot;John&#39;s building identifier is \(buildingIdentifier).&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">// prints &quot;John&#39;s building identifier is The Larches.&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们也可以继续把更多的方法链接到一起。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">if</span> <span class="n">let</span> <span class="n">beginsWithThe</span> <span class="o">=</span>
</span><span class='line'>    <span class="n">john</span><span class="p">.</span><span class="n">residence</span><span class="o">?</span><span class="p">.</span><span class="n">address</span><span class="o">?</span><span class="p">.</span><span class="n">buildingIdentifier</span><span class="p">()</span><span class="o">?</span><span class="p">.</span><span class="n">hasPrefix</span><span class="p">(</span><span class="s">&quot;The&quot;</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="n">beginsWithThe</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">println</span><span class="p">(</span><span class="s">&quot;John&#39;s building identifier begins with </span><span class="se">\&quot;</span><span class="s">The</span><span class="se">\&quot;</span><span class="s">.&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">println</span><span class="p">(</span><span class="s">&quot;John&#39;s building identifier does not begin with </span><span class="se">\&quot;</span><span class="s">The</span><span class="se">\&quot;</span><span class="s">.&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">// prints &quot;John&#39;s building identifier begins with &quot;The&quot;.&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<pre><code>注意
注意?在括弧的后面。
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Language Guide: ARC]]></title>
    <link href="http://zxhfirefox.github.io/blog/2014/10/25/language-guide-arc/"/>
    <updated>2014-10-25T10:21:04+08:00</updated>
    <id>http://zxhfirefox.github.io/blog/2014/10/25/language-guide-arc</id>
    <content type="html"><![CDATA[<p>Swift使用自动引用计数（ARC）来追踪和管理内存使用。在绝大多数情况下，这意味着内存管理并不需要你自己去思考太多。ARC自动会把那些不在需要的对象实例的内存释放掉。</p>

<p>然而，在少数情况下，ARC需要对实例之间的关系有更明确的了解来更好的管理内存。这里我们就讲解这些情况来让ARC更好的管理内存。</p>

<pre><code>注意
引用计数只针对类实例，枚举和结构体都是值对象，不是引用对象。
</code></pre>

<!-- more -->


<h3>ARC原理</h3>

<p>每当你创建一个类的实例，ARC会为这个实例分配一定的内存。这块内存包含实例类型的信息和类型存储属性的值。</p>

<p>另外，当一个实例不在需要时，ARC会释放之前分配给这个实例的对象，回收的内存会作为其他使用。这样确保了不在使用的实例不会依然占用内存。</p>

<p>然而，如果ARC要销毁一个仍在使用的实例，那我们就无法在访问这个实例的属性，调用它的方法。事实上，如果你这么做了，程序就会崩溃。</p>

<p>为了确保实例在我们需要的时候不会被销毁，ARC会追踪有多少属性，常量，变量正在引用每一个类实例。只要还有引用存在，ARC就不会去释放对象的内存。</p>

<p>每当你把一个类实例附值给一个属性，常量或变量，这个属性，常量或变量就会对这个实例有一个强引用。这个引用叫强引用是因为它可以保持持有一个对象，不允许这个对象被销毁。</p>

<h3>ARC实战</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">class</span> <span class="n">Person</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">let</span> <span class="nl">name</span><span class="p">:</span> <span class="n">String</span>
</span><span class='line'>    <span class="n">init</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
</span><span class='line'>        <span class="n">println</span><span class="p">(</span><span class="s">&quot;\(name) is being initialized&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">deinit</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">println</span><span class="p">(</span><span class="s">&quot;\(name) is being deinitialized&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们先定义一个类Person，在初始化和反初始化里打印一些信息。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">var</span> <span class="nl">reference1</span><span class="p">:</span> <span class="n">Person</span><span class="o">?</span>
</span><span class='line'><span class="n">var</span> <span class="nl">reference2</span><span class="p">:</span> <span class="n">Person</span><span class="o">?</span>
</span><span class='line'><span class="n">var</span> <span class="nl">reference3</span><span class="p">:</span> <span class="n">Person</span><span class="o">?</span>
</span></code></pre></td></tr></table></div></figure>


<p>声明3个optional的Person变量，初始值为 nil。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">reference1</span> <span class="o">=</span> <span class="n">Person</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="s">&quot;John Appleseed&quot;</span><span class="p">)</span>
</span><span class='line'><span class="c1">// prints &quot;John Appleseed is being initialized&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>创建一个对象。这时候reference1 是对这个实例的一个强引用。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">reference2</span> <span class="o">=</span> <span class="n">reference1</span>
</span><span class='line'><span class="n">reference3</span> <span class="o">=</span> <span class="n">reference1</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们把reference1附值给reference2和reference3，这样我们又多了2个强引用到我们的实例。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">reference1</span> <span class="o">=</span> <span class="nb">nil</span>
</span><span class='line'><span class="n">reference2</span> <span class="o">=</span> <span class="nb">nil</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们reference1和reference2 设置为 nil。这样他们就不在持有实例的强引用，注意，我们虽然把reference1 设置了 nil，实例的反初始化函数并没有调用，因为我们其实还有reference3持有对象的强引用。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">reference3</span> <span class="o">=</span> <span class="nb">nil</span>
</span><span class='line'><span class="c1">// prints &quot;John Appleseed is being deinitialized&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>在我们把reference3 设置 nil 之后， ARC会把实例对象销毁。</p>

<h3>类实例间的强引用循环</h3>

<p>在上面的例子中，ARC可以追踪对Person实例的强引用，并且在没有强引用释放内存。</p>

<p>然而，我们有可能写出使一个类实例的强引用永远不会降到0的代码。比如我们让两个对象互相引用对方，那么这2个对象一致持有对方，这叫做强引用循环。</p>

<p>我们通过在这种引用关系里定义一些类似于弱的，非持有的关系来打断引用循环。</p>

<p>我们先来看看引用循环是如何造成的。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">class</span> <span class="n">Person</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">let</span> <span class="nl">name</span><span class="p">:</span> <span class="n">String</span>
</span><span class='line'>    <span class="n">init</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span> <span class="nb">self</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span> <span class="p">}</span>
</span><span class='line'>    <span class="n">var</span> <span class="nl">apartment</span><span class="p">:</span> <span class="n">Apartment</span><span class="o">?</span>
</span><span class='line'>    <span class="n">deinit</span> <span class="p">{</span> <span class="n">println</span><span class="p">(</span><span class="s">&quot;\(name) is being deinitialized&quot;</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">class</span> <span class="n">Apartment</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">let</span> <span class="nl">number</span><span class="p">:</span> <span class="n">Int</span>
</span><span class='line'>    <span class="n">init</span><span class="p">(</span><span class="nl">number</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">{</span> <span class="nb">self</span><span class="p">.</span><span class="n">number</span> <span class="o">=</span> <span class="n">number</span> <span class="p">}</span>
</span><span class='line'>    <span class="n">var</span> <span class="nl">tenant</span><span class="p">:</span> <span class="n">Person</span><span class="o">?</span>
</span><span class='line'>    <span class="n">deinit</span> <span class="p">{</span> <span class="n">println</span><span class="p">(</span><span class="s">&quot;Apartment #\(number) is being deinitialized&quot;</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们定义了2个类，Person有一个名字，和一个optional的apartment，初始值是nil。Apartment有个数字，和一个optional的tenant，初始值为nil。两个类都实现了反初始化函数来打印一些信息。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">var</span> <span class="nl">john</span><span class="p">:</span> <span class="n">Person</span><span class="o">?</span>
</span><span class='line'><span class="n">var</span> <span class="nl">number73</span><span class="p">:</span> <span class="n">Apartment</span><span class="o">?</span>
</span><span class='line'><span class="n">john</span> <span class="o">=</span> <span class="n">Person</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="s">&quot;John Appleseed&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">number73</span> <span class="o">=</span> <span class="n">Apartment</span><span class="p">(</span><span class="nl">number</span><span class="p">:</span> <span class="mi">73</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们分别创建两个实例。这时候john的apartment和number73的tenant都还是nil。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">john</span><span class="o">!</span><span class="p">.</span><span class="n">apartment</span> <span class="o">=</span> <span class="n">number73</span>
</span><span class='line'><span class="n">number73</span><span class="o">!</span><span class="p">.</span><span class="n">tenant</span> <span class="o">=</span> <span class="n">john</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后，我们把他们关联起来，注意使用 ！来解包。在这时候，两个实例互相之间都拿着对方的强引用。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">john</span> <span class="o">=</span> <span class="nb">nil</span>
</span><span class='line'><span class="n">number73</span> <span class="o">=</span> <span class="nb">nil</span>
</span></code></pre></td></tr></table></div></figure>


<p>尽管我们把变量设置为nil。也没有触发反初始化函数，证明了他们之间存在互相的强引用。这样我们再也无法获取到这2个实例的内存。我们的程序就内存泄露了。</p>

<h3>解决强引用循环</h3>

<p>Swift有两种方式来解决强引用循环。弱引用（weak reference）和 非持有引用（unowned reference）。</p>

<p>他们两个都使得一个实例引用到另一个实例，但不是一个强引用。这样对象之间就可以互相引用而不形成强引用循环。</p>

<p>当你知道如果这个引用有时候会成为nil的时候使用弱引用。相反的，如果你知道这个引用一旦设置就永远不会是nil得时候使用非持有引用。</p>

<h4>弱引用</h4>

<p>弱引用是一种不会持有实例的引用，也就不会阻止ARC去销毁实例。这种行为可以阻止强引用循环。使用 weak 关键字来声明弱引用。</p>

<p>如果这个引用在使用期间可能是nil得话，就需要使用weak，如果这个引用在使用期间总是有值，那么就该使用非持有引用。在上面的例子里，因为apartment可能没有tenant，所以用weak来打破引用循环比较合适。</p>

<pre><code>注意
弱引用必须声明为变量，来表示他们的值可能是nil。弱引用不能是常量。
</code></pre>

<p>因为弱引用允许没有值，所以我们必须把每一个弱引用都声明为optional的。</p>

<p>因为弱引用不会阻止ARC销毁实例，所以ARC在销毁实例时，弱引用不应该继续引用实例。ARC会在销毁时把弱引用设置为nil。我们可以像检查普通optional一样来检查弱引用是否为nil。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">class</span> <span class="n">Person</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">let</span> <span class="nl">name</span><span class="p">:</span> <span class="n">String</span>
</span><span class='line'>    <span class="n">init</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span> <span class="nb">self</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span> <span class="p">}</span>
</span><span class='line'>    <span class="n">var</span> <span class="nl">apartment</span><span class="p">:</span> <span class="n">Apartment</span><span class="o">?</span>
</span><span class='line'>    <span class="n">deinit</span> <span class="p">{</span> <span class="n">println</span><span class="p">(</span><span class="s">&quot;\(name) is being deinitialized&quot;</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">class</span> <span class="n">Apartment</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">let</span> <span class="nl">number</span><span class="p">:</span> <span class="n">Int</span>
</span><span class='line'>    <span class="n">init</span><span class="p">(</span><span class="nl">number</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">{</span> <span class="nb">self</span><span class="p">.</span><span class="n">number</span> <span class="o">=</span> <span class="n">number</span> <span class="p">}</span>
</span><span class='line'>    <span class="k">weak</span> <span class="n">var</span> <span class="nl">tenant</span><span class="p">:</span> <span class="n">Person</span><span class="o">?</span>
</span><span class='line'>    <span class="n">deinit</span> <span class="p">{</span> <span class="n">println</span><span class="p">(</span><span class="s">&quot;Apartment #\(number) is being deinitialized&quot;</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">var</span> <span class="nl">john</span><span class="p">:</span> <span class="n">Person</span><span class="o">?</span>
</span><span class='line'><span class="n">var</span> <span class="nl">number73</span><span class="p">:</span> <span class="n">Apartment</span><span class="o">?</span>
</span><span class='line'><span class="n">john</span> <span class="o">=</span> <span class="n">Person</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="s">&quot;John Appleseed&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">number73</span> <span class="o">=</span> <span class="n">Apartment</span><span class="p">(</span><span class="nl">number</span><span class="p">:</span> <span class="mi">73</span><span class="p">)</span>
</span><span class='line'><span class="n">john</span><span class="o">!</span><span class="p">.</span><span class="n">apartment</span> <span class="o">=</span> <span class="n">number73</span>
</span><span class='line'><span class="n">number73</span><span class="o">!</span><span class="p">.</span><span class="n">tenant</span> <span class="o">=</span> <span class="n">john</span>
</span><span class='line'><span class="n">john</span> <span class="o">=</span> <span class="nb">nil</span>
</span><span class='line'><span class="c1">// prints &quot;John Appleseed is being deinitialized&quot;</span>
</span><span class='line'><span class="n">number73</span> <span class="o">=</span> <span class="nb">nil</span>
</span><span class='line'><span class="c1">// prints &quot;Apartment #73 is being deinitialized&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<h4>非持有引用</h4>

<p>和弱引用一样，非持有引用也不会对实例强引用。和弱引用不一样，非持有引用会认为引用的实例一致存在。因为这个，非持有引用一般并不需要定义为optional的。使用 unowned 关键字来定义非持有引用。</p>

<p>因为非持有引用不是optional的，所以你不用每次都去解包。但是,ARC没有办法在实例被销毁时把非持有引用设置为nil，因为他不是optional的。</p>

<pre><code>注意
如果我们尝试在一个实例已经被销毁了，还去访问一个非持有引用，这将是运行时错误。只有在你确认对象不会销毁的情况下使用非持有引用。

另外，Swift确保你在这么做的时候肯定崩溃。所以我们需要避免它。
</code></pre>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">class</span> <span class="n">Customer</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">let</span> <span class="nl">name</span><span class="p">:</span> <span class="n">String</span>
</span><span class='line'>    <span class="n">var</span> <span class="nl">card</span><span class="p">:</span> <span class="n">CreditCard</span><span class="o">?</span>
</span><span class='line'>    <span class="n">init</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">deinit</span> <span class="p">{</span> <span class="n">println</span><span class="p">(</span><span class="s">&quot;\(name) is being deinitialized&quot;</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">class</span> <span class="n">CreditCard</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">let</span> <span class="nl">number</span><span class="p">:</span> <span class="n">UInt64</span>
</span><span class='line'>    <span class="n">unowned</span> <span class="n">let</span> <span class="nl">customer</span><span class="p">:</span> <span class="n">Customer</span>
</span><span class='line'>    <span class="n">init</span><span class="p">(</span><span class="nl">number</span><span class="p">:</span> <span class="n">UInt64</span><span class="p">,</span> <span class="nl">customer</span><span class="p">:</span> <span class="n">Customer</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">number</span> <span class="o">=</span> <span class="n">number</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">customer</span> <span class="o">=</span> <span class="n">customer</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">deinit</span> <span class="p">{</span> <span class="n">println</span><span class="p">(</span><span class="s">&quot;Card #\(number) is being deinitialized&quot;</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们定义了两个类。Customer和CreditCard。因为CreditCard从创建开始就会一值有一个持有者。所以为了避免引用循环，这里使用了unowned。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">var</span> <span class="nl">john</span><span class="p">:</span> <span class="n">Customer</span><span class="o">?</span>
</span><span class='line'><span class="n">john</span> <span class="o">=</span> <span class="n">Customer</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="s">&quot;John Appleseed&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">john</span><span class="o">!</span><span class="p">.</span><span class="n">card</span> <span class="o">=</span> <span class="n">CreditCard</span><span class="p">(</span><span class="nl">number</span><span class="p">:</span> <span class="mi">1234</span><span class="n">_5678_9012_3456</span><span class="p">,</span> <span class="nl">customer</span><span class="p">:</span> <span class="n">john</span><span class="o">!</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们创建对象，并把他们关联起来。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">john</span> <span class="o">=</span> <span class="nb">nil</span>
</span><span class='line'><span class="c1">// prints &quot;John Appleseed is being deinitialized&quot;</span>
</span><span class='line'><span class="c1">// prints &quot;Card #1234567890123456 is being deinitialized&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>当我们把john设置为nil时，它引用的Custyomer实例就不在被任何强引用引用，所以被ARC销毁，在这之后，对应的CreditCard实例也不再被任何强引用引用。所以也跟着被ARC销毁了。</p>

<h4>非持有引用和自动解包的optional属性</h4>

<p>我们分别用例子讲解了弱引用和非持有引用来打断强引用循环的方式。</p>

<p>然而，有第三种情况，在这里，两个属性都应该有值，而且在初始化结束后就该一直有值。这时候，我们需要把一个类的非持有属性和一个另一个类的自动解包的optional组合起来。</p>

<p>这样，我们可以直接访问这两个属性，不用解包，同时也避免了引用循环。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">class</span> <span class="n">Country</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">let</span> <span class="nl">name</span><span class="p">:</span> <span class="n">String</span>
</span><span class='line'>    <span class="n">let</span> <span class="nl">capitalCity</span><span class="p">:</span> <span class="n">City</span><span class="o">!</span>
</span><span class='line'>    <span class="n">init</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span> <span class="nl">capitalName</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">capitalCity</span> <span class="o">=</span> <span class="n">City</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="n">capitalName</span><span class="p">,</span> <span class="nl">country</span><span class="p">:</span> <span class="nb">self</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">class</span> <span class="n">City</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">let</span> <span class="nl">name</span><span class="p">:</span> <span class="n">String</span>
</span><span class='line'>    <span class="n">unowned</span> <span class="n">let</span> <span class="nl">country</span><span class="p">:</span> <span class="n">Country</span>
</span><span class='line'>    <span class="n">init</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span> <span class="nl">country</span><span class="p">:</span> <span class="n">Country</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">country</span> <span class="o">=</span> <span class="n">country</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在上面的例子中，一个Country都必须有个capitalCity，每个City都必须有个country。</p>

<p>City的初始化函数在Country的初始化函数里调用，它需要一个Country实例，但是根据两步初始化的要求，Country在它的初始化函数里在实力初始化完毕之前无法使用self。所以capitalCity是一个自动解包的optional，它的初始值为nil，也就是说在设置capitalCity时，Country对象已经初始化完毕。这样就可以用来创建City对象。</p>

<p>所有这些都意味着我们可以再一个语句里创建Country和City对象，也不会造成引用循环，而且capitalCity可以直接被访问，不需要加 ！ 来解包。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">var</span> <span class="n">country</span> <span class="o">=</span> <span class="n">Country</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="s">&quot;Canada&quot;</span><span class="p">,</span> <span class="nl">capitalName</span><span class="p">:</span> <span class="s">&quot;Ottawa&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">println</span><span class="p">(</span><span class="s">&quot;\(country.name)&#39;s capital city is called \(country.capitalCity.name)&quot;</span><span class="p">)</span>
</span><span class='line'><span class="c1">// prints &quot;Canada&#39;s capital city is called Ottawa&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<h3>闭包的强引用循环</h3>

<p>我们说明了如何让两个实例互相引用对方来造成引用循环，也说明了如何使用弱引用和非持有引用来打破引用循环。</p>

<p>当我们把一个闭包附值给一个实例的属性时，如果这个闭包捕获了这个实例，那么这也是一种强引用循环。这种捕获可能是闭包里访问了实例的属性（self.someProperty)或是调用了方法(self.someMethod)。不管哪一种，闭包都捕获了self，导致了引用循环。</p>

<p>这种引用循环的发生是因为闭包和类一样，也是引用类型。当我们把闭包附值给属性时，我们是把闭包的引用附值了。这样，其实就是两个强引用互相引用了对方。然而，不是两个实例，而是一个实例和一个闭包。</p>

<p>Swift通过一种叫做闭包捕获列表的方式来解决这个问题。我们先来看如何造成这样的引用循环。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">class</span> <span class="n">HTMLElement</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">let</span> <span class="nl">name</span><span class="p">:</span> <span class="n">String</span>
</span><span class='line'>    <span class="n">let</span> <span class="nl">text</span><span class="p">:</span> <span class="n">String</span><span class="o">?</span>
</span><span class='line'>    <span class="n">lazy</span> <span class="n">var</span> <span class="nl">asHTML</span><span class="p">:</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="n">String</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="n">let</span> <span class="n">text</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="n">text</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="s">&quot;&lt;\(self.name)&gt;\(text)&lt;/\(self.name)&gt;&quot;</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="s">&quot;&lt;\(self.name) /&gt;&quot;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">init</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span> <span class="nl">text</span><span class="p">:</span> <span class="n">String</span><span class="o">?</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">text</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">deinit</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">println</span><span class="p">(</span><span class="s">&quot;\(name) is being deinitialized&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>HTMLElement定义了两个属性name和text来表示HTML元素。它还定义了一个延迟属性，asHTML，它的类型是 ()->String。</p>

<p>这个asHTML属性看起来是个方法，但是它使属性，我们可以改变它的实现来自定义实现。</p>

<pre><code>注意
asHTML是延迟的（lazy）。因为我们只是在需要的时候才会调用访问这个属性。因为是延迟的，我们可以在闭包里使用self，因为延迟属性只会在初始化结束后被访问，而这时候，self是已经存在的。
</code></pre>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">var</span> <span class="nl">paragraph</span><span class="p">:</span> <span class="n">HTMLElement</span><span class="o">?</span> <span class="o">=</span> <span class="n">HTMLElement</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="s">&quot;p&quot;</span><span class="p">,</span> <span class="nl">text</span><span class="p">:</span> <span class="s">&quot;hello, world&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">println</span><span class="p">(</span><span class="n">paragraph</span><span class="o">!</span><span class="p">.</span><span class="n">asHTML</span><span class="p">())</span>
</span><span class='line'><span class="c1">// prints &quot;&lt;p&gt;hello, world&lt;/p&gt;&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们创建一个实例，访问asHTML属性。</p>

<p>可是，我们上面所写的，会造成强引用循环。</p>

<pre><code>注意
虽然我们在闭包里多次引用self。但是这也只会造成一个强引用。
</code></pre>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">paragraph</span> <span class="o">=</span> <span class="nb">nil</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们把paragraph设置为nil，但是HTMLElement的反初始化函数并没有调用，也证明了存在强引用循环。</p>

<h3>解决闭包的强引用循环</h3>

<p>我们通过在闭包定义时给出捕获列表来解决闭包的强引用循环。捕获列表定义了当闭包捕获一个或多个引用时的规则。就好像两个实例强引用一样，我们把捕获列表里的引用表示为弱引用或非持有引用。弱引用还是非持有引用取决其他部分代码之间的关系。</p>

<pre><code>注意
Swift要求我们在闭包中访问属性或调用方法时都必须加self。这样提醒我们，闭包会捕获self。
</code></pre>

<h4>定义捕获列表</h4>

<p>在捕获列表里的每一个元素都是一对由weak或unowned和一个类实例（self或someInstane）。这些元恶写在方括号里，由逗号隔开。</p>

<p>如果闭包有参数列表和返回值，捕获列表需要写在他们前面：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">lazy</span> <span class="n">var</span> <span class="nl">someClosure</span><span class="p">:</span> <span class="p">(</span><span class="n">Int</span><span class="p">,</span> <span class="n">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">String</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="n">unowned</span> <span class="nb">self</span><span class="p">]</span> <span class="p">(</span><span class="nl">index</span><span class="p">:</span> <span class="n">Int</span><span class="p">,</span> <span class="nl">stringToProcess</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">String</span> <span class="k">in</span>
</span><span class='line'>    <span class="c1">// closure body goes here</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果没有参数列表或返回值，捕获列表可以写在闭包的一开始，跟着 in ：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">lazy</span> <span class="n">var</span> <span class="nl">someClosure</span><span class="p">:</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="n">String</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="n">unowned</span> <span class="nb">self</span><span class="p">]</span> <span class="k">in</span>
</span><span class='line'>    <span class="c1">// closure body goes here</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>弱引用和非持有引用</h4>

<p>如果闭包和捕获的实例会一直互相引用的话，在捕获列表用 unowned，这样他们会同时被销毁。</p>

<p>如果捕获的实例有可能为nil，那么就是用 weak。 弱引用永远都是optional的，也会自动设置为nil。这样你需要在闭包里检查他们是否还存在。</p>

<pre><code>注意
如果捕获的引用永远不会是nil，那么应该用 unowned。
</code></pre>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">class</span> <span class="n">HTMLElement</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">let</span> <span class="nl">name</span><span class="p">:</span> <span class="n">String</span>
</span><span class='line'>    <span class="n">let</span> <span class="nl">text</span><span class="p">:</span> <span class="n">String</span><span class="o">?</span>
</span><span class='line'>    <span class="n">lazy</span> <span class="n">var</span> <span class="nl">asHTML</span><span class="p">:</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="n">String</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>        <span class="p">[</span><span class="n">unowned</span> <span class="nb">self</span><span class="p">]</span> <span class="k">in</span>
</span><span class='line'>        <span class="k">if</span> <span class="n">let</span> <span class="n">text</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="n">text</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="s">&quot;&lt;\(self.name)&gt;\(text)&lt;/\(self.name)&gt;&quot;</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="s">&quot;&lt;\(self.name) /&gt;&quot;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">init</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span> <span class="nl">text</span><span class="p">:</span> <span class="n">String</span><span class="o">?</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">text</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">deinit</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">println</span><span class="p">(</span><span class="s">&quot;\(name) is being deinitialized&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">var</span> <span class="nl">paragraph</span><span class="p">:</span> <span class="n">HTMLElement</span><span class="o">?</span> <span class="o">=</span> <span class="n">HTMLElement</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="s">&quot;p&quot;</span><span class="p">,</span> <span class="nl">text</span><span class="p">:</span> <span class="s">&quot;hello, world&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">println</span><span class="p">(</span><span class="n">paragraph</span><span class="o">!</span><span class="p">.</span><span class="n">asHTML</span><span class="p">())</span>
</span><span class='line'><span class="c1">// prints &quot;&lt;p&gt;hello, world&lt;/p&gt;&quot;</span>
</span><span class='line'><span class="n">paragraph</span> <span class="o">=</span> <span class="nb">nil</span>
</span><span class='line'><span class="c1">// prints &quot;p is being deinitialized&quot;</span>
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Language Guide: Deinitialization]]></title>
    <link href="http://zxhfirefox.github.io/blog/2014/10/19/language-guide-u-deinit/"/>
    <updated>2014-10-19T00:40:13+08:00</updated>
    <id>http://zxhfirefox.github.io/blog/2014/10/19/language-guide-u-deinit</id>
    <content type="html"><![CDATA[<p>一个反初始化函数在类实例被销毁之前调用。我们用 deinit关键字来写反初始化函数。反初始化函数只有类类型有。</p>

<h5>反初始化函数原理</h5>

<p>Swift自动把不在使用的实例销毁，并释放资源。Swift使用ARC来做内存管理。一般来讲，我们不需要手动的释放资源。不过，如果我们自己处理了一些资源，我们可能就需要自己做一些清理工作。</p>

<p>每个类，最多只有一个 deinit 方法。 没有任何参数。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">deinit</span> <span class="p">{</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<!--more-->


<p>反初始化函数自动在对象销毁前调用。你不能自己手动调用，父类的反初始化函数会被继承，而且在子类的实现末尾自动调用。即使子类不提供反初始化函数，父类的也会的调用。</p>

<p>因为在销毁之前调用反初始化函数，所以在反初始化函数里，所偶的属性都还可以访问。</p>

<h5>反初始化函数实战</h5>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">struct</span> <span class="n">Bank</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">static</span> <span class="n">var</span> <span class="n">coinsInBank</span> <span class="o">=</span> <span class="mi">10</span><span class="n">_000</span>
</span><span class='line'>    <span class="k">static</span> <span class="n">func</span> <span class="n">vendCoins</span><span class="p">(</span><span class="n">var</span> <span class="nl">numberOfCoinsToVend</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Int</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">numberOfCoinsToVend</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">numberOfCoinsToVend</span><span class="p">,</span> <span class="n">coinsInBank</span><span class="p">)</span>
</span><span class='line'>        <span class="n">coinsInBank</span> <span class="o">-=</span> <span class="n">numberOfCoinsToVend</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">numberOfCoinsToVend</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">static</span> <span class="n">func</span> <span class="n">receiveCoins</span><span class="p">(</span><span class="nl">coins</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">coinsInBank</span> <span class="o">+=</span> <span class="n">coins</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">class</span> <span class="n">Player</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">var</span> <span class="nl">coinsInPurse</span><span class="p">:</span> <span class="n">Int</span>
</span><span class='line'>    <span class="n">init</span><span class="p">(</span><span class="nl">coins</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">coinsInPurse</span> <span class="o">=</span> <span class="n">Bank</span><span class="p">.</span><span class="n">vendCoins</span><span class="p">(</span><span class="n">coins</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">func</span> <span class="n">winCoins</span><span class="p">(</span><span class="nl">coins</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">coinsInPurse</span> <span class="o">+=</span> <span class="n">Bank</span><span class="p">.</span><span class="n">vendCoins</span><span class="p">(</span><span class="n">coins</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">deinit</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">Bank</span><span class="p">.</span><span class="n">receiveCoins</span><span class="p">(</span><span class="n">coinsInPurse</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">var</span> <span class="nl">playerOne</span><span class="p">:</span> <span class="n">Player</span><span class="o">?</span> <span class="o">=</span> <span class="n">Player</span><span class="p">(</span><span class="nl">coins</span><span class="p">:</span> <span class="mi">100</span><span class="p">)</span>
</span><span class='line'><span class="n">println</span><span class="p">(</span><span class="s">&quot;A new player has joined the game with \(playerOne!.coinsInPurse) coins&quot;</span><span class="p">)</span>
</span><span class='line'><span class="c1">// prints &quot;A new player has joined the game with 100 coins&quot;</span>
</span><span class='line'><span class="n">println</span><span class="p">(</span><span class="s">&quot;There are now \(Bank.coinsInBank) coins left in the bank&quot;</span><span class="p">)</span>
</span><span class='line'><span class="c1">// prints &quot;There are now 9900 coins left in the bank&quot;</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">playerOne</span><span class="o">!</span><span class="p">.</span><span class="n">winCoins</span><span class="p">(</span><span class="mi">2</span><span class="n">_000</span><span class="p">)</span>
</span><span class='line'><span class="n">println</span><span class="p">(</span><span class="s">&quot;PlayerOne won 2000 coins &amp; now has \(playerOne!.coinsInPurse) coins&quot;</span><span class="p">)</span>
</span><span class='line'><span class="c1">// prints &quot;PlayerOne won 2000 coins &amp; now has 2100 coins&quot;</span>
</span><span class='line'><span class="n">println</span><span class="p">(</span><span class="s">&quot;The bank now only has \(Bank.coinsInBank) coins left&quot;</span><span class="p">)</span>
</span><span class='line'><span class="c1">// prints &quot;The bank now only has 7900 coins left&quot;</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">playerOne</span> <span class="o">=</span> <span class="nb">nil</span>
</span><span class='line'><span class="n">println</span><span class="p">(</span><span class="s">&quot;PlayerOne has left the game&quot;</span><span class="p">)</span>
</span><span class='line'><span class="c1">// prints &quot;PlayerOne has left the game&quot;</span>
</span><span class='line'><span class="n">println</span><span class="p">(</span><span class="s">&quot;The bank now has \(Bank.coinsInBank) coins&quot;</span><span class="p">)</span>
</span><span class='line'><span class="c1">// prints &quot;The bank now has 10000 coins&quot;</span>
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Language Guide: Initialization]]></title>
    <link href="http://zxhfirefox.github.io/blog/2014/10/19/language-guide-t-init/"/>
    <updated>2014-10-19T00:39:16+08:00</updated>
    <id>http://zxhfirefox.github.io/blog/2014/10/19/language-guide-t-init</id>
    <content type="html"><![CDATA[<p>初始化是让一个类，结构体，枚举的实例变的可用的过程。这个过程包含了把实例上的每一个存储属性都给与一个初始值，还有任何的确保在实例可以被使用前需要做的工作。</p>

<p>我们使用初始化函数来做初始化，初始化函数是一种特殊的函数，在实例被创建时，它会被调用。和ObjC的初始化函数不同，Swift的初始化函数不返回值。他们的主要目的就是确保这个新的实例在被使用之前正确的初始化。</p>

<p>类类型的实例也可以实现反初始化函数，它在实例被销毁时可以用来做任何的清理工作。</p>

<!--more-->


<h5>为存储属性设置初始值</h5>

<p>类和结构体必须在实例被使用前为所有的存储属性设置初始值。存储属性不能处于未决定的状态。</p>

<p>我们可以在初始化函数给存储属性初始值，也可以在定义属性时给出初始值。</p>

<pre><code>注意
在初始化函数里给属性附值和定义属性时给出初始值，都不会触发属性观察者
</code></pre>

<h6>初始化函数</h6>

<p>初始化函数在创建一个类型的实例后被调用，一个最简单的初始化函数就像一个实例方法，没有参数，函数名是 init 关键字。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">init</span><span class="p">(){</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>例如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">struct</span> <span class="n">Fahrenheit</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">var</span> <span class="nl">temperature</span><span class="p">:</span> <span class="n">Double</span>
</span><span class='line'>    <span class="n">init</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">temperature</span> <span class="o">=</span> <span class="mf">32.0</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">var</span> <span class="n">f</span> <span class="o">=</span> <span class="n">Fahrenheit</span><span class="p">()</span>
</span><span class='line'><span class="n">println</span><span class="p">(</span><span class="s">&quot;The default temperature is \(f.temperature)° Fahrenheit&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h6>默认属性值</h6>

<p>我们可以像上面的例子里那样在初始化函数里设置属性初始值。也可以在属性定义时给出初始值。</p>

<pre><code>注意
如果一个属性总是有着同样的初始值，我们应该在属性定义时给出初始值，而不是在初始化函数里给出。
</code></pre>

<p>我们把上面的例子可以改写为：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">struct</span> <span class="n">Fahrenheit</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">var</span> <span class="n">temperature</span> <span class="o">=</span> <span class="mf">32.0</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h5>自定义初始化</h5>

<p>我们可以通过给出输入参数，或optional的属性类型，或是在初始化时改变常量属性来自定义初始化过程。</p>

<h6>初始化参数</h6>

<p>我们可以给初始化函数定义参数，初始化参数的能力和函数，方法的一样。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">struct</span> <span class="n">Celsius</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">var</span> <span class="nl">temperatureInCelsius</span><span class="p">:</span> <span class="n">Double</span>
</span><span class='line'>    <span class="n">init</span><span class="p">(</span><span class="n">fromFahrenheit</span> <span class="nl">fahrenheit</span><span class="p">:</span> <span class="n">Double</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">temperatureInCelsius</span> <span class="o">=</span> <span class="p">(</span><span class="n">fahrenheit</span> <span class="o">-</span> <span class="mf">32.0</span><span class="p">)</span> <span class="o">/</span> <span class="mf">1.8</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">init</span><span class="p">(</span><span class="n">fromKelvin</span> <span class="nl">kelvin</span><span class="p">:</span> <span class="n">Double</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">temperatureInCelsius</span> <span class="o">=</span> <span class="n">kelvin</span> <span class="o">-</span> <span class="mf">273.15</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">let</span> <span class="n">boilingPointOfWater</span> <span class="o">=</span> <span class="n">Celsius</span><span class="p">(</span><span class="nl">fromFahrenheit</span><span class="p">:</span> <span class="mf">212.0</span><span class="p">)</span>
</span><span class='line'><span class="c1">// boilingPointOfWater.temperatureInCelsius is 100.0</span>
</span><span class='line'><span class="n">let</span> <span class="n">freezingPointOfWater</span> <span class="o">=</span> <span class="n">Celsius</span><span class="p">(</span><span class="nl">fromKelvin</span><span class="p">:</span> <span class="mf">273.15</span><span class="p">)</span>
</span><span class='line'><span class="c1">// freezingPointOfWater.temperatureInCelsius is 0.0</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的例子里，两个初始化函数接受不同的温度值，分别转换到Celsius温度。</p>

<h6>本地和外部参数名</h6>

<p>和函数，方法一样，初始化参数也可以本地参数名和外部参数名。</p>

<p>然而，初始化函数并不像函数和方法一样，有一个函数名。因此，参数的名字和类型将决定哪一个初始化函数被调用。因此，如果我们不给出外部参数名子，Swift会默认给每一个参数一个外部名字。这个外部名字和本地名字一样，就好像你给每个参数都写 # 一样。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">struct</span> <span class="n">Color</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">red</span><span class="p">,</span> <span class="n">green</span><span class="p">,</span> <span class="nl">blue</span><span class="p">:</span> <span class="n">Double</span>
</span><span class='line'>    <span class="n">init</span><span class="p">(</span><span class="nl">red</span><span class="p">:</span> <span class="n">Double</span><span class="p">,</span> <span class="nl">green</span><span class="p">:</span> <span class="n">Double</span><span class="p">,</span> <span class="nl">blue</span><span class="p">:</span> <span class="n">Double</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">red</span>   <span class="o">=</span> <span class="n">red</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">green</span> <span class="o">=</span> <span class="n">green</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">blue</span>  <span class="o">=</span> <span class="n">blue</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">init</span><span class="p">(</span><span class="nl">white</span><span class="p">:</span> <span class="n">Double</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">red</span>   <span class="o">=</span> <span class="n">white</span>
</span><span class='line'>        <span class="n">green</span> <span class="o">=</span> <span class="n">white</span>
</span><span class='line'>        <span class="n">blue</span>  <span class="o">=</span> <span class="n">white</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">let</span> <span class="n">magenta</span> <span class="o">=</span> <span class="n">Color</span><span class="p">(</span><span class="nl">red</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="nl">green</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span> <span class="nl">blue</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">)</span>
</span><span class='line'><span class="n">let</span> <span class="n">halfGray</span> <span class="o">=</span> <span class="n">Color</span><span class="p">(</span><span class="nl">white</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意，我们无法不给外部参数名字来调用初始化函数，即使我们可以通过参数个数来确定使用哪个初始化函数。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">let</span> <span class="n">veryGreen</span> <span class="o">=</span> <span class="n">Color</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
</span><span class='line'><span class="c1">// this reports a compile-time error - external names are required</span>
</span></code></pre></td></tr></table></div></figure>


<h6>没有外部名字的初始化参数</h6>

<p>如果你真的不像给出初始化参数的外部名字， 使用 _ 来作为外部参数名字给出。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">struct</span> <span class="n">Celsius</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">var</span> <span class="nl">temperatureInCelsius</span><span class="p">:</span> <span class="n">Double</span>
</span><span class='line'>    <span class="n">init</span><span class="p">(</span><span class="n">fromFahrenheit</span> <span class="nl">fahrenheit</span><span class="p">:</span> <span class="n">Double</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">temperatureInCelsius</span> <span class="o">=</span> <span class="p">(</span><span class="n">fahrenheit</span> <span class="o">-</span> <span class="mf">32.0</span><span class="p">)</span> <span class="o">/</span> <span class="mf">1.8</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">init</span><span class="p">(</span><span class="n">fromKelvin</span> <span class="nl">kelvin</span><span class="p">:</span> <span class="n">Double</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">temperatureInCelsius</span> <span class="o">=</span> <span class="n">kelvin</span> <span class="o">-</span> <span class="mf">273.15</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">init</span><span class="p">(</span><span class="n">_</span> <span class="nl">celsius</span><span class="p">:</span> <span class="n">Double</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">temperatureInCelsius</span> <span class="o">=</span> <span class="n">celsius</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">let</span> <span class="n">bodyTemperature</span> <span class="o">=</span> <span class="n">Celsius</span><span class="p">(</span><span class="mf">37.0</span><span class="p">)</span>
</span><span class='line'><span class="c1">// bodyTemperature.temperatureInCelsius is 37.0</span>
</span></code></pre></td></tr></table></div></figure>


<p>因为外部参数名字是 _ ，所以可以直接调用，而不给出参数名字。</p>

<h6>optional的属性类型</h6>

<p>如果我们自定义的类型有一个存储属性在逻辑上可能没有值，或许因为它的值在初始化时还不能确定，或许因为它在某些时刻允许没有值，我们把它声明为optional的属性。optional的属性默认被初始化为 nil，表明这个属性在初始化时没有值。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">class</span> <span class="n">SurveyQuestion</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">var</span> <span class="nl">text</span><span class="p">:</span> <span class="n">String</span>
</span><span class='line'>    <span class="n">var</span> <span class="nl">response</span><span class="p">:</span> <span class="n">String</span><span class="o">?</span>
</span><span class='line'>    <span class="n">init</span><span class="p">(</span><span class="nl">text</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">text</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">func</span> <span class="n">ask</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">println</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">let</span> <span class="n">cheeseQuestion</span> <span class="o">=</span> <span class="n">SurveyQuestion</span><span class="p">(</span><span class="nl">text</span><span class="p">:</span> <span class="s">&quot;Do you like cheese?&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">cheeseQuestion</span><span class="p">.</span><span class="n">ask</span><span class="p">()</span>
</span><span class='line'><span class="c1">// prints &quot;Do you like cheese?&quot;</span>
</span><span class='line'><span class="n">cheeseQuestion</span><span class="p">.</span><span class="n">response</span> <span class="o">=</span> <span class="s">&quot;Yes, I do like cheese.&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的例子里，response是一个optional的字符串。</p>

<h6>在初始化阶段修改常量属性的值</h6>

<p>我们可以再初始化阶段修改一个常量属性的值，只要在初始化结束之前给它一个值。</p>

<pre><code>注意
对于类实例，一个常量属性只能在定义属性的类的初始化过程里被修改，而不能在子类里被修改。
</code></pre>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">class</span> <span class="n">SurveyQuestion</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">let</span> <span class="nl">text</span><span class="p">:</span> <span class="n">String</span>
</span><span class='line'>    <span class="n">var</span> <span class="nl">response</span><span class="p">:</span> <span class="n">String</span><span class="o">?</span>
</span><span class='line'>    <span class="n">init</span><span class="p">(</span><span class="nl">text</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">text</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">func</span> <span class="n">ask</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">println</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">let</span> <span class="n">beetsQuestion</span> <span class="o">=</span> <span class="n">SurveyQuestion</span><span class="p">(</span><span class="nl">text</span><span class="p">:</span> <span class="s">&quot;How about beets?&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">beetsQuestion</span><span class="p">.</span><span class="n">ask</span><span class="p">()</span>
</span><span class='line'><span class="c1">// prints &quot;How about beets?&quot;</span>
</span><span class='line'><span class="n">beetsQuestion</span><span class="p">.</span><span class="n">response</span> <span class="o">=</span> <span class="s">&quot;I also like beets. (But not with cheese.)&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们text属性改为常量，来表示问题并会改变。虽然他是常量，但是初始化过程中还是可以被改变。</p>

<h5>默认初始化函数</h5>

<p>对于任意的结构体或基类，当他们的所有属性都一个默认值，并且没有给出任何初始化函数的时候，Swift给出一个默认初始化函数。这个初始化函数就是简单的把所有的默认值附值给属性。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">class</span> <span class="n">ShoppingListItem</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">var</span> <span class="nl">name</span><span class="p">:</span> <span class="n">String</span><span class="o">?</span>
</span><span class='line'>    <span class="n">var</span> <span class="n">quantity</span> <span class="o">=</span> <span class="mi">1</span>
</span><span class='line'>    <span class="n">var</span> <span class="n">purchased</span> <span class="o">=</span> <span class="nb">false</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">var</span> <span class="n">item</span> <span class="o">=</span> <span class="n">ShoppingListItem</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p>因为ShoppingListItem的所有属性都有默认值，而且他还没有基类，也没给出自己的初始化函数，Swift会为它提供一个默认的初始化函数。</p>

<h6>结构体类型的按成员的初始化函数</h6>

<p>结构体对象如果没有给出自己的初始化函数，将得到一个默认的按成员初始化的初始化函数。即使有些属性并没有给出默认值。</p>

<p>按成员初始化的初始化函数是一种初始化结构体的一种简写，初始值根据名字传递给初始化函数。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">struct</span> <span class="n">Size</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">var</span> <span class="n">width</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">height</span> <span class="o">=</span> <span class="mf">0.0</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">let</span> <span class="n">twoByTwo</span> <span class="o">=</span> <span class="n">Size</span><span class="p">(</span><span class="nl">width</span><span class="p">:</span> <span class="mf">2.0</span><span class="p">,</span> <span class="nl">height</span><span class="p">:</span> <span class="mf">2.0</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h5>值类型的初始化代理</h5>

<p>初始化函数可以调用其他初始化函数来执行初始化过程，这种方式叫做初始化代理，可以避免重复代码。</p>

<p>初始化代理如果工作，那种形式的代理是可以的，在值类型和类类型是不一样的。值类型，不支持继承，所以他们的初始化代理比较简单，因为他们只能把初始化代理给其他的由他们自己提供的初始化函数。然而，类，可以从其他类继承。这就意味着类有着额外的责任来确保他们继承的属性也被初始化。</p>

<p>对于值类型，self.init 来引用其他的初始化函数， self.init只能在一个初始化函数里被调用。</p>

<p>如果我们给值类型定义了自定义的初始化函数，那么我们就无法再访问默认的初始化函数。这个限制是为了防止我们有额外的初始化步骤，而有时候不小心使用了默认的初始化函数来初始化了实例。</p>

<pre><code>注意
如果我们希望使用默认的初始化函数，还想定义自定义的初始化函数，我们可以把自定义的初始化函数写在扩展里。
</code></pre>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">struct</span> <span class="n">Size</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">var</span> <span class="n">width</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">height</span> <span class="o">=</span> <span class="mf">0.0</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">struct</span> <span class="n">Point</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">var</span> <span class="n">x</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mf">0.0</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">struct</span> <span class="n">Rect</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">var</span> <span class="n">origin</span> <span class="o">=</span> <span class="n">Point</span><span class="p">()</span>
</span><span class='line'>    <span class="n">var</span> <span class="n">size</span> <span class="o">=</span> <span class="n">Size</span><span class="p">()</span>
</span><span class='line'>    <span class="n">init</span><span class="p">()</span> <span class="p">{}</span>
</span><span class='line'>    <span class="n">init</span><span class="p">(</span><span class="nl">origin</span><span class="p">:</span> <span class="n">Point</span><span class="p">,</span> <span class="nl">size</span><span class="p">:</span> <span class="n">Size</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">origin</span> <span class="o">=</span> <span class="n">origin</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">init</span><span class="p">(</span><span class="nl">center</span><span class="p">:</span> <span class="n">Point</span><span class="p">,</span> <span class="nl">size</span><span class="p">:</span> <span class="n">Size</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">let</span> <span class="n">originX</span> <span class="o">=</span> <span class="n">center</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="p">(</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
</span><span class='line'>        <span class="n">let</span> <span class="n">originY</span> <span class="o">=</span> <span class="n">center</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="p">(</span><span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">init</span><span class="p">(</span><span class="nl">origin</span><span class="p">:</span> <span class="n">Point</span><span class="p">(</span><span class="nl">x</span><span class="p">:</span> <span class="n">originX</span><span class="p">,</span> <span class="nl">y</span><span class="p">:</span> <span class="n">originY</span><span class="p">),</span> <span class="nl">size</span><span class="p">:</span> <span class="n">size</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>第一个init，就相当于默认初始化函数。
第二个init，相当于按成员来初始化的初始化函数。
第三个init，是我们自己的，相对复杂的初始化函数。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">let</span> <span class="n">basicRect</span> <span class="o">=</span> <span class="n">Rect</span><span class="p">()</span>
</span><span class='line'><span class="c1">// basicRect&#39;s origin is (0.0, 0.0) and its size is (0.0, 0.0)</span>
</span><span class='line'><span class="n">let</span> <span class="n">originRect</span> <span class="o">=</span> <span class="n">Rect</span><span class="p">(</span><span class="nl">origin</span><span class="p">:</span> <span class="n">Point</span><span class="p">(</span><span class="nl">x</span><span class="p">:</span> <span class="mf">2.0</span><span class="p">,</span> <span class="nl">y</span><span class="p">:</span> <span class="mf">2.0</span><span class="p">),</span>
</span><span class='line'>    <span class="nl">size</span><span class="p">:</span> <span class="n">Size</span><span class="p">(</span><span class="nl">width</span><span class="p">:</span> <span class="mf">5.0</span><span class="p">,</span> <span class="nl">height</span><span class="p">:</span> <span class="mf">5.0</span><span class="p">))</span>
</span><span class='line'><span class="c1">// originRect&#39;s origin is (2.0, 2.0) and its size is (5.0, 5.0)</span>
</span><span class='line'><span class="n">let</span> <span class="n">centerRect</span> <span class="o">=</span> <span class="n">Rect</span><span class="p">(</span><span class="nl">center</span><span class="p">:</span> <span class="n">Point</span><span class="p">(</span><span class="nl">x</span><span class="p">:</span> <span class="mf">4.0</span><span class="p">,</span> <span class="nl">y</span><span class="p">:</span> <span class="mf">4.0</span><span class="p">),</span>
</span><span class='line'>    <span class="nl">size</span><span class="p">:</span> <span class="n">Size</span><span class="p">(</span><span class="nl">width</span><span class="p">:</span> <span class="mf">3.0</span><span class="p">,</span> <span class="nl">height</span><span class="p">:</span> <span class="mf">3.0</span><span class="p">))</span>
</span><span class='line'><span class="c1">// centerRect&#39;s origin is (2.5, 2.5) and its size is (3.0, 3.0)</span>
</span></code></pre></td></tr></table></div></figure>


<h5>类继承和初始化</h5>

<p>一个类的所有的存储属性，包括任何继承的属性，都必须在初始化过程中被初始化。</p>

<p>Swift定义了两种初始化函数来简化并确保所有的属性都被初始化，叫做指定初始化函数和便利初始化函数。</p>

<h6>指定初始化函数和便利初始化函数</h6>

<p>指定初始化函数是一个类的基本初始化函数。一个指定初始化函数初始化一个类所有属性，并且调用父类的初始化函数来完成初始化过程。</p>

<p>类应该只有很少的指定初始化函数，很多情况下只有一个。指定初始化函数是初始化过程的&#8221;漏斗&#8221;位置，经过它来进入父类的初始化链。</p>

<p>每个类至少有一个指定初始化函数。有些时候，这个是从父类继承了一个或多个指定初始化函数。</p>

<p>便利初始化函数是辅助的初始化函数。我们可以定一个便利初始化函数来调用同一个类的指定初始化函数，并给它一些属性的默认值。我们也可以定义便利初始化函数来给一个实例某些特殊的值。</p>

<p>如果我们不需要，我们可以不给出任何的便利初始化函数。当我们需要时，我们定义便利初始化函数来明确和简化我们的代码。</p>

<h6>语法</h6>

<p>指定初始化函数和值类型的普通初始化函数语法一样</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">init</span><span class="p">(</span> <span class="p">[</span><span class="n">parameters</span><span class="p">]){</span>
</span><span class='line'>    <span class="p">[</span><span class="n">statements</span><span class="p">]</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>便利初始化函数写法基本一致，但是需要用 convenience 来标示出来。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">convenience</span> <span class="nf">init</span><span class="p">([</span><span class="n">parameters</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="n">statements</span><span class="p">]</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>注：  []并不是数组。</p>

<h6>类类型的初始化代理</h6>

<p>为了简化指定初始化函数和便利初始化函数之间的关系，Swift使用下面3条规则。</p>

<ol>
<li>一个指定的初始化函数必须调用它的直接父类的一个指定初始化函数。</li>
<li>一个便利的初始化函数必须调用它自己同一个类的另一个初始化函数。</li>
<li>一个便利的初始化函数必须最终调用一个指定的初始化函数。</li>
</ol>


<p>简单来讲就是：</p>

<ul>
<li>指定的初始化函数需要向上代理</li>
<li>便利的初始化函数必须横向代理</li>
</ul>


<p>注： 有两张图片比较清楚对这一概念给出例子。</p>

<h6>两步初始化</h6>

<p>在Swift的类初始化里，有两步，第一步，每一个由定义这个属性类给出的存储属性被初始化。第二步，每一个类都可以进一步的修改这些属性来使得实例可用。</p>

<p>这种方式可以确保初始化安全，并且仍然提供了在类继承里完整的灵活度。两步初始化防止了某些属性在被初始化之前就被使用了，也防止了某个属性被其他的初始化函数修改。</p>

<pre><code>注意
Swift的两步初始化和ObjC的很相似，主要区别在于第一步里，ObjC会把0或nil附值给每个属性，而Swift更灵活的可以把自定义的初始值附值给属性。
</code></pre>

<p>Swift编译器会做4种检查来确保两步初始化没有错误。</p>

<ol>
<li>一个指定的初始化函数必须确保在调用父类初始化之前，自己的所有属性都被初始化。</li>
<li>一个指定的初始化函数在给继承的属性附值之前，必须调用父类的初始化函数。</li>
<li>一个便利初始化函数必须在给属性附值之前调用另外的初始化函数，如果不这样，这个属性的值会被覆盖。</li>
<li>一个初始化函数在第一步完成之前，不能调用任何的实例方法，不能读取任何属性，也不能把self作为值来引用。</li>
</ol>


<p>一个实例在第一步结束之前都不算完整初始化，而方法，属性只有在第一步结束后才能访问。</p>

<p>下面就是两步初始化如何进行的：</p>

<p>第一步：</p>

<ul>
<li>一个指定的或便利的初始化函数被调用。</li>
<li>这个实例的内存被分配，但没有初始化。</li>
<li>一个指定的初始化确保所有的由当前类引进的属性被初始化。</li>
<li>这个指定的初始化函数向上代理调用父类的初始化函数，让父类进行初始化。</li>
<li>这一步骤一直进行直到没有父类。</li>
<li>直到继承链的顶端，最后的父类把自己的属性都初始化完毕之后，那么这个实例的内存就被初始化完毕。第一阶段结束。</li>
</ul>


<p>第二步：</p>

<ul>
<li>从继承链顶端往下，每个指定的初始化函数可以自定义属性的值。这时候，初始化函数可以访问 self，也可以修改属性值，调用方法等等。</li>
<li>最终，任何的便利方法可以修改属性的值以及使用self。</li>
</ul>


<h6>初始化函数继承和重写</h6>

<p>和ObjC不同，Swift子类默认不继承他们父类的初始化函数。这样可以避免，如果子类从父类继承了一个简单的初始化函数，而是得子类的实例没有完全初始化。</p>

<pre><code>注意
父类的初始化函数只在特定情况下被继承了，需要确保安全。
</code></pre>

<p>如果你想给一个子类加一个和父类一样的初始化函数，你可以在子类重新给出实现。</p>

<p>如果你在子类写了一个和父类的指定的初始化函数一样的初始化函数，你实际上是重写了那个初始化函数，所以你必须加上 override 。即便你是重写了一个自动提供的默认初始化函数，也要写override。</p>

<p>和重写属性，方法，角标一样，override会使得编译器去检查是否和父类相匹配。</p>

<pre><code>注意
你应该在重写父类的指定的初始化函数时总是写上 override，即使你子类的实现是一个便利的初始化函数。
</code></pre>

<p>相反的，如果你重写的初始化函数和父类的一个便利初始化函数想匹配，那父类的便利初始化函数就永远不能在你的子类里被直接调用。因此，子类其实严格来说并没有重写父类的初始化函数，所以你可以不写 override。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">class</span> <span class="n">Vehicle</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">var</span> <span class="n">numberOfWheels</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'>    <span class="n">var</span> <span class="nl">description</span><span class="p">:</span> <span class="n">String</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="s">&quot;\(numberOfWheels) wheel(s)&quot;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的例子，Vehicle给出了属性的默认值，也没有自定义初始化函数，也么有父类，那么它由一个默认的初始化函数。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">let</span> <span class="n">vehicle</span> <span class="o">=</span> <span class="n">Vehicle</span><span class="p">()</span>
</span><span class='line'><span class="n">println</span><span class="p">(</span><span class="s">&quot;Vehicle: \(vehicle.description)&quot;</span><span class="p">)</span>
</span><span class='line'><span class="c1">// Vehicle: 0 wheel(s)</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们定义一个子类</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">class</span> <span class="nl">Bicycle</span><span class="p">:</span> <span class="n">Vehicle</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">override</span> <span class="n">init</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="nb">super</span><span class="p">.</span><span class="n">init</span><span class="p">()</span>
</span><span class='line'>        <span class="n">numberOfWheels</span> <span class="o">=</span> <span class="mi">2</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Bicycle定义了一个指定的初始化函数，这个初始化函数和父类的一个指定的初始化函数匹配，所以Bicycle的初始化函数被标记为 override。</p>

<p>Bicycle的init，调用了父类的init。然后修改了numberOfWheels的值。</p>

<pre><code>注意
子类可以在初始化时修改继承属性的值，但是只能修改变量属性，而不能修改常量属性。
</code></pre>

<h6>自动的初始化函数继承</h6>

<p>如上所述，子类默认不能从父类继承初始化函数。然而，如果特定情况满足，父类的初始化函数自动被继承。在实际使用中，这意味着你不需要大量的重写父类的初始化函数，而是可以从父类中安全的继承初始化函数。</p>

<p>假设我们在子类里给新加的属性提供默认值，下面两条规则会使用</p>

<ol>
<li>如果子类没有定义任何的制定的初始化函数，它会自动从父类继承所有的指定的初始化函数。</li>
<li>如果子类提供了父类的所有的指定的初始化函数的实现，不管是通过 1 还是自己给出实现，它都会自动继承所有的便利初始化函数。</li>
</ol>


<p>这2条规则，即使子类有自定义的便利初始化函数也一样适用。</p>

<pre><code>注意
一个子类可以把一个父类的指定初始化函数实现为一个子类的一个便利初始化函数来满足规则2.
</code></pre>

<h6>指定初始化函数和便利初始化函数实战</h6>

<p>下面的例子给出指定初始化函数，便利初始化函数，自动继承的初始化函数。</p>

<p>基类：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">class</span> <span class="n">Food</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">var</span> <span class="nl">name</span><span class="p">:</span> <span class="n">String</span>
</span><span class='line'>    <span class="n">init</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">convenience</span> <span class="n">init</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">init</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="s">&quot;[Unnamed]&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Food定义了一个属性name。一个指定的初始化函数，一个便利的初始化函数，没有默认的初始化函数。</p>

<p>子类：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">class</span> <span class="nl">RecipeIngredient</span><span class="p">:</span> <span class="n">Food</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">var</span> <span class="nl">quantity</span><span class="p">:</span> <span class="n">Int</span>
</span><span class='line'>    <span class="n">init</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span> <span class="nl">quantity</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">quantity</span> <span class="o">=</span> <span class="n">quantity</span>
</span><span class='line'>        <span class="nb">super</span><span class="p">.</span><span class="n">init</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="n">name</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">override</span> <span class="n">convenience</span> <span class="n">init</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">init</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="n">name</span><span class="p">,</span> <span class="nl">quantity</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>RecipeIngredient定义了一个自己的指定的初始化函数，接受name和quantity参数。自己先把自己的quantity初始化，然后调用super来初始化父类。</p>

<p>RecipeIngredient它还定义了一个便利的初始化函数，接受name参数，因为这个初始化函数和父类的一个指定初始化函数相匹配，所以需要加上 override关键字。</p>

<p>尽管RecipeIngredient把父类的一个指定初始化函数重写为便利初始化函数，它也是实现了所有父类的指定初始化函数，所以它还继承了父类的所有便利初始化函数。因为RecipeIngredient的父类是Food，只有一个便利初始化函数，如果我们在RecipeIngredient调用这个初始化函数，会代理到RecipeIngredient，而不是Food。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">let</span> <span class="n">oneMysteryItem</span> <span class="o">=</span> <span class="n">RecipeIngredient</span><span class="p">()</span>
</span><span class='line'><span class="n">let</span> <span class="n">oneBacon</span> <span class="o">=</span> <span class="n">RecipeIngredient</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="s">&quot;Bacon&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">let</span> <span class="n">sixEggs</span> <span class="o">=</span> <span class="n">RecipeIngredient</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="s">&quot;Eggs&quot;</span><span class="p">,</span> <span class="nl">quantity</span><span class="p">:</span> <span class="mi">6</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>第三个类：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">class</span> <span class="nl">ShoppingListItem</span><span class="p">:</span> <span class="n">RecipeIngredient</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">var</span> <span class="n">purchased</span> <span class="o">=</span> <span class="nb">false</span>
</span><span class='line'>    <span class="n">var</span> <span class="nl">description</span><span class="p">:</span> <span class="n">String</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">var</span> <span class="n">output</span> <span class="o">=</span> <span class="s">&quot;\(quantity) x \(name)&quot;</span>
</span><span class='line'>        <span class="n">output</span> <span class="o">+=</span> <span class="n">purchased</span> <span class="o">?</span> <span class="s">&quot; ✔&quot;</span> <span class="o">:</span> <span class="s">&quot; ✘&quot;</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">output</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<pre><code>注意
ShoppingListItem没有提供初始化函数来初始化purchased，因为东西从开始都是未购买的。
</code></pre>

<p>因为ShoppingListItem的属性都有默认值而且没有定义任何的初始化函数，那么它继承了所有的指定初始化函数和便利初始化函数。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">var</span> <span class="n">breakfastList</span> <span class="o">=</span> <span class="p">[</span>
</span><span class='line'>    <span class="n">ShoppingListItem</span><span class="p">(),</span>
</span><span class='line'>    <span class="n">ShoppingListItem</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="s">&quot;Bacon&quot;</span><span class="p">),</span>
</span><span class='line'>    <span class="n">ShoppingListItem</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="s">&quot;Eggs&quot;</span><span class="p">,</span> <span class="nl">quantity</span><span class="p">:</span> <span class="mi">6</span><span class="p">),</span>
</span><span class='line'><span class="p">]</span>
</span><span class='line'><span class="n">breakfastList</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;Orange juice&quot;</span>
</span><span class='line'><span class="n">breakfastList</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">purchased</span> <span class="o">=</span> <span class="nb">true</span>
</span><span class='line'><span class="k">for</span> <span class="n">item</span> <span class="k">in</span> <span class="n">breakfastList</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="n">item</span><span class="p">.</span><span class="n">description</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">// 1 x Orange juice ✔</span>
</span><span class='line'><span class="c1">// 1 x Bacon ✘</span>
</span><span class='line'><span class="c1">// 6 x Eggs ✘</span>
</span></code></pre></td></tr></table></div></figure>


<h5>可失败的初始化函数</h5>

<p>有些时候，定义一个可失败的初始化函数是有意义的。这个失败可能是因为参数错误，或是缺少需要的参数，或者其他阻止初始化过程的情况。</p>

<p>我们在init后面加一个 ？ 来标示这个初始化函数可能失败。</p>

<pre><code>注意
你不能定义一个可失败的和不可失败的初始化函数，接受相同的参数类型和名字。
</code></pre>

<p>可失败的初始化函数创建一个optioanl的值。如果我们在可失败的初始化函数里写了 return nil，就意味着初始化失败了。</p>

<pre><code>注意
严格来讲，初始化函数不返回值。相反，他们的目的是确保 self 在初始化结束后是完整并正确可用的。 所以虽然我们使用 return nil 来表示初始化失败，但是不用在成功初始化时使用 return。
</code></pre>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">struct</span> <span class="n">Animal</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">let</span> <span class="nl">species</span><span class="p">:</span> <span class="n">String</span>
</span><span class='line'>    <span class="n">init</span><span class="o">?</span><span class="p">(</span><span class="nl">species</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="n">species</span><span class="p">.</span><span class="n">isEmpty</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">nil</span> <span class="p">}</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">species</span> <span class="o">=</span> <span class="n">species</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">let</span> <span class="n">someCreature</span> <span class="o">=</span> <span class="n">Animal</span><span class="p">(</span><span class="nl">species</span><span class="p">:</span> <span class="s">&quot;Giraffe&quot;</span><span class="p">)</span>
</span><span class='line'><span class="c1">// someCreature is of type Animal?, not Animal</span>
</span><span class='line'><span class="k">if</span> <span class="n">let</span> <span class="n">giraffe</span> <span class="o">=</span> <span class="n">someCreature</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="s">&quot;An animal was initialized with a species of \(giraffe.species)&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">// prints &quot;An animal was initialized with a species of Giraffe&quot;</span>
</span><span class='line'><span class="n">let</span> <span class="n">anonymousCreature</span> <span class="o">=</span> <span class="n">Animal</span><span class="p">(</span><span class="nl">species</span><span class="p">:</span> <span class="s">&quot;&quot;</span><span class="p">)</span>
</span><span class='line'><span class="c1">// anonymousCreature is of type Animal?, not Animal</span>
</span><span class='line'><span class="k">if</span> <span class="n">anonymousCreature</span> <span class="o">==</span> <span class="nb">nil</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="s">&quot;The anonymous creature could not be initialized&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">// prints &quot;The anonymous creature could not be initialized&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<pre><code>注意
检查空字符串和检查 nil 是不一样的。
</code></pre>

<h6>枚举的可失败初始化函数</h6>

<p>我们可以使用可失败的初始化函数根据参数来从枚举成员里选择适当值。如果没有合适的值，我们就失败了。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">enum</span> <span class="n">TemperatureUnit</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">Kelvin</span><span class="p">,</span> <span class="n">Celsius</span><span class="p">,</span> <span class="n">Fahrenheit</span>
</span><span class='line'>    <span class="n">init</span><span class="o">?</span><span class="p">(</span><span class="nl">symbol</span><span class="p">:</span> <span class="n">Character</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">switch</span> <span class="n">symbol</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">case</span> <span class="s">&quot;K&quot;</span><span class="o">:</span>
</span><span class='line'>            <span class="nb">self</span> <span class="o">=</span> <span class="p">.</span><span class="n">Kelvin</span>
</span><span class='line'>        <span class="k">case</span> <span class="s">&quot;C&quot;</span><span class="o">:</span>
</span><span class='line'>            <span class="nb">self</span> <span class="o">=</span> <span class="p">.</span><span class="n">Celsius</span>
</span><span class='line'>        <span class="k">case</span> <span class="s">&quot;F&quot;</span><span class="o">:</span>
</span><span class='line'>            <span class="nb">self</span> <span class="o">=</span> <span class="p">.</span><span class="n">Fahrenheit</span>
</span><span class='line'>        <span class="k">default</span><span class="o">:</span>
</span><span class='line'>            <span class="k">return</span> <span class="nb">nil</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">let</span> <span class="n">fahrenheitUnit</span> <span class="o">=</span> <span class="n">TemperatureUnit</span><span class="p">(</span><span class="nl">symbol</span><span class="p">:</span> <span class="s">&quot;F&quot;</span><span class="p">)</span>
</span><span class='line'><span class="k">if</span> <span class="n">fahrenheitUnit</span> <span class="o">!=</span> <span class="nb">nil</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="s">&quot;This is a defined temperature unit, so initialization succeeded.&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">// prints &quot;This is a defined temperature unit, so initialization succeeded.&quot;</span>
</span><span class='line'><span class="n">let</span> <span class="n">unknownUnit</span> <span class="o">=</span> <span class="n">TemperatureUnit</span><span class="p">(</span><span class="nl">symbol</span><span class="p">:</span> <span class="s">&quot;X&quot;</span><span class="p">)</span>
</span><span class='line'><span class="k">if</span> <span class="n">unknownUnit</span> <span class="o">==</span> <span class="nb">nil</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="s">&quot;This is not a defined temperature unit, so initialization failed.&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">// prints &quot;This is not a defined temperature unit, so initialization failed.&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<h6>有原始值的枚举的可失败初始化函数</h6>

<p>有原始值的枚举自动的有一个可失败的初始化函数，init?(rawValue:)。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">enum</span> <span class="nl">TemperatureUnit</span><span class="p">:</span> <span class="n">Character</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">Kelvin</span> <span class="o">=</span> <span class="s">&quot;K&quot;</span><span class="p">,</span> <span class="n">Celsius</span> <span class="o">=</span> <span class="s">&quot;C&quot;</span><span class="p">,</span> <span class="n">Fahrenheit</span> <span class="o">=</span> <span class="s">&quot;F&quot;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">let</span> <span class="n">fahrenheitUnit</span> <span class="o">=</span> <span class="n">TemperatureUnit</span><span class="p">(</span><span class="nl">rawValue</span><span class="p">:</span> <span class="s">&quot;F&quot;</span><span class="p">)</span>
</span><span class='line'><span class="k">if</span> <span class="n">fahrenheitUnit</span> <span class="o">!=</span> <span class="nb">nil</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="s">&quot;This is a defined temperature unit, so initialization succeeded.&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">// prints &quot;This is a defined temperature unit, so initialization succeeded.&quot;</span>
</span><span class='line'><span class="n">let</span> <span class="n">unknownUnit</span> <span class="o">=</span> <span class="n">TemperatureUnit</span><span class="p">(</span><span class="nl">rawValue</span><span class="p">:</span> <span class="s">&quot;X&quot;</span><span class="p">)</span>
</span><span class='line'><span class="k">if</span> <span class="n">unknownUnit</span> <span class="o">==</span> <span class="nb">nil</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="s">&quot;This is not a defined temperature unit, so initialization failed.&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">// prints &quot;This is not a defined temperature unit, so initialization failed.&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<h6>类的可失败初始化函数</h6>

<p>一个值类型的可失败的初始化函数可以在初始化的任何阶段失败。</p>

<p>然而对于类，一个可失败的初始化函数，只能在所有的由当前类引进的存储属性都被初始化之后，并且任何的初始化代理开始后才能触发失败。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">class</span> <span class="n">Product</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">let</span> <span class="nl">name</span><span class="p">:</span> <span class="n">String</span><span class="o">!</span>
</span><span class='line'>    <span class="n">init</span><span class="o">?</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="n">name</span><span class="p">.</span><span class="n">isEmpty</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">nil</span> <span class="p">}</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的例子，name属性是个optional的，所以有初始值 nil。是满足我们的要求的。</p>

<p>因为name是常量属性，所以我们一旦初始化成功，我们就可以确保name始终有值，可以不用去再检查。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">if</span> <span class="n">let</span> <span class="n">bowTie</span> <span class="o">=</span> <span class="n">Product</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="s">&quot;bow tie&quot;</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// no need to check if bowTie.name == nil</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="s">&quot;The product&#39;s name is \(bowTie.name)&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">// prints &quot;The product&#39;s name is bow tie&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<h6>初始化失败的传递</h6>

<p>一个可失败的初始化函数可以代理到同一个类的其他的可失败的初始化函数，对于类，也可以代理到父类的可失败的初始化函数。</p>

<p>不论如何代理，如果一个可失败的初始化函数失败，那么整个初始化过程失败。</p>

<pre><code>注意
可失败的初始化函数也可以代理到一个不可失败的初始化函数。如果你需要在一个已有的初始化过程中添加一个潜在的失败的初始化函数，可以这种方式。
</code></pre>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">class</span> <span class="nl">CartItem</span><span class="p">:</span> <span class="n">Product</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">let</span> <span class="nl">quantity</span><span class="p">:</span> <span class="n">Int</span><span class="o">!</span>
</span><span class='line'>    <span class="n">init</span><span class="o">?</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span> <span class="nl">quantity</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nb">super</span><span class="p">.</span><span class="n">init</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="n">name</span><span class="p">)</span>
</span><span class='line'>        <span class="k">if</span> <span class="n">quantity</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">nil</span> <span class="p">}</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">quantity</span> <span class="o">=</span> <span class="n">quantity</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的例子中，quantity是optional的，初始值是nil。我们先调用了super.init(name: name) 来满足可失败的初始化函数的要求。如果name是空的，那么super.init就会失败，整个初始化就失败了。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">if</span> <span class="n">let</span> <span class="n">twoSocks</span> <span class="o">=</span> <span class="n">CartItem</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="s">&quot;sock&quot;</span><span class="p">,</span> <span class="nl">quantity</span><span class="p">:</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="s">&quot;Item: \(twoSocks.name), quantity: \(twoSocks.quantity)&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">// prints &quot;Item: sock, quantity: 2&quot;</span>
</span><span class='line'><span class="k">if</span> <span class="n">let</span> <span class="n">zeroShirts</span> <span class="o">=</span> <span class="n">CartItem</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="s">&quot;shirt&quot;</span><span class="p">,</span> <span class="nl">quantity</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="s">&quot;Item: \(zeroShirts.name), quantity: \(zeroShirts.quantity)&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="s">&quot;Unable to initialize zero shirts&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">// prints &quot;Unable to initialize zero shirts&quot;</span>
</span><span class='line'><span class="k">if</span> <span class="n">let</span> <span class="n">oneUnnamed</span> <span class="o">=</span> <span class="n">CartItem</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="nl">quantity</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="s">&quot;Item: \(oneUnnamed.name), quantity: \(oneUnnamed.quantity)&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="s">&quot;Unable to initialize one unnamed product&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">// prints &quot;Unable to initialize one unnamed product&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<h6>重写可失败的初始化函数</h6>

<p>我们可以在子类里重写可失败的初始化函数，我们甚至可以在子类里把可失败的初始化函数重写为不可失败的初始化函数。</p>

<p>如果我们在子类里把一个父类的可失败的初始化函数重写为一个不可失败的初始化函数，那么我们就不能向上代理这个初始化函数。一个不可失败的初始化函数永远都不能代理到一个可失败的初始化函数。</p>

<pre><code>注意
我们可以把一个可失败的重写为一个不可失败的，相反则不行。
</code></pre>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">class</span> <span class="n">Document</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">var</span> <span class="nl">name</span><span class="p">:</span> <span class="n">String</span><span class="o">?</span>
</span><span class='line'>    <span class="c1">// this initializer creates a document with a nil name value</span>
</span><span class='line'>    <span class="n">init</span><span class="p">()</span> <span class="p">{}</span>
</span><span class='line'>    <span class="c1">// this initializer creates a document with a non-empty name value</span>
</span><span class='line'>    <span class="n">init</span><span class="o">?</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="n">name</span><span class="p">.</span><span class="n">isEmpty</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">nil</span> <span class="p">}</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Document的名字可以是nil，但是不能为空字符串&#8221;&ldquo;。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">class</span> <span class="nl">AutomaticallyNamedDocument</span><span class="p">:</span> <span class="n">Document</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">override</span> <span class="n">init</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="nb">super</span><span class="p">.</span><span class="n">init</span><span class="p">()</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;[Untitled]&quot;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">override</span> <span class="n">init</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nb">super</span><span class="p">.</span><span class="n">init</span><span class="p">()</span>
</span><span class='line'>        <span class="k">if</span> <span class="n">name</span><span class="p">.</span><span class="n">isEmpty</span> <span class="p">{</span>
</span><span class='line'>            <span class="nb">self</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;[Untitled]&quot;</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>            <span class="nb">self</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>AutomaticallyNamedDocument重写了可失败的init，但是因为AutomaticallyNamedDocument是自动提供名字的，所以它不会失败。</p>

<h6>init! 可失败初始化函数</h6>

<p>因为 init? 初始化一个 optional的值。</p>

<p>我们也可以使用 init! 来初始化一个自动解包的otpional的值。</p>

<p>我们可以在init? 和 init! 之前互相代理，也可以互相重写。我们也可以从 init 代理到 init!，但是这样做，如果init! 失败就会触发一个断言。</p>

<h5>必须的初始化函数</h5>

<p>在一个类的初始化函数前面加上 required 来表示任何的子类都必须实现这个初始化函数。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">class</span> <span class="n">SomeClass</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">required</span> <span class="n">init</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// initializer implementation goes here</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在子类里，你也必须加上 required 关键字，但是不需要写 override。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">class</span> <span class="nl">SomeSubclass</span><span class="p">:</span> <span class="n">SomeClass</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">required</span> <span class="n">init</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// subclass implementation of the required initializer goes here</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<pre><code>注意
你需要显式的实现 required的初始化函数，如果你可以通过一个继承的初始化函数来实现。
</code></pre>

<h5>通过闭包或函数来设置默认的属性值</h5>

<p>如果一个存储属性的默认值需要一些自定义或是配置，我们可以使用闭包或全局函数来提供默认值。每当一个实例被创建，这个闭包或函数就被调用，返回值会设置给对应的属性。</p>

<p>这种类型的闭包和函数一般创建一个和属性类型一致的变量，然后返回这个变量。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">class</span> <span class="n">SomeClass</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">let</span> <span class="nl">someProperty</span><span class="p">:</span> <span class="n">SomeType</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// create a default value for someProperty inside this closure</span>
</span><span class='line'>        <span class="c1">// someValue must be of the same type as SomeType</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">someValue</span>
</span><span class='line'>        <span class="p">}()</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意大括号后面的括弧，这是告诉Swift来执行这个闭包，如果不写括弧，其实是把闭包附值给了属性，而不是闭包执行的结果。</p>

<pre><code>注意
如果使用闭包来初始化属性，记得实例的其他的部分还没有被初始化，所以不能在闭包里使用其他属性，self也不能用，还不能调用实例方法。
</code></pre>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">struct</span> <span class="n">Checkerboard</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">let</span> <span class="nl">boardColors</span><span class="p">:</span> <span class="p">[</span><span class="n">Bool</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">var</span> <span class="n">temporaryBoard</span> <span class="o">=</span> <span class="p">[</span><span class="n">Bool</span><span class="p">]()</span>
</span><span class='line'>        <span class="n">var</span> <span class="n">isBlack</span> <span class="o">=</span> <span class="nb">false</span>
</span><span class='line'>        <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mf">1.</span><span class="p">.</span><span class="mf">.10</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">for</span> <span class="n">j</span> <span class="k">in</span> <span class="mf">1.</span><span class="p">.</span><span class="mf">.10</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">temporaryBoard</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">isBlack</span><span class="p">)</span>
</span><span class='line'>                <span class="n">isBlack</span> <span class="o">=</span> <span class="o">!</span><span class="n">isBlack</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>            <span class="n">isBlack</span> <span class="o">=</span> <span class="o">!</span><span class="n">isBlack</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">temporaryBoard</span>
</span><span class='line'>        <span class="p">}()</span>
</span><span class='line'>    <span class="n">func</span> <span class="n">squareIsBlackAtRow</span><span class="p">(</span><span class="nl">row</span><span class="p">:</span> <span class="n">Int</span><span class="p">,</span> <span class="nl">column</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Bool</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">boardColors</span><span class="p">[(</span><span class="n">row</span> <span class="o">*</span> <span class="mi">10</span><span class="p">)</span> <span class="o">+</span> <span class="n">column</span><span class="p">]</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>每当一个Checkerboard创建时，boardColors对应的闭包都会执行。</p>
]]></content>
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: swift | zxhfirefox's Blog]]></title>
  <link href="http://zxhfirefox.github.io/blog/categories/swift/atom.xml" rel="self"/>
  <link href="http://zxhfirefox.github.io/"/>
  <updated>2014-10-25T10:29:03+08:00</updated>
  <id>http://zxhfirefox.github.io/</id>
  <author>
    <name><![CDATA[zxhfirefox]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Language Guide: Protocols]]></title>
    <link href="http://zxhfirefox.github.io/blog/2014/10/25/language-guide-w-protocols/"/>
    <updated>2014-10-25T10:26:20+08:00</updated>
    <id>http://zxhfirefox.github.io/blog/2014/10/25/language-guide-w-protocols</id>
    <content type="html"><![CDATA[<p>一个协议定义了一系列满足某些特定需要的方法，属性和其他要求的一个蓝图。协议本身并不提供这些要求的具体实现，它只负责描述这些要求。然后，协议可以被类，结构体，枚举来实现提供这些要求的真正实现。</p>

<p>协议可以要求实现协议的类型有特殊的实例属性，实例方法，类型方法，操作符和角标。</p>

<!-- more -->


<h3>协议语法</h3>

<p>定义协议和定义类，结构体，枚举很相似。</p>

<pre><code class="swift">protocol SomeProtocol {
    // protocol definition goes here
}
</code></pre>

<p>当类型实现协议时，把协议写在类型名字后面，由冒号隔开，多个协议之间由逗号分开。</p>

<pre><code class="swift">struct SomeStructure: FirstProtocol, AnotherProtocol {
    // structure definition goes here
}
</code></pre>

<p>如果类有父类，要把父类写在协议的前面。</p>

<pre><code class="swift">class SomeClass: SomeSuperclass, FirstProtocol, AnotherProtocol {
    // class definition goes here
}
</code></pre>

<h3>属性要求</h3>

<p>协议可以要求实现的类型提供实例属性或类属性。协议并不表明是存储属性还是计算属性，它只给出类型和名字，同时说明是只读的还是可读可写的。</p>

<p>如果一个协议规定的属性是可读可写的，那么实现类型不就能通过常量存储属性或只读计算属性来满足。如果协议规定的属性是只读的，那么实现类型可以通过任何属性来实现，就算你在实现时同时给出了setter也是可以的。</p>

<p>属性要求总是写成变量形式的。getter和setter用 set 和 get 标示。</p>

<pre><code class="swift">protocol SomeProtocol {
    var mustBeSettable: Int { get set }
    var doesNotNeedToBeSettable: Int { get }
}
</code></pre>

<p>类型属性总是用class 来标示，即使实现的类型是值类型，具体实现里用的是 static。</p>

<pre><code class="swift">protocol AnotherProtocol {
    class var someTypeProperty: Int { get set }
}
</code></pre>

<p>下面的例子:</p>

<pre><code class="swift">protocol FullyNamed {
    var fullName: String { get }
}
</code></pre>

<p>只定义了一个属性要求。</p>

<pre><code class="swift">struct Person: FullyNamed {
    var fullName: String
}
let john = Person(fullName: "John Appleseed")
// john.fullName is "John Appleseed"
</code></pre>

<p>Person实现了协议，通过一个存储的属性。</p>

<pre><code class="swift">class Starship: FullyNamed {
    var prefix: String?
    var name: String
    init(name: String, prefix: String? = nil) {
        self.name = name
        self.prefix = prefix
    }
    var fullName: String {
        return (prefix != nil ? prefix! + " " : "") + name
    }
}
var ncc1701 = Starship(name: "Enterprise", prefix: "USS")
// ncc1701.fullName is "USS Enterprise"
</code></pre>

<p>Starship也实现了这个协议，通过一个计算属性。</p>

<h3>方法要求</h3>

<p>协议可以要求实现类型去实现特定的实例方法和类型方法。这些方法在协议里的定义和他们实现时一模一样，只是没有大括号和函数体。变长参数也是可以的，规则和普通方法一样。</p>

<pre><code>注意
协议定义的方法和普通方法语法一样，但是不能允许给出参数默认值。
</code></pre>

<p>和类型属性要求一样，在类型方法要求前面添加 class 关键字。即使是值类型去实现这个方法。</p>

<pre><code class="swift">protocol SomeProtocol {
    class func someTypeMethod()
}
protocol RandomNumberGenerator {
    func random() -&gt; Double
}
</code></pre>

<p>上面是两个协议，一个定义了一个类型方法，一个定义了一个实例方法。</p>

<pre><code class="swift">class LinearCongruentialGenerator: RandomNumberGenerator {
    var lastRandom = 42.0
    let m = 139968.0
    let a = 3877.0
    let c = 29573.0
    func random() -&gt; Double {
        lastRandom = ((lastRandom * a + c) % m)
        return lastRandom / m
    }
}
let generator = LinearCongruentialGenerator()
println("Here's a random number: \(generator.random())")
// prints "Here's a random number: 0.37464991998171"
println("And another one: \(generator.random())")
// prints "And another one: 0.729023776863283"
</code></pre>

<h3>可变方法要求</h3>

<p>如果我们定义协议实例方法需要修改实例本身，我们也需要在协议定义中，给方法加上 mutating 关键字。这样使得结构体和枚举可以实现协议。</p>

<pre><code>注意
如果我们在协议定义时，给出 mutating，当我们用一个类实现协议时，就不用写 mutating，但是如果是结构体和枚举，是必须要写得。
</code></pre>

<pre><code class="swift">protocol Togglable {
    mutating func toggle()
}
</code></pre>

<p>我们定义了一个协议，包含一个mutating的方法。</p>

<pre><code class="swift">enum OnOffSwitch: Togglable {
    case Off, On
    mutating func toggle() {
        switch self {
        case Off:
            self = On
        case On:
            self = Off
        }
    }
}
var lightSwitch = OnOffSwitch.Off
lightSwitch.toggle()
// lightSwitch is now equal to .On
</code></pre>

<p>我们在枚举OnOffSwitch上实现了协议。</p>

<h3>初始化函数要求</h3>

<p>协议可以定义特殊的初始化函数要求。</p>

<pre><code class="swift">protocol SomeProtocol {
    init(someParameter: Int)
}
</code></pre>

<h4>类实现</h4>

<p>我们可以把协议要求的初始化函数实现为指定初始化函数或便利初始化函数，但是都需要加上 required。</p>

<pre><code class="swift">class SomeClass: SomeProtocol {
    required init(someParameter: Int) {
        // initializer implementation goes here
    }
}
</code></pre>

<p>使用 required 保证了我们给所有子类提供了显式的或是继承的初始化函数。</p>

<pre><code>注意
如果类是 final，则我们可以不写 required的。
</code></pre>

<p>如果一个子类重写了一个父类的指定初始化函数，并且实现了一个协议的初始化函数，required 和 override 则都需要写。</p>

<pre><code class="swift">protocol SomeProtocol {
    init()
}
class SomeSuperClass {
    init() {
        // initializer implementation goes here
    }
}
class SomeSubClass: SomeSuperClass, SomeProtocol {
    // "required" from SomeProtocol conformance; "override" from SomeSuperClass
    required override init() {
        // initializer implementation goes here
    }
}
</code></pre>

<h4>可失败的初始化函数要求</h4>

<p>协议可以定义可失败的初始化函数要求。</p>

<p>一个可失败的初始化要求可以被一个可失败的或者不可失败的初始化函数实现。一个不可失败的初始化函数可以被一个不可失败的或是一个自动解包的可失败初始化函数实现。</p>

<h3>协议也是类型</h3>

<p>协议不会提供它定义的任何要求的实现。然而，协议却可以作为一个类型来使用。</p>

<p>因为它也是类型，所以我们可以把它用在任何一个类型允许的地方。例如：
    *   作为参数或返回值
    *   作为常量，变量或属性
    *   作为字典，数组或其他集合的元素的类型</p>

<pre><code>注意
因为协议是类型，所以首字母应该大写
</code></pre>

<pre><code class="swift">class Dice {
    let sides: Int
    let generator: RandomNumberGenerator
    init(sides: Int, generator: RandomNumberGenerator) {
        self.sides = sides
        self.generator = generator
    }
    func roll() -&gt; Int {
        return Int(generator.random() * Double(sides)) + 1
    }
}
</code></pre>

<p>我们定义了Dice类，它有一个RandomNumberGenerator的属性。</p>

<pre><code class="swift">var d6 = Dice(sides: 6, generator: LinearCongruentialGenerator())
for _ in 1...5 {
    println("Random dice roll is \(d6.roll())")
}
// Random dice roll is 3
// Random dice roll is 5
// Random dice roll is 4
// Random dice roll is 5
// Random dice roll is 4
</code></pre>

<h3>代理</h3>

<p>代理，是一种设计模式，它可以让一个类或结构体把自己的一部分责任代理给其他类型的实例。这个设计模式通过把代理过去的责任封装到一个协议里，然后实现了协议的类型就可以作为代理来提供这部分功能。代理可以用来相应某些特定的时间，或者从不知道底层类型的数据获取数据。</p>

<pre><code class="swift">protocol DiceGame {
    var dice: Dice { get }
    func play()
}
protocol DiceGameDelegate {
    func gameDidStart(game: DiceGame)
    func game(game: DiceGame, didStartNewTurnWithDiceRoll diceRoll: Int)
    func gameDidEnd(game: DiceGame)
}
</code></pre>

<p>我们定义了2个协议，DiceGame和GiceGameDelegate。</p>

<pre><code class="swift">class SnakesAndLadders: DiceGame {
    let finalSquare = 25
    let dice = Dice(sides: 6, generator: LinearCongruentialGenerator())
    var square = 0
    var board: [Int]
    init() {
        board = [Int](count: finalSquare + 1, repeatedValue: 0)
        board[03] = +08; board[06] = +11; board[09] = +09; board[10] = +02
        board[14] = -10; board[19] = -11; board[22] = -02; board[24] = -08
    }
    var delegate: DiceGameDelegate?
    func play() {
        square = 0
        delegate?.gameDidStart(self)
        gameLoop: while square != finalSquare {
            let diceRoll = dice.roll()
            delegate?.game(self, didStartNewTurnWithDiceRoll: diceRoll)
            switch square + diceRoll {
            case finalSquare:
                break gameLoop
            case let newSquare where newSquare &gt; finalSquare:
                continue gameLoop
            default:
                square += diceRoll
                square += board[square]
            }
        }
        delegate?.gameDidEnd(self)
    }
}
</code></pre>

<pre><code class="swift">class DiceGameTracker: DiceGameDelegate {
    var numberOfTurns = 0
    func gameDidStart(game: DiceGame) {
        numberOfTurns = 0
        if game is SnakesAndLadders {
            println("Started a new game of Snakes and Ladders")
        }
        println("The game is using a \(game.dice.sides)-sided dice")
    }
    func game(game: DiceGame, didStartNewTurnWithDiceRoll diceRoll: Int) {
        ++numberOfTurns
        println("Rolled a \(diceRoll)")
    }
    func gameDidEnd(game: DiceGame) {
        println("The game lasted for \(numberOfTurns) turns")
    }
}
</code></pre>

<pre><code class="swift">let tracker = DiceGameTracker()
let game = SnakesAndLadders()
game.delegate = tracker
game.play()
// Started a new game of Snakes and Ladders
// The game is using a 6-sided dice
// Rolled a 3
// Rolled a 5
// Rolled a 4
// Rolled a 5
// The game lasted for 4 turns
</code></pre>

<h3>通过扩展来实现协议</h3>

<p>我们可以通过扩展一个类型来实现协议，即使我们拿不到这个类型的源代码。扩展可以添加属性，方法，角标，也可以添加协议的实现。</p>

<pre><code>注意
已有的实例也会具有新扩展实现的协议。
</code></pre>

<pre><code class="swift">protocol TextRepresentable {
    func asText() -&gt; String
}
</code></pre>

<pre><code class="swift">extension Dice: TextRepresentable {
    func asText() -&gt; String {
        return "A \(sides)-sided dice"
    }
}
</code></pre>

<p>我们扩展Dice来实现了TextRepresentable协议。</p>

<pre><code class="swift">let d12 = Dice(sides: 12, generator: LinearCongruentialGenerator())
println(d12.asText())
// prints "A 12-sided dice"
</code></pre>

<p>我们就可以使用asText方法了。</p>

<h4>通过扩展来声明协议实现</h4>

<p>如果一个类型已经实现了协议的所有要求，但是没有说明它实现了协议。我们可以通过一个扩展来说明。</p>

<pre><code class="swift">struct Hamster {
    var name: String
    func asText() -&gt; String {
        return "A hamster named \(name)"
    }
}
extension Hamster: TextRepresentable {}
</code></pre>

<pre><code class="swift">let simonTheHamster = Hamster(name: "Simon")
let somethingTextRepresentable: TextRepresentable = simonTheHamster
println(somethingTextRepresentable.asText())
// prints "A hamster named Simon"
</code></pre>

<p>这样，Hamster实例可以被当做TextRepresentable类型。</p>

<pre><code>注意
类型不是简单的满足协议的要求就算实现协议了，他们必须声明他们实现了协议。
</code></pre>

<h3>协议类型集合</h3>

<p>协议可以作为集合元素的类型。</p>

<pre><code class="swift">let things: [TextRepresentable] = [game, d12, simonTheHamster]
for thing in things {
    println(thing.asText())
}
// A game of Snakes and Ladders with 25 squares
// A 12-sided dice
// A hamster named Simon
</code></pre>

<p>注意thing的类型是TextRepresentable，而不是具体的其他类型。然而，因为它的类型是TextRepresentable，TextRepresentable能做的任何事情，它们都可以做。</p>

<h3>协议继承</h3>

<p>协议可以从一个或多个协议继承，而且还可以在这些基础上添加新的要求。协议的继承语法和类的继承语法是一样的。</p>

<pre><code class="swift">protocol InheritingProtocol: SomeProtocol, AnotherProtocol {
    // protocol definition goes here
}
</code></pre>

<pre><code class="swift">protocol PrettyTextRepresentable: TextRepresentable {
    func asPrettyText() -&gt; String
}
</code></pre>

<p>这里我们定义了一个新的协议，继承自TextRepresentable。</p>

<pre><code class="swift">extension SnakesAndLadders: PrettyTextRepresentable {
    func asPrettyText() -&gt; String {
        var output = asText() + ":\n"
        for index in 1...finalSquare {
            switch board[index] {
            case let ladder where ladder &gt; 0:
                output += "▲ "
            case let snake where snake &lt; 0:
                output += "▼ "
            default:
                output += "○ "
            }
        }
        return output
    }
}
println(game.asPrettyText())
// A game of Snakes and Ladders with 25 squares:
// ○ ○ ▲ ○ ○ ▲ ○ ○ ▲ ▲ ○ ○ ○ ▼ ○ ○ ○ ○ ▼ ○ ○ ▼ ○ ▼ ○
</code></pre>

<h3>只给类的协议</h3>

<p>我们可以限制实现协议的类型只能是类，而不能是结构体和枚举。通过在协议继承列表的最前面加一个 class 来限制实现协议的类型只能是类。</p>

<pre><code class="swift">protocol SomeClassOnlyProtocol: class, SomeInheritedProtocol {
    // class-only protocol definition goes here
}
</code></pre>

<pre><code>注意
仅当协议的实现需要区分值和引用的不同语意时使用只给类的协议。
</code></pre>

<h3>协议组合</h3>

<p>有时候要求一个类型同时实现多个协议是有用的。我们可以把多个协议组合成一个协议。写成protocol&lt;SomeProtocl, AnotherProtocol>。我们可以在尖括号里写任意多得协议。</p>

<pre><code class="swift">protocol Named {
    var name: String { get }
}
protocol Aged {
    var age: Int { get }
}
struct Person: Named, Aged {
    var name: String
    var age: Int
}
func wishHappyBirthday(celebrator: protocol&lt;Named, Aged&gt;) {
    println("Happy birthday \(celebrator.name) - you're \(celebrator.age)!")
}
let birthdayPerson = Person(name: "Malcolm", age: 21)
wishHappyBirthday(birthdayPerson)
// prints "Happy birthday Malcolm - you're 21!"
</code></pre>

<p>上面的例子里，我们定义2个协议，由一个结构体实现2个协议。定义了一个函数接受一个组合协议的类型。</p>

<pre><code>注意
协议组合并没有定义一个新的，永久的类型。相反，是临时的定义了一个局部的组合了其他协议的协议。
</code></pre>

<h3>检查协议实现</h3>

<p>我们可以使用 is 和 as 操作符来检查协议实现和把实例转换到特定协议类型。检查协议实现和检查类型是一样的。
    *   如果实例实现了协议，is 返回true，如果没有，返回 false。
    *   as？ 返回一个optional的协议类型，如果实例没有实现协议，返回nil。
    *   as 返回一个一个特定的协议类型，如果实例没有实现协议，运行时错误。</p>

<pre><code class="swift">@objc protocol HasArea {
    var area: Double { get }
}
</code></pre>

<pre><code>注意
如果我们要检查一个协议是否被实例实现，我们必须把协议标记上 @objc。这个标记意味着这个协议可以在ObjC代码中使用。即使你打算在ObjC中使用，你如果想对实例做检查，协议也必须标记为 @objc。

另外，标记为@objc的协议只能被类实现，而不能被结构体和枚举实现。
</code></pre>

<pre><code class="swift">class Circle: HasArea {
    let pi = 3.1415927
    var radius: Double
    var area: Double { return pi * radius * radius }
    init(radius: Double) { self.radius = radius }
}
class Country: HasArea {
    var area: Double
    init(area: Double) { self.area = area }
}
class Animal {
    var legs: Int
    init(legs: Int) { self.legs = legs }
}
let objects: [AnyObject] = [
    Circle(radius: 2.0),
    Country(area: 243_610),
    Animal(legs: 4)
]
for object in objects {
    if let objectWithArea = object as? HasArea {
        println("Area is \(objectWithArea.area)")
    } else {
        println("Something that doesn't have an area")
    }
}
// Area is 12.5663708
// Area is 243610.0
// Something that doesn't have an area
</code></pre>

<h3>可选的协议要求</h3>

<p>我们可以在协议里定义可选的要求。这些要求可以不被实现的类型实现。可选的要求前面用 optional来标示。</p>

<p>一个可选的协议要求可以使用optional链来调用，来检查一个类型实现了协议，但没有实现可选的要求。</p>

<p>我们在可选的要求后面加？来调用。可选的属性和方法，总会返回一个optional的值。来表示是否成功访问或调用，来反映这个可选的要求是否被实现。</p>

<pre><code>注意
可选的协议要求只能在@objc的协议里。
</code></pre>

<pre><code class="swift">@objc protocol CounterDataSource {
    optional func incrementForCount(count: Int) -&gt; Int
    optional var fixedIncrement: Int { get }
}
</code></pre>

<pre><code>注意
严格来说，我们可以定义一个类，实现CounterDataSource，但不给出任何实现。
</code></pre>

<pre><code class="swift">@objc class Counter {
    var count = 0
    var dataSource: CounterDataSource?
    func increment() {
        if let amount = dataSource?.incrementForCount?(count) {
            count += amount
        } else if let amount = dataSource?.fixedIncrement? {
            count += amount
        }
    }
}
</code></pre>

<pre><code class="swift">class ThreeSource: CounterDataSource {
    let fixedIncrement = 3
}
var counter = Counter()
counter.dataSource = ThreeSource()
for _ in 1...4 {
    counter.increment()
    println(counter.count)
}
// 3
// 6
// 9
// 12
class TowardsZeroSource: CounterDataSource {
    func incrementForCount(count: Int) -&gt; Int {
        if count == 0 {
            return 0
        } else if count &lt; 0 {
            return 1
        } else {
            return -1
        }
    }
}
counter.count = -4
counter.dataSource = TowardsZeroSource()
for _ in 1...5 {
    counter.increment()
    println(counter.count)
}
// -3
// -2
// -1
// 0
// 0
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Language Guide: Extension]]></title>
    <link href="http://zxhfirefox.github.io/blog/2014/10/25/language-guide-v-extension/"/>
    <updated>2014-10-25T10:25:34+08:00</updated>
    <id>http://zxhfirefox.github.io/blog/2014/10/25/language-guide-v-extension</id>
    <content type="html"><![CDATA[<p>扩展可以给已有的类，结构体，枚举添加新的功能。这包括可以给我们无法获取源代码的类型添加功能。扩展和ObjC的类别很相似。（和ObjC的类别不同，Swift的扩展没有名字）</p>

<p>Swift里扩展可以：</p>

<ul>
<li>添加计算属性和静态计算属性</li>
<li>添加实例方法和类型方法</li>
<li>提供新的初始化函数</li>
<li>定义角标</li>
<li>定义和使用新的嵌套类型</li>
<li><p>实现协议</p>

<pre><code>注意
扩展只能添加功能，而不能重写已有的功能
</code></pre></li>
</ul>


<!-- more -->


<h3>语法</h3>

<p>使用 extension 关键字声明扩展：</p>

<pre><code class="swift">extension SomeType{
}
</code></pre>

<p>扩展可以让一个现有类型实现一个或多个协议。这种情况下，协议的名字和对于类或者结构体是一样的。</p>

<pre><code class="swift">extension SomeType: SomeProtocol, AnotherProtocol{
}
</code></pre>

<pre><code>注意
我们使用扩展给现有类型添加功能，这些功能将对所有实例产生效果，即使是在扩展定义之前就创建的实例
</code></pre>

<h3>计算属性</h3>

<p>扩展可以给现有类型添加计算的实例属性或类属性。</p>

<pre><code class="swift">extension Double{
    var km: Double { return self * 1_000.0 }
    var m: Double { return self }
    var cm: Double { return self / 100.0 }
    var mm: Double { return self / 1_000.0 }
    var ft: Double { return self / 3.28084 }
}
let oneInch = 25.4.mm
println("One inch is \(oneInch) meters")
// prints "One inch is 0.0254 meters"
let threeFeet = 3.ft
println("Three feet is \(threeFeet) meters")
// prints "Three feet is 0.914399970739201 meters"
</code></pre>

<p>这些计算属性可以用于数值字面量。</p>

<p>他们也是只读的属性。</p>

<pre><code class="swift">let aMarathon = 42.km + 195.m
println("A marathon is \(aMarathon) meters long")
// prints "A marathon is 42195.0 meters long"
</code></pre>

<pre><code>注意
扩展可以添加计算属性，但是不能添加存储属性，也不能注册属性观察者
</code></pre>

<h3>初始化函数</h3>

<p>扩展可以给已有类型添加新的初始化函数。这样我们可以扩展一些类型让他们可以接受我们自己的初始化参数，或者增加一些原有实现没有的初始化选项。</p>

<p>扩展可以给类添加便利初始化函数，但是不能添加指定初始化函数，或者反初始化函数。这两种函数必须在原有实现上实现。</p>

<pre><code>注意
如果我们通过扩展给值类型添加一个初始化函数，而这个函数提供了所有存储属性的默认值，并且没有添加自定义的初始化函数，那么我们可以在扩展的初始化函数里调用默认初始化函数或按成员的初始化函数。

因为如果我们在值类型里定义了自定义的初始化函数，默认的初始化函数就不会提供。但是扩展里可以。
</code></pre>

<pre><code class="swift">struct Size {
    var width = 0.0, height = 0.0
}
struct Point {
    var x = 0.0, y = 0.0
}
struct Rect {
    var origin = Point()
    var size = Size()
}
</code></pre>

<p>我们定义了3个结构体，他们都有默认的初始化函数和按成员的初始化函数。</p>

<pre><code class="swift">let defaultRect = Rect()
let memberwiseRect = Rect(origin: Point(x: 2.0, y: 2.0),
    size: Size(width: 5.0, height: 5.0))
</code></pre>

<p>我们添加一个扩展：</p>

<pre><code class="swift">extension Rect {
    init(center: Point, size: Size) {
        let originX = center.x - (size.width / 2)
        let originY = center.y - (size.height / 2)
        self.init(origin: Point(x: originX, y: originY), size: size)
    }
}
</code></pre>

<p>我们可以使用这个初始化来创建实例：</p>

<pre><code class="swift">let centerRect = Rect(center: Point(x: 4.0, y: 4.0),
    size: Size(width: 3.0, height: 3.0))
// centerRect's origin is (2.5, 2.5) and its size is (3.0, 3.0)
</code></pre>

<pre><code>注意
所有我们在扩展里添加的初始化函数，都依然需要保证初始化结束后，实例是完整的被初始化的。
</code></pre>

<h3>方法</h3>

<p>扩展还可以给已有类型添加实例方法或类型方法。</p>

<pre><code class="swift">extension Int {
    func repetitions(task: () -&gt; ()) {
        for i in 0..&lt;self {
            task()
        }
    }
}
3.repetitions({
    println("Hello!")
})
// Hello!
// Hello!
// Hello!
3.repetitions {
    println("Goodbye!")
}
// Goodbye!
// Goodbye!
// Goodbye!
</code></pre>

<p>注：这种看起来就和Ruby的有些相似了。</p>

<h4>可变的实例方法</h4>

<p>通过扩展添加的实例方法也可以修改实例本身。结构体和枚举方法修改的自己的必须添加 mutating。</p>

<pre><code class="swift">extension Int {
    mutating func square() {
        self = self * self
    }
}
var someInt = 3
someInt.square()
// someInt is now 9
</code></pre>

<h3>角标</h3>

<p>扩展也可以给给已有类型添加角标。</p>

<pre><code class="swift">extension Int {
    subscript(var digitIndex: Int) -&gt; Int {
        var decimalBase = 1
        while digitIndex &gt; 0 {
            decimalBase *= 10
            --digitIndex
        }
        return (self / decimalBase) % 10
    }
}
746381295[0]
// returns 5
746381295[1]
// returns 9
746381295[2]
// returns 2
746381295[8]
// returns 7
</code></pre>

<p>注：很有意思的扩展。。。</p>

<h3>嵌套类型</h3>

<p>扩展也可以在已有类型中添加新的嵌套类型。</p>

<pre><code class="swift">extension Int {
    enum Kind {
        case Negative, Zero, Positive
    }
    var kind: Kind {
        switch self {
        case 0:
            return .Zero
        case let x where x &gt; 0:
            return .Positive
        default:
            return .Negative
        }
    }
}
</code></pre>

<pre><code class="swift">func printIntegerKinds(numbers: [Int]) {
    for number in numbers {
        switch number.kind {
        case .Negative:
            print("- ")
        case .Zero:
            print("0 ")
        case .Positive:
            print("+ ")
        }
    }
    print("\n")
}
printIntegerKinds([3, 19, -27, 0, -6, 0, 7])
// prints "+ + - 0 - 0 +"
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Language Guide: Nested Type]]></title>
    <link href="http://zxhfirefox.github.io/blog/2014/10/25/language-guide-u-nested-type/"/>
    <updated>2014-10-25T10:24:19+08:00</updated>
    <id>http://zxhfirefox.github.io/blog/2014/10/25/language-guide-u-nested-type</id>
    <content type="html"><![CDATA[<p>枚举通常被定义来帮助实现一个类和结构体。同样的，有时候为了在一个更复杂的上下文里定义和使用某一些特殊的类型是很方便的。为了达到这一点，Swift允许定义嵌套类型，这样你就可以在需要枚举，类，结构体来支持的复杂的类型里定义他们。</p>

<p>定义嵌套类型，只需要把类型定义写在大括号里面。你需要嵌套几层就嵌套几层。</p>

<!-- more -->


<h5>嵌套类型举例</h5>

<p>下面的例子定义了一个结构体，BlackjackCard，它代表了一种扑克牌。这个结构里有2个嵌套的类型，叫Suit和Rank。</p>

<p>在 Blackjack里，Ace有2个值，1或11.这个值有一个叫Values的结构体表示，这个结构体嵌套在Rank里。</p>

<pre><code class="swift">struct BlackjackCard{
    enum Suit: Character{
        case Spades="s",Hearts="h",Diamonds="d",Clubs="c"
    }
    enum Rank: Int {
        case Two = 2, Three, Four, Five, Six, Seven, Eight, Nine, Ten
        case Jack, Queen, King, Ace
        struct Values{
            let first: Int,second: Int?
        }
        var values: Values{
            switch self{
            case .Ace:
                return Values(first:1,second:11)
            case .Jack, .Queen, .King:
                return Values(first:10,second:nil)
            default:
                return Values(first:self.toRaw(),second:nil)
            }
        }
    }
    let rank: Rank,suit: Suit
    var description: String {
        var output = "suit is \(suit.toRaw(),"
        output += " value is \(rank.values.first)"
        if let second = rank.values.second {
            output += " or \(second)"
        }
        return output
    }
}
</code></pre>

<p>Suit枚举定义了扑克牌里常见的四种花色。</p>

<p>Rank枚举定义了扑克牌的大小。</p>

<p>Rank还嵌套了一个类型Values来表示扑克牌一般只有一个值，除了Ace有两个值。而Values里有一个Int的first和一个optional的Int的sencond。</p>

<p>Rank还定义了一个计算的属性values，返回一个Values类型的值。</p>

<p>BlackjackCard自己有2个属性，suit和rank。还有一个计算的属性，description。</p>

<p>因为BlackjackCard没有自定义初始化函数，所以它有一个默认的成员初始化函数。</p>

<pre><code class="swift">let theAceOfSpades = BlackjackCard(rank: .Ace,suit: .Spades)
println(theAceOfSpades)
</code></pre>

<p>尽管Rank和Suit是嵌套在BlackjackCard里的类型，他们的类型依然可以从上下文里推断出来。</p>

<h5>引用嵌套类型</h5>

<p>如果需要在定义上下文之外的地方使用嵌套类型，需要把外部类型的名字加在嵌套类型的名字的前面：</p>

<pre><code class="swift">let heartsSymbol = BlackjackCard.Suit.Hearts.toRaw()
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Language Guide: Type Casting]]></title>
    <link href="http://zxhfirefox.github.io/blog/2014/10/25/language-guide-type-cast/"/>
    <updated>2014-10-25T10:23:07+08:00</updated>
    <id>http://zxhfirefox.github.io/blog/2014/10/25/language-guide-type-cast</id>
    <content type="html"><![CDATA[<p>类型转换是一种检查实例类型的方法，并且或者把这个实例作为它的类别的父类或子类来使用。</p>

<p>Swift里类型转换用is和as操作符。这两个操作符提供了简单的方式来检查一个值的类型或者把一个值转换到另一个类型。</p>

<p>我们也可以用类型转换来检查一个类型是否实现了一个协议。</p>

<!-- more -->


<h3>定义一个类继承树</h3>

<p>我们需要在类继承里检查一个实例是否是某个类的实例，并把它转换到同一个继承树里的其他类。</p>

<pre><code class="swift">class MediaItem {
    var name: String
    init(name: String) {
        self.name = name
    }
}
class Movie: MediaItem {
    var director: String
    init(name: String, director: String) {
        self.director = director
        super.init(name: name)
    }
}
class Song: MediaItem {
    var artist: String
    init(name: String, artist: String) {
        self.artist = artist
        super.init(name: name)
    }
}
</code></pre>

<p>我们定义了三个类，一个父类，两个子类。</p>

<pre><code class="swift">let library = [
    Movie(name: "Casablanca", director: "Michael Curtiz"),
    Song(name: "Blue Suede Shoes", artist: "Elvis Presley"),
    Movie(name: "Citizen Kane", director: "Orson Welles"),
    Song(name: "The One And Only", artist: "Chesney Hawkes"),
    Song(name: "Never Gonna Give You Up", artist: "Rick Astley")
]
// the type of "library" is inferred to be [MediaItem]
</code></pre>

<p>我们又定义了一个数组，里面包含了一些实例。注意，这个数组的类型是[MediaItem]。当我们遍历数组时，得到的对象也是MediaItem,我们需要向下转换到具体的类。</p>

<h3>检查类型</h3>

<p>使用 is 操作符来检查实例是否是某个特定类的实例。如果是就返回true，如果不是就返回false。</p>

<pre><code class="swift">var movieCount = 0
var songCount = 0
for item in library {
    if item is Movie {
        ++movieCount
    } else if item is Song {
        ++songCount
    }
}
println("Media library contains \(movieCount) movies and \(songCount) songs")
// prints "Media library contains 2 movies and 3 songs"
</code></pre>

<p>上面的代码，我们遍历整个数组，判断每个实例的类型，然后分别计算出有多少电影，多少歌曲。</p>

<h3>向下转换（Downcasting）</h3>

<p>一个类型的变量或常量，事实上有可能指向一个这个类的子类。我们可以尝试使用as操作符来尝试向下转换。</p>

<p>因为向下转换可能失败，所以转换操作符有两种形式。as？，返回一个optional。as，尝试转换并强制解包。</p>

<p>当我们不确定实例的类型能否转换成功时，使用as？来做。如果失败了，会返回一个nil。</p>

<p>只有当我们确认实例的类型能够转换成功时，才使用as来做。如果使用了as，却转换失败，会造成运行时错误。</p>

<pre><code class="swift">for item in library {
    if let movie = item as? Movie {
        println("Movie: '\(movie.name)', dir. \(movie.director)")
    } else if let song = item as? Song {
        println("Song: '\(song.name)', by \(song.artist)")
    }
}
// Movie: 'Casablanca', dir. Michael Curtiz
// Song: 'Blue Suede Shoes', by Elvis Presley
// Movie: 'Citizen Kane', dir. Orson Welles
// Song: 'The One And Only', by Chesney Hawkes
// Song: 'Never Gonna Give You Up', by Rick Astley
</code></pre>

<p>上面的代码中，我们尝试把每个实例向下转换到具体的类型。使用as？，然后使用optional绑定来使用真实的值。</p>

<pre><code>注意
转换并不会修改实例或它的值。底层的实例没有改变，只是简单的被当做另一个类型来使用。
</code></pre>

<h3>Any和AnyObject类型转到</h3>

<p>Swift提供了两种比较宽泛的类型：</p>

<ul>
<li>AnyObject可以表示任何类类型的实例</li>
<li><p>Any可以表示任何类型，包括函数类型</p>

<pre><code>注意
仅当需要时在使用Any和AnyObject，尽可能的明确出实例的类型。
</code></pre></li>
</ul>


<h4>AnyObject</h4>

<p>当使用Cocoa的API时，我们经常接收到一个数组类型是[AnyObject]的数组，这是因为ObjC没有指定类型的数组。然而，我们事实上通过API的信息是比较确定数组里元素的类型的。</p>

<p>在这种情况下，我们可以使用as来直接把数组元素向下转换到特定的类型来使用。</p>

<pre><code class="swift">let someObjects: [AnyObject] = [
    Movie(name: "2001: A Space Odyssey", director: "Stanley Kubrick"),
    Movie(name: "Moon", director: "Duncan Jones"),
    Movie(name: "Alien", director: "Ridley Scott")
]
</code></pre>

<p>因为数组里全是Moive类型的实例，所以我们可以直接使用as。</p>

<pre><code class="swift">for object in someObjects {
    let movie = object as Movie
    println("Movie: '\(movie.name)', dir. \(movie.director)")
}
// Movie: '2001: A Space Odyssey', dir. Stanley Kubrick
// Movie: 'Moon', dir. Duncan Jones
// Movie: 'Alien', dir. Ridley Scott
</code></pre>

<p>我们甚至可以直接把数组向下转换到[Movie]来操作：</p>

<pre><code class="swift">for movie in someObjects as [Movie] {
    println("Movie: '\(movie.name)', dir. \(movie.director)")
}
// Movie: '2001: A Space Odyssey', dir. Stanley Kubrick
// Movie: 'Moon', dir. Duncan Jones
// Movie: 'Alien', dir. Ridley Scott
</code></pre>

<h4>Any</h4>

<p>下面的例子里，我们使用Any来操作一个混合类型的数组，可以包括函数类型，和非类类型。</p>

<pre><code class="swift">var things = [Any]()
things.append(0)
things.append(0.0)
things.append(42)
things.append(3.14159)
things.append("hello")
things.append((3.0, 5.0))
things.append(Movie(name: "Ghostbusters", director: "Ivan Reitman"))
things.append({ (name: String) -&gt; String in "Hello, \(name)" })
</code></pre>

<p>数组thing包含了两个Int，两个Double，一个String，一个元组，一个Movie，一个闭包。</p>

<p>我们可以使用is和as用一个switch来处理这个数组：</p>

<pre><code class="swift">for thing in things {
    switch thing {
    case 0 as Int:
        println("zero as an Int")
    case 0 as Double:
        println("zero as a Double")
    case let someInt as Int:
        println("an integer value of \(someInt)")
    case let someDouble as Double where someDouble &gt; 0:
        println("a positive double value of \(someDouble)")
    case is Double:
        println("some other double value that I don't want to print")
    case let someString as String:
        println("a string value of \"\(someString)\"")
    case let (x, y) as (Double, Double):
        println("an (x, y) point at \(x), \(y)")
    case let movie as Movie:
        println("a movie called '\(movie.name)', dir. \(movie.director)")
    case let stringConverter as String -&gt; String:
        println(stringConverter("Michael"))
    default:
        println("something else")
    }
}
// zero as an Int
// zero as a Double
// an integer value of 42
// a positive double value of 3.14159
// a string value of "hello"
// an (x, y) point at 3.0, 5.0
// a movie called 'Ghostbusters', dir. Ivan Reitman
// Hello, Michael
</code></pre>

<pre><code>注意
在switch里我们使用as而不是as？来检查和转换类型。在switch里这样做总是安全的。
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Language Guide: Optional Chaining]]></title>
    <link href="http://zxhfirefox.github.io/blog/2014/10/25/language-guide-optional-chaining/"/>
    <updated>2014-10-25T10:22:10+08:00</updated>
    <id>http://zxhfirefox.github.io/blog/2014/10/25/language-guide-optional-chaining</id>
    <content type="html"><![CDATA[<p>Optional链条是一种在一个optional上查询，调用属性，方法和角标得时候，这个optional的值可能是nil得一种操作。如果这个optional有值，那么属性，方法，角标的调用会成功，如果optional是nil，属性，方法，角标的调用返回nil。多个查询可以链接在一起，整个链接在有任何一个地方为nil时简单的返回失败。</p>

<pre><code>注意
Optional链条有点类似于ObjC中给nil发送消息，但是它可以使用在任何类型上，而且也可以检查成功或失败。
</code></pre>

<!-- more -->


<h3>Optional链条作为强制解包的替换方案</h3>

<p>我们在我们期望的属性，方法，角标后面加？来表示optional链条。这和在一个optional值的后面加！来强制解包很相似。主要区别在于如果optional值为nil，链条会简单的失败，而强制解包会触发运行时错误。</p>

<p>为了反映optional链条可以调用在一个nil上，整个链条的返回值都是一个optional的值，即使你访问的属性，方法，角标并不是optional的。我们可以使用这个返回值来检查optional链条的调用是否成功，或者因为有nil值而没有成功。</p>

<p>特别的，optional链条调用的结果和预期的结果类型相同，包裹在一个optional里。一个返回Int的属性会返回Int？。</p>

<pre><code class="swift">class Person{
    var residence: Residence?
}
class Residence {
    var numberOfRooms = 1
}
</code></pre>

<p>我们定义了两个类。</p>

<pre><code class="swift">let john = Person()
</code></pre>

<p>创建一个Person对象，这时候它的residence是nil。如果我们强制访问residence的numberOfRooms属性就会触发运行时错误。</p>

<pre><code class="swift">let roomCount = john.residence!.numberOfRooms
// this triggers a runtime error
</code></pre>

<p>然而，我们使用optional链条来处理这个：</p>

<pre><code class="swift">if let roomCount = john.residence?.numberOfRooms {
    println("John's residence has \(roomCount) room(s).")
} else {
    println("Unable to retrieve the number of rooms.")
}
// prints "Unable to retrieve the number of rooms."
</code></pre>

<p>因为residence是nil，所以optional链条失败，返回nil。</p>

<p>如果我们给residence附值。</p>

<pre><code class="swift">john.residence = Residence()
if let roomCount = john.residence?.numberOfRooms {
    println("John's residence has \(roomCount) room(s).")
} else {
    println("Unable to retrieve the number of rooms.")
}
// prints "John's residence has 1 room(s)."
</code></pre>

<p>optional链条就成功了，返回了正确的numberOfRooms。</p>

<h3>为optional链条定义模型类</h3>

<p>我们多层次的使用optional链条来调用属性，方法，角标。这使得你可以不断向下的访问复杂的模型类的属性，并且检查是否可以访问属性，方法，角标。</p>

<pre><code class="swift">class Person {
    var residence: Residence?
}
class Residence {
    var rooms = [Room]()
    var numberOfRooms: Int {
        return rooms.count
    }
    subscript(i: Int) -&gt; Room {
        get {
            return rooms[i]
        }
        set {
            rooms[i] = newValue
        }
    }
    func printNumberOfRooms() {
        println("The number of rooms is \(numberOfRooms)")
    }
    var address: Address?
}
</code></pre>

<p>这次，我们的Residence有多个Room，所以numberOfRooms成为了一个计算属性。并实现了角标访问来访问或设置Room。最后，它还有一个optional的Address。</p>

<pre><code class="swift">class Room {
    let name: String
    init(name: String) { self.name = name }
}
class Address {
    var buildingName: String?
    var buildingNumber: String?
    var street: String?
    func buildingIdentifier() -&gt; String? {
        if buildingName != nil {
            return buildingName
        } else if buildingNumber != nil {
            return buildingNumber
        } else {
            return nil
        }
    }
}
</code></pre>

<p>我们定义了Room和Address类，Address类有3个optional的属性，和一个返回optional的String的方法。</p>

<h3>通过optional链条访问属性</h3>

<p>我们可以通过optional链条来访问一个optional值的属性，并检查访问是否成功。</p>

<pre><code class="swift">let john = Person()
if let roomCount = john.residence?.numberOfRooms {
    println("John's residence has \(roomCount) room(s).")
} else {
    println("Unable to retrieve the number of rooms.")
}
// prints "Unable to retrieve the number of rooms."
</code></pre>

<p>上面的例子和之前一样，因为没有residence，所以没有办法访问房间数。</p>

<pre><code class="swift">let someAddress = Address()
someAddress.buildingNumber = "29"
someAddress.street = "Acacia Road"
john.residence?.address = someAddress
</code></pre>

<p>这次，我们通过optional链条来给属性附值，但是因为residence是nil，所以附值依然是失败的。</p>

<h3>通过optional链条调用方法</h3>

<p>我们可以用optional链条来调用一个optional值的方法，然后检查调用是否成功。即使这个方法不返回值，我们也能这么做。</p>

<p>Residence的printNumberOfRooms方法，没有给出返回值。</p>

<p>但是，没有给出返回值的方法其实是返回了Void类型，这意味着他们返回了一个空元组()。</p>

<p>如果我们把这个方法调用在optional链条时，这个方法会返回Void？，而不是Void。这样我们可以用if语句来检查我们能不能调用printNumberOfRooms方法即便方法自己没有定义返回值。</p>

<pre><code class="swift">if john.residence?.printNumberOfRooms() != nil {
    println("It was possible to print the number of rooms.")
} else {
    println("It was not possible to print the number of rooms.")
}
// prints "It was not possible to print the number of rooms."
</code></pre>

<p>任何尝试通过optional链条设置属性的操作都会返回一个Void？，我们可以用来检查设置属性是否成功：</p>

<pre><code class="swift">if (john.residence?.address = someAddress) != nil {
    println("It was possible to set the address.")
} else {
    println("It was not possible to set the address.")
}
// prints "It was not possible to set the address."
</code></pre>

<h3>通过optional链条访问角标</h3>

<p>我们可以通过在optional的值上使用optional链条来获取或设置角标的值，并且检查是否成功。</p>

<pre><code>注意
当我们使用optional链条来访问角标值的时候我们总是把？放在方括号的前面。事实上，optional链条的？总是紧跟着optional的值。
</code></pre>

<pre><code class="swift">if let firstRoomName = john.residence?[0].name {
    println("The first room name is \(firstRoomName).")
} else {
    println("Unable to retrieve the first room name.")
}
// prints "Unable to retrieve the first room name."
</code></pre>

<p>？紧跟在residence后面，因为residence是我们要检查的optional值。</p>

<pre><code class="swift">john.residence?[0] = Room(name: "Bathroom")
</code></pre>

<p>通过角标设置也是，这个操作也是失败的，因为residence是nil。</p>

<pre><code class="swift">let johnsHouse = Residence()
johnsHouse.rooms.append(Room(name: "Living Room"))
johnsHouse.rooms.append(Room(name: "Kitchen"))
john.residence = johnsHouse
if let firstRoomName = john.residence?[0].name {
    println("The first room name is \(firstRoomName).")
} else {
    println("Unable to retrieve the first room name.")
}
// prints "The first room name is Living Room."
</code></pre>

<p>在我们给residence附值之后，optional链条的操作就会成功。</p>

<h4>访问optional类型的角标</h4>

<p>如果一个角标的返回值是optional，那我们在使用optional链条时需要把？放到方括号的后面。</p>

<pre><code class="swift">var testScores = ["Dave": [86, 82, 84], "Bev": [79, 94, 81]]
testScores["Dave"]?[0] = 91
testScores["Bev"]?[0]++
testScores["Brian"]?[0] = 72
// the "Dave" array is now [91, 82, 84] and the "Bev" array is now [80, 94, 81]
</code></pre>

<h3>连接多个层次的链条</h3>

<p>我们多层次的使用optional链条来访问深入访问模型的方法，属性和角标。但是，多层次的optional并不会增加多层次的optional值。</p>

<p>换句话说：</p>

<ul>
<li>如果我们获取的类型不是optional的，它会变成optional。</li>
<li>如果获取的已经是optional的，它不会变的更加optional。</li>
</ul>


<p>因此：</p>

<ul>
<li>如果我们访问的返回值是Int，返回它会返回Int？</li>
<li>如果我们访问的已经是Int？，那么返回的就是Int？</li>
</ul>


<pre><code class="swift">if let johnsStreet = john.residence?.address?.street {
    println("John's street name is \(johnsStreet).")
} else {
    println("Unable to retrieve the address.")
}
// prints "Unable to retrieve the address."
</code></pre>

<p>这里，我们连续的使用optional链条来访问street属性。而street属性本身就是String？的，所以整个链条返回的类型也是String？。</p>

<pre><code class="swift">let johnsAddress = Address()
johnsAddress.buildingName = "The Larches"
johnsAddress.street = "Laurel Street"
john.residence!.address = johnsAddress
if let johnsStreet = john.residence?.address?.street {
    println("John's street name is \(johnsStreet).")
} else {
    println("Unable to retrieve the address.")
}
// prints "John's street name is Laurel Street."
</code></pre>

<h3>链接到有optional返回值的方法</h3>

<p>上面的例子是我们通过optional链条来尝试访问一个optional类型的属性。</p>

<p>我们也可以把一个返回optional值的方法链接到链条里。</p>

<pre><code class="swift">if let buildingIdentifier = john.residence?.address?.buildingIdentifier() {
    println("John's building identifier is \(buildingIdentifier).")
}
// prints "John's building identifier is The Larches."
</code></pre>

<p>我们也可以继续把更多的方法链接到一起。</p>

<pre><code class="swift">if let beginsWithThe =
    john.residence?.address?.buildingIdentifier()?.hasPrefix("The") {
        if beginsWithThe {
            println("John's building identifier begins with \"The\".")
        } else {
            println("John's building identifier does not begin with \"The\".")
        }
}
// prints "John's building identifier begins with "The"."
</code></pre>

<pre><code>注意
注意?在括弧的后面。
</code></pre>
]]></content>
  </entry>
  
</feed>

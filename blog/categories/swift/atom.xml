<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: swift | zxhfirefox's Blog]]></title>
  <link href="http://zxhfirefox.github.io/blog/categories/swift/atom.xml" rel="self"/>
  <link href="http://zxhfirefox.github.io/"/>
  <updated>2014-10-19T00:41:46+08:00</updated>
  <id>http://zxhfirefox.github.io/</id>
  <author>
    <name><![CDATA[zxhfirefox]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Language Guide: Deinitialization]]></title>
    <link href="http://zxhfirefox.github.io/blog/2014/10/19/language-guide-u-deinit/"/>
    <updated>2014-10-19T00:40:13+08:00</updated>
    <id>http://zxhfirefox.github.io/blog/2014/10/19/language-guide-u-deinit</id>
    <content type="html"><![CDATA[<p>一个反初始化函数在类实例被销毁之前调用。我们用 deinit关键字来写反初始化函数。反初始化函数只有类类型有。</p>

<h5>反初始化函数原理</h5>

<p>Swift自动把不在使用的实例销毁，并释放资源。Swift使用ARC来做内存管理。一般来讲，我们不需要手动的释放资源。不过，如果我们自己处理了一些资源，我们可能就需要自己做一些清理工作。</p>

<p>每个类，最多只有一个 deinit 方法。 没有任何参数。</p>

<pre><code class="swift"> deinit {
 }
</code></pre>

<p>反初始化函数自动在对象销毁前调用。你不能自己手动调用，父类的反初始化函数会被继承，而且在子类的实现末尾自动调用。即使子类不提供反初始化函数，父类的也会的调用。</p>

<p>因为在销毁之前调用反初始化函数，所以在反初始化函数里，所偶的属性都还可以访问。</p>

<h5>反初始化函数实战</h5>

<pre><code class="swift">struct Bank {
    static var coinsInBank = 10_000
    static func vendCoins(var numberOfCoinsToVend: Int) -&gt; Int {
        numberOfCoinsToVend = min(numberOfCoinsToVend, coinsInBank)
        coinsInBank -= numberOfCoinsToVend
        return numberOfCoinsToVend
    }
    static func receiveCoins(coins: Int) {
        coinsInBank += coins
    }
}
</code></pre>

<pre><code class="swift">class Player {
    var coinsInPurse: Int
    init(coins: Int) {
        coinsInPurse = Bank.vendCoins(coins)
    }
    func winCoins(coins: Int) {
        coinsInPurse += Bank.vendCoins(coins)
    }
    deinit {
        Bank.receiveCoins(coinsInPurse)
    }
}
</code></pre>

<pre><code class="swift">var playerOne: Player? = Player(coins: 100)
println("A new player has joined the game with \(playerOne!.coinsInPurse) coins")
// prints "A new player has joined the game with 100 coins"
println("There are now \(Bank.coinsInBank) coins left in the bank")
// prints "There are now 9900 coins left in the bank"
</code></pre>

<pre><code class="swift">playerOne!.winCoins(2_000)
println("PlayerOne won 2000 coins &amp; now has \(playerOne!.coinsInPurse) coins")
// prints "PlayerOne won 2000 coins &amp; now has 2100 coins"
println("The bank now only has \(Bank.coinsInBank) coins left")
// prints "The bank now only has 7900 coins left"
</code></pre>

<pre><code class="swift">playerOne = nil
println("PlayerOne has left the game")
// prints "PlayerOne has left the game"
println("The bank now has \(Bank.coinsInBank) coins")
// prints "The bank now has 10000 coins"
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Language Guide: Initialization]]></title>
    <link href="http://zxhfirefox.github.io/blog/2014/10/19/language-guide-t-init/"/>
    <updated>2014-10-19T00:39:16+08:00</updated>
    <id>http://zxhfirefox.github.io/blog/2014/10/19/language-guide-t-init</id>
    <content type="html"><![CDATA[<p>初始化是让一个类，结构体，枚举的实例变的可用的过程。这个过程包含了把实例上的每一个存储属性都给与一个初始值，还有任何的确保在实例可以被使用前需要做的工作。</p>

<p>我们使用初始化函数来做初始化，初始化函数是一种特殊的函数，在实例被创建时，它会被调用。和ObjC的初始化函数不同，Swift的初始化函数不返回值。他们的主要目的就是确保这个新的实例在被使用之前正确的初始化。</p>

<p>类类型的实例也可以实现反初始化函数，它在实例被销毁时可以用来做任何的清理工作。</p>

<h5>为存储属性设置初始值</h5>

<p>类和结构体必须在实例被使用前为所有的存储属性设置初始值。存储属性不能处于未决定的状态。</p>

<p>我们可以在初始化函数给存储属性初始值，也可以在定义属性时给出初始值。</p>

<pre><code>注意
在初始化函数里给属性附值和定义属性时给出初始值，都不会触发属性观察者
</code></pre>

<h6>初始化函数</h6>

<p>初始化函数在创建一个类型的实例后被调用，一个最简单的初始化函数就像一个实例方法，没有参数，函数名是 init 关键字。</p>

<pre><code class="swift">init(){
}
</code></pre>

<p>例如：</p>

<pre><code class="swift">struct Fahrenheit {
    var temperature: Double
    init() {
        temperature = 32.0
    }
}
var f = Fahrenheit()
println("The default temperature is \(f.temperature)° Fahrenheit")
</code></pre>

<h6>默认属性值</h6>

<p>我们可以像上面的例子里那样在初始化函数里设置属性初始值。也可以在属性定义时给出初始值。</p>

<pre><code>注意
如果一个属性总是有着同样的初始值，我们应该在属性定义时给出初始值，而不是在初始化函数里给出。
</code></pre>

<p>我们把上面的例子可以改写为：</p>

<pre><code class="swift">struct Fahrenheit {
    var temperature = 32.0
}
</code></pre>

<h5>自定义初始化</h5>

<p>我们可以通过给出输入参数，或optional的属性类型，或是在初始化时改变常量属性来自定义初始化过程。</p>

<h6>初始化参数</h6>

<p>我们可以给初始化函数定义参数，初始化参数的能力和函数，方法的一样。</p>

<pre><code class="swift">struct Celsius {
    var temperatureInCelsius: Double
    init(fromFahrenheit fahrenheit: Double) {
        temperatureInCelsius = (fahrenheit - 32.0) / 1.8
    }
    init(fromKelvin kelvin: Double) {
        temperatureInCelsius = kelvin - 273.15
    }
}
let boilingPointOfWater = Celsius(fromFahrenheit: 212.0)
// boilingPointOfWater.temperatureInCelsius is 100.0
let freezingPointOfWater = Celsius(fromKelvin: 273.15)
// freezingPointOfWater.temperatureInCelsius is 0.0
</code></pre>

<p>上面的例子里，两个初始化函数接受不同的温度值，分别转换到Celsius温度。</p>

<h6>本地和外部参数名</h6>

<p>和函数，方法一样，初始化参数也可以本地参数名和外部参数名。</p>

<p>然而，初始化函数并不像函数和方法一样，有一个函数名。因此，参数的名字和类型将决定哪一个初始化函数被调用。因此，如果我们不给出外部参数名子，Swift会默认给每一个参数一个外部名字。这个外部名字和本地名字一样，就好像你给每个参数都写 # 一样。</p>

<pre><code class="swift">struct Color {
    let red, green, blue: Double
    init(red: Double, green: Double, blue: Double) {
        self.red   = red
        self.green = green
        self.blue  = blue
    }
    init(white: Double) {
        red   = white
        green = white
        blue  = white
    }
}
let magenta = Color(red: 1.0, green: 0.0, blue: 1.0)
let halfGray = Color(white: 0.5)
</code></pre>

<p>注意，我们无法不给外部参数名字来调用初始化函数，即使我们可以通过参数个数来确定使用哪个初始化函数。</p>

<pre><code class="swift">let veryGreen = Color(0.0, 1.0, 0.0)
// this reports a compile-time error - external names are required
</code></pre>

<h6>没有外部名字的初始化参数</h6>

<p>如果你真的不像给出初始化参数的外部名字， 使用 _ 来作为外部参数名字给出。</p>

<pre><code class="swift">struct Celsius {
    var temperatureInCelsius: Double
    init(fromFahrenheit fahrenheit: Double) {
        temperatureInCelsius = (fahrenheit - 32.0) / 1.8
    }
    init(fromKelvin kelvin: Double) {
        temperatureInCelsius = kelvin - 273.15
    }
    init(_ celsius: Double) {
        temperatureInCelsius = celsius
    }
}
let bodyTemperature = Celsius(37.0)
// bodyTemperature.temperatureInCelsius is 37.0
</code></pre>

<p>因为外部参数名字是 _ ，所以可以直接调用，而不给出参数名字。</p>

<h6>optional的属性类型</h6>

<p>如果我们自定义的类型有一个存储属性在逻辑上可能没有值，或许因为它的值在初始化时还不能确定，或许因为它在某些时刻允许没有值，我们把它声明为optional的属性。optional的属性默认被初始化为 nil，表明这个属性在初始化时没有值。</p>

<pre><code class="swift">class SurveyQuestion {
    var text: String
    var response: String?
    init(text: String) {
        self.text = text
    }
    func ask() {
        println(text)
    }
}
let cheeseQuestion = SurveyQuestion(text: "Do you like cheese?")
cheeseQuestion.ask()
// prints "Do you like cheese?"
cheeseQuestion.response = "Yes, I do like cheese."
</code></pre>

<p>上面的例子里，response是一个optional的字符串。</p>

<h6>在初始化阶段修改常量属性的值</h6>

<p>我们可以再初始化阶段修改一个常量属性的值，只要在初始化结束之前给它一个值。</p>

<pre><code>注意
对于类实例，一个常量属性只能在定义属性的类的初始化过程里被修改，而不能在子类里被修改。
</code></pre>

<pre><code class="swift">class SurveyQuestion {
    let text: String
    var response: String?
    init(text: String) {
        self.text = text
    }
    func ask() {
        println(text)
    }
}
let beetsQuestion = SurveyQuestion(text: "How about beets?")
beetsQuestion.ask()
// prints "How about beets?"
beetsQuestion.response = "I also like beets. (But not with cheese.)"
</code></pre>

<p>我们text属性改为常量，来表示问题并会改变。虽然他是常量，但是初始化过程中还是可以被改变。</p>

<h5>默认初始化函数</h5>

<p>对于任意的结构体或基类，当他们的所有属性都一个默认值，并且没有给出任何初始化函数的时候，Swift给出一个默认初始化函数。这个初始化函数就是简单的把所有的默认值附值给属性。</p>

<pre><code class="swift">class ShoppingListItem {
    var name: String?
    var quantity = 1
    var purchased = false
}
var item = ShoppingListItem()
</code></pre>

<p>因为ShoppingListItem的所有属性都有默认值，而且他还没有基类，也没给出自己的初始化函数，Swift会为它提供一个默认的初始化函数。</p>

<h6>结构体类型的按成员的初始化函数</h6>

<p>结构体对象如果没有给出自己的初始化函数，将得到一个默认的按成员初始化的初始化函数。即使有些属性并没有给出默认值。</p>

<p>按成员初始化的初始化函数是一种初始化结构体的一种简写，初始值根据名字传递给初始化函数。</p>

<pre><code class="swift">struct Size {
    var width = 0.0, height = 0.0
}
let twoByTwo = Size(width: 2.0, height: 2.0)
</code></pre>

<h5>值类型的初始化代理</h5>

<p>初始化函数可以调用其他初始化函数来执行初始化过程，这种方式叫做初始化代理，可以避免重复代码。</p>

<p>初始化代理如果工作，那种形式的代理是可以的，在值类型和类类型是不一样的。值类型，不支持继承，所以他们的初始化代理比较简单，因为他们只能把初始化代理给其他的由他们自己提供的初始化函数。然而，类，可以从其他类继承。这就意味着类有着额外的责任来确保他们继承的属性也被初始化。</p>

<p>对于值类型，self.init 来引用其他的初始化函数， self.init只能在一个初始化函数里被调用。</p>

<p>如果我们给值类型定义了自定义的初始化函数，那么我们就无法再访问默认的初始化函数。这个限制是为了防止我们有额外的初始化步骤，而有时候不小心使用了默认的初始化函数来初始化了实例。</p>

<pre><code>注意
如果我们希望使用默认的初始化函数，还想定义自定义的初始化函数，我们可以把自定义的初始化函数写在扩展里。
</code></pre>

<pre><code class="swift">struct Size {
    var width = 0.0, height = 0.0
}
struct Point {
    var x = 0.0, y = 0.0
}
struct Rect {
    var origin = Point()
    var size = Size()
    init() {}
    init(origin: Point, size: Size) {
        self.origin = origin
        self.size = size
    }
    init(center: Point, size: Size) {
        let originX = center.x - (size.width / 2)
        let originY = center.y - (size.height / 2)
        self.init(origin: Point(x: originX, y: originY), size: size)
    }
}
</code></pre>

<p>第一个init，就相当于默认初始化函数。
第二个init，相当于按成员来初始化的初始化函数。
第三个init，是我们自己的，相对复杂的初始化函数。</p>

<pre><code class="swift">let basicRect = Rect()
// basicRect's origin is (0.0, 0.0) and its size is (0.0, 0.0)
let originRect = Rect(origin: Point(x: 2.0, y: 2.0),
    size: Size(width: 5.0, height: 5.0))
// originRect's origin is (2.0, 2.0) and its size is (5.0, 5.0)
let centerRect = Rect(center: Point(x: 4.0, y: 4.0),
    size: Size(width: 3.0, height: 3.0))
// centerRect's origin is (2.5, 2.5) and its size is (3.0, 3.0)
</code></pre>

<h5>类继承和初始化</h5>

<p>一个类的所有的存储属性，包括任何继承的属性，都必须在初始化过程中被初始化。</p>

<p>Swift定义了两种初始化函数来简化并确保所有的属性都被初始化，叫做指定初始化函数和便利初始化函数。</p>

<h6>指定初始化函数和便利初始化函数</h6>

<p>指定初始化函数是一个类的基本初始化函数。一个指定初始化函数初始化一个类所有属性，并且调用父类的初始化函数来完成初始化过程。</p>

<p>类应该只有很少的指定初始化函数，很多情况下只有一个。指定初始化函数是初始化过程的&#8221;漏斗&#8221;位置，经过它来进入父类的初始化链。</p>

<p>每个类至少有一个指定初始化函数。有些时候，这个是从父类继承了一个或多个指定初始化函数。</p>

<p>便利初始化函数是辅助的初始化函数。我们可以定一个便利初始化函数来调用同一个类的指定初始化函数，并给它一些属性的默认值。我们也可以定义便利初始化函数来给一个实例某些特殊的值。</p>

<p>如果我们不需要，我们可以不给出任何的便利初始化函数。当我们需要时，我们定义便利初始化函数来明确和简化我们的代码。</p>

<h6>语法</h6>

<p>指定初始化函数和值类型的普通初始化函数语法一样</p>

<pre><code class="swift">init( [parameters]){
    [statements]
}
</code></pre>

<p>便利初始化函数写法基本一致，但是需要用 convenience 来标示出来。</p>

<pre><code class="swift">convenience init([parameters]) {
    [statements]
}
</code></pre>

<p>注：  []并不是数组。</p>

<h6>类类型的初始化代理</h6>

<p>为了简化指定初始化函数和便利初始化函数之间的关系，Swift使用下面3条规则。</p>

<ol>
<li>一个指定的初始化函数必须调用它的直接父类的一个指定初始化函数。</li>
<li>一个便利的初始化函数必须调用它自己同一个类的另一个初始化函数。</li>
<li>一个便利的初始化函数必须最终调用一个指定的初始化函数。</li>
</ol>


<p>简单来讲就是：</p>

<ul>
<li>指定的初始化函数需要向上代理</li>
<li>便利的初始化函数必须横向代理</li>
</ul>


<p>注： 有两张图片比较清楚对这一概念给出例子。</p>

<h6>两步初始化</h6>

<p>在Swift的类初始化里，有两步，第一步，每一个由定义这个属性类给出的存储属性被初始化。第二步，每一个类都可以进一步的修改这些属性来使得实例可用。</p>

<p>这种方式可以确保初始化安全，并且仍然提供了在类继承里完整的灵活度。两步初始化防止了某些属性在被初始化之前就被使用了，也防止了某个属性被其他的初始化函数修改。</p>

<pre><code>注意
Swift的两步初始化和ObjC的很相似，主要区别在于第一步里，ObjC会把0或nil附值给每个属性，而Swift更灵活的可以把自定义的初始值附值给属性。
</code></pre>

<p>Swift编译器会做4种检查来确保两步初始化没有错误。</p>

<ol>
<li>一个指定的初始化函数必须确保在调用父类初始化之前，自己的所有属性都被初始化。</li>
<li>一个指定的初始化函数在给继承的属性附值之前，必须调用父类的初始化函数。</li>
<li>一个便利初始化函数必须在给属性附值之前调用另外的初始化函数，如果不这样，这个属性的值会被覆盖。</li>
<li>一个初始化函数在第一步完成之前，不能调用任何的实例方法，不能读取任何属性，也不能把self作为值来引用。</li>
</ol>


<p>一个实例在第一步结束之前都不算完整初始化，而方法，属性只有在第一步结束后才能访问。</p>

<p>下面就是两步初始化如何进行的：</p>

<p>第一步：</p>

<ul>
<li>一个指定的或便利的初始化函数被调用。</li>
<li>这个实例的内存被分配，但没有初始化。</li>
<li>一个指定的初始化确保所有的由当前类引进的属性被初始化。</li>
<li>这个指定的初始化函数向上代理调用父类的初始化函数，让父类进行初始化。</li>
<li>这一步骤一直进行直到没有父类。</li>
<li>直到继承链的顶端，最后的父类把自己的属性都初始化完毕之后，那么这个实例的内存就被初始化完毕。第一阶段结束。</li>
</ul>


<p>第二步：</p>

<ul>
<li>从继承链顶端往下，每个指定的初始化函数可以自定义属性的值。这时候，初始化函数可以访问 self，也可以修改属性值，调用方法等等。</li>
<li>最终，任何的便利方法可以修改属性的值以及使用self。</li>
</ul>


<h6>初始化函数继承和重写</h6>

<p>和ObjC不同，Swift子类默认不继承他们父类的初始化函数。这样可以避免，如果子类从父类继承了一个简单的初始化函数，而是得子类的实例没有完全初始化。</p>

<pre><code>注意
父类的初始化函数只在特定情况下被继承了，需要确保安全。
</code></pre>

<p>如果你想给一个子类加一个和父类一样的初始化函数，你可以在子类重新给出实现。</p>

<p>如果你在子类写了一个和父类的指定的初始化函数一样的初始化函数，你实际上是重写了那个初始化函数，所以你必须加上 override 。即便你是重写了一个自动提供的默认初始化函数，也要写override。</p>

<p>和重写属性，方法，角标一样，override会使得编译器去检查是否和父类相匹配。</p>

<pre><code>注意
你应该在重写父类的指定的初始化函数时总是写上 override，即使你子类的实现是一个便利的初始化函数。
</code></pre>

<p>相反的，如果你重写的初始化函数和父类的一个便利初始化函数想匹配，那父类的便利初始化函数就永远不能在你的子类里被直接调用。因此，子类其实严格来说并没有重写父类的初始化函数，所以你可以不写 override。</p>

<pre><code class="swift">class Vehicle {
    var numberOfWheels = 0
    var description: String {
        return "\(numberOfWheels) wheel(s)"
    }
}
</code></pre>

<p>上面的例子，Vehicle给出了属性的默认值，也没有自定义初始化函数，也么有父类，那么它由一个默认的初始化函数。</p>

<pre><code class="swift">let vehicle = Vehicle()
println("Vehicle: \(vehicle.description)")
// Vehicle: 0 wheel(s)
</code></pre>

<p>我们定义一个子类</p>

<pre><code class="swift">class Bicycle: Vehicle {
    override init() {
        super.init()
        numberOfWheels = 2
    }
}
</code></pre>

<p>Bicycle定义了一个指定的初始化函数，这个初始化函数和父类的一个指定的初始化函数匹配，所以Bicycle的初始化函数被标记为 override。</p>

<p>Bicycle的init，调用了父类的init。然后修改了numberOfWheels的值。</p>

<pre><code>注意
子类可以在初始化时修改继承属性的值，但是只能修改变量属性，而不能修改常量属性。
</code></pre>

<h6>自动的初始化函数继承</h6>

<p>如上所述，子类默认不能从父类继承初始化函数。然而，如果特定情况满足，父类的初始化函数自动被继承。在实际使用中，这意味着你不需要大量的重写父类的初始化函数，而是可以从父类中安全的继承初始化函数。</p>

<p>假设我们在子类里给新加的属性提供默认值，下面两条规则会使用</p>

<ol>
<li>如果子类没有定义任何的制定的初始化函数，它会自动从父类继承所有的指定的初始化函数。</li>
<li>如果子类提供了父类的所有的指定的初始化函数的实现，不管是通过 1 还是自己给出实现，它都会自动继承所有的便利初始化函数。</li>
</ol>


<p>这2条规则，即使子类有自定义的便利初始化函数也一样适用。</p>

<pre><code>注意
一个子类可以把一个父类的指定初始化函数实现为一个子类的一个便利初始化函数来满足规则2.
</code></pre>

<h6>指定初始化函数和便利初始化函数实战</h6>

<p>下面的例子给出指定初始化函数，便利初始化函数，自动继承的初始化函数。</p>

<p>基类：</p>

<pre><code class="swift">class Food {
    var name: String
    init(name: String) {
        self.name = name
    }
    convenience init() {
        self.init(name: "[Unnamed]")
    }
}
</code></pre>

<p>Food定义了一个属性name。一个指定的初始化函数，一个便利的初始化函数，没有默认的初始化函数。</p>

<p>子类：</p>

<pre><code class="swift">class RecipeIngredient: Food {
    var quantity: Int
    init(name: String, quantity: Int) {
        self.quantity = quantity
        super.init(name: name)
    }
    override convenience init(name: String) {
        self.init(name: name, quantity: 1)
    }
}
</code></pre>

<p>RecipeIngredient定义了一个自己的指定的初始化函数，接受name和quantity参数。自己先把自己的quantity初始化，然后调用super来初始化父类。</p>

<p>RecipeIngredient它还定义了一个便利的初始化函数，接受name参数，因为这个初始化函数和父类的一个指定初始化函数相匹配，所以需要加上 override关键字。</p>

<p>尽管RecipeIngredient把父类的一个指定初始化函数重写为便利初始化函数，它也是实现了所有父类的指定初始化函数，所以它还继承了父类的所有便利初始化函数。因为RecipeIngredient的父类是Food，只有一个便利初始化函数，如果我们在RecipeIngredient调用这个初始化函数，会代理到RecipeIngredient，而不是Food。</p>

<pre><code class="swift">let oneMysteryItem = RecipeIngredient()
let oneBacon = RecipeIngredient(name: "Bacon")
let sixEggs = RecipeIngredient(name: "Eggs", quantity: 6)
</code></pre>

<p>第三个类：</p>

<pre><code class="swift">class ShoppingListItem: RecipeIngredient {
    var purchased = false
    var description: String {
        var output = "\(quantity) x \(name)"
        output += purchased ? " ✔" : " ✘"
        return output
    }
}
</code></pre>

<pre><code>注意
ShoppingListItem没有提供初始化函数来初始化purchased，因为东西从开始都是未购买的。
</code></pre>

<p>因为ShoppingListItem的属性都有默认值而且没有定义任何的初始化函数，那么它继承了所有的指定初始化函数和便利初始化函数。</p>

<pre><code class="swift">var breakfastList = [
    ShoppingListItem(),
    ShoppingListItem(name: "Bacon"),
    ShoppingListItem(name: "Eggs", quantity: 6),
]
breakfastList[0].name = "Orange juice"
breakfastList[0].purchased = true
for item in breakfastList {
    println(item.description)
}
// 1 x Orange juice ✔
// 1 x Bacon ✘
// 6 x Eggs ✘
</code></pre>

<h5>可失败的初始化函数</h5>

<p>有些时候，定义一个可失败的初始化函数是有意义的。这个失败可能是因为参数错误，或是缺少需要的参数，或者其他阻止初始化过程的情况。</p>

<p>我们在init后面加一个 ？ 来标示这个初始化函数可能失败。</p>

<pre><code>注意
你不能定义一个可失败的和不可失败的初始化函数，接受相同的参数类型和名字。
</code></pre>

<p>可失败的初始化函数创建一个optioanl的值。如果我们在可失败的初始化函数里写了 return nil，就意味着初始化失败了。</p>

<pre><code>注意
严格来讲，初始化函数不返回值。相反，他们的目的是确保 self 在初始化结束后是完整并正确可用的。 所以虽然我们使用 return nil 来表示初始化失败，但是不用在成功初始化时使用 return。
</code></pre>

<pre><code class="swift">struct Animal {
    let species: String
    init?(species: String) {
        if species.isEmpty { return nil }
        self.species = species
    }
}
let someCreature = Animal(species: "Giraffe")
// someCreature is of type Animal?, not Animal
if let giraffe = someCreature {
    println("An animal was initialized with a species of \(giraffe.species)")
}
// prints "An animal was initialized with a species of Giraffe"
let anonymousCreature = Animal(species: "")
// anonymousCreature is of type Animal?, not Animal
if anonymousCreature == nil {
    println("The anonymous creature could not be initialized")
}
// prints "The anonymous creature could not be initialized"
</code></pre>

<pre><code>注意
检查空字符串和检查 nil 是不一样的。
</code></pre>

<h6>枚举的可失败初始化函数</h6>

<p>我们可以使用可失败的初始化函数根据参数来从枚举成员里选择适当值。如果没有合适的值，我们就失败了。</p>

<pre><code class="swift">enum TemperatureUnit {
    case Kelvin, Celsius, Fahrenheit
    init?(symbol: Character) {
        switch symbol {
        case "K":
            self = .Kelvin
        case "C":
            self = .Celsius
        case "F":
            self = .Fahrenheit
        default:
            return nil
        }
    }
}
let fahrenheitUnit = TemperatureUnit(symbol: "F")
if fahrenheitUnit != nil {
    println("This is a defined temperature unit, so initialization succeeded.")
}
// prints "This is a defined temperature unit, so initialization succeeded."
let unknownUnit = TemperatureUnit(symbol: "X")
if unknownUnit == nil {
    println("This is not a defined temperature unit, so initialization failed.")
}
// prints "This is not a defined temperature unit, so initialization failed."
</code></pre>

<h6>有原始值的枚举的可失败初始化函数</h6>

<p>有原始值的枚举自动的有一个可失败的初始化函数，init?(rawValue:)。</p>

<pre><code class="swift">enum TemperatureUnit: Character {
    case Kelvin = "K", Celsius = "C", Fahrenheit = "F"
}
let fahrenheitUnit = TemperatureUnit(rawValue: "F")
if fahrenheitUnit != nil {
    println("This is a defined temperature unit, so initialization succeeded.")
}
// prints "This is a defined temperature unit, so initialization succeeded."
let unknownUnit = TemperatureUnit(rawValue: "X")
if unknownUnit == nil {
    println("This is not a defined temperature unit, so initialization failed.")
}
// prints "This is not a defined temperature unit, so initialization failed."
</code></pre>

<h6>类的可失败初始化函数</h6>

<p>一个值类型的可失败的初始化函数可以在初始化的任何阶段失败。</p>

<p>然而对于类，一个可失败的初始化函数，只能在所有的由当前类引进的存储属性都被初始化之后，并且任何的初始化代理开始后才能触发失败。</p>

<pre><code class="swift">class Product {
    let name: String!
    init?(name: String) {
        if name.isEmpty { return nil }
        self.name = name
    }
}
</code></pre>

<p>上面的例子，name属性是个optional的，所以有初始值 nil。是满足我们的要求的。</p>

<p>因为name是常量属性，所以我们一旦初始化成功，我们就可以确保name始终有值，可以不用去再检查。</p>

<pre><code class="swift">if let bowTie = Product(name: "bow tie") {
    // no need to check if bowTie.name == nil
    println("The product's name is \(bowTie.name)")
}
// prints "The product's name is bow tie"
</code></pre>

<h6>初始化失败的传递</h6>

<p>一个可失败的初始化函数可以代理到同一个类的其他的可失败的初始化函数，对于类，也可以代理到父类的可失败的初始化函数。</p>

<p>不论如何代理，如果一个可失败的初始化函数失败，那么整个初始化过程失败。</p>

<pre><code>注意
可失败的初始化函数也可以代理到一个不可失败的初始化函数。如果你需要在一个已有的初始化过程中添加一个潜在的失败的初始化函数，可以这种方式。
</code></pre>

<pre><code class="swift">class CartItem: Product {
    let quantity: Int!
    init?(name: String, quantity: Int) {
        super.init(name: name)
        if quantity &lt; 1 { return nil }
        self.quantity = quantity
    }
}
</code></pre>

<p>上面的例子中，quantity是optional的，初始值是nil。我们先调用了super.init(name: name) 来满足可失败的初始化函数的要求。如果name是空的，那么super.init就会失败，整个初始化就失败了。</p>

<pre><code class="swift">if let twoSocks = CartItem(name: "sock", quantity: 2) {
    println("Item: \(twoSocks.name), quantity: \(twoSocks.quantity)")
}
// prints "Item: sock, quantity: 2"
if let zeroShirts = CartItem(name: "shirt", quantity: 0) {
    println("Item: \(zeroShirts.name), quantity: \(zeroShirts.quantity)")
} else {
    println("Unable to initialize zero shirts")
}
// prints "Unable to initialize zero shirts"
if let oneUnnamed = CartItem(name: "", quantity: 1) {
    println("Item: \(oneUnnamed.name), quantity: \(oneUnnamed.quantity)")
} else {
    println("Unable to initialize one unnamed product")
}
// prints "Unable to initialize one unnamed product"
</code></pre>

<h6>重写可失败的初始化函数</h6>

<p>我们可以在子类里重写可失败的初始化函数，我们甚至可以在子类里把可失败的初始化函数重写为不可失败的初始化函数。</p>

<p>如果我们在子类里把一个父类的可失败的初始化函数重写为一个不可失败的初始化函数，那么我们就不能向上代理这个初始化函数。一个不可失败的初始化函数永远都不能代理到一个可失败的初始化函数。</p>

<pre><code>注意
我们可以把一个可失败的重写为一个不可失败的，相反则不行。
</code></pre>

<pre><code class="swift">class Document {
    var name: String?
    // this initializer creates a document with a nil name value
    init() {}
    // this initializer creates a document with a non-empty name value
    init?(name: String) {
        if name.isEmpty { return nil }
        self.name = name
    }
}
</code></pre>

<p>Document的名字可以是nil，但是不能为空字符串&#8221;&ldquo;。</p>

<pre><code class="swift">class AutomaticallyNamedDocument: Document {
    override init() {
        super.init()
        self.name = "[Untitled]"
    }
    override init(name: String) {
        super.init()
        if name.isEmpty {
            self.name = "[Untitled]"
        } else {
            self.name = name
        }
    }
}
</code></pre>

<p>AutomaticallyNamedDocument重写了可失败的init，但是因为AutomaticallyNamedDocument是自动提供名字的，所以它不会失败。</p>

<h6>init! 可失败初始化函数</h6>

<p>因为 init? 初始化一个 optional的值。</p>

<p>我们也可以使用 init! 来初始化一个自动解包的otpional的值。</p>

<p>我们可以在init? 和 init! 之前互相代理，也可以互相重写。我们也可以从 init 代理到 init!，但是这样做，如果init! 失败就会触发一个断言。</p>

<h5>必须的初始化函数</h5>

<p>在一个类的初始化函数前面加上 required 来表示任何的子类都必须实现这个初始化函数。</p>

<pre><code class="swift">class SomeClass {
    required init() {
        // initializer implementation goes here
    }
}
</code></pre>

<p>在子类里，你也必须加上 required 关键字，但是不需要写 override。</p>

<pre><code class="swift">class SomeSubclass: SomeClass {
    required init() {
        // subclass implementation of the required initializer goes here
    }
}
</code></pre>

<pre><code>注意
你需要显式的实现 required的初始化函数，如果你可以通过一个继承的初始化函数来实现。
</code></pre>

<h5>通过闭包或函数来设置默认的属性值</h5>

<p>如果一个存储属性的默认值需要一些自定义或是配置，我们可以使用闭包或全局函数来提供默认值。每当一个实例被创建，这个闭包或函数就被调用，返回值会设置给对应的属性。</p>

<p>这种类型的闭包和函数一般创建一个和属性类型一致的变量，然后返回这个变量。</p>

<pre><code class="swift">class SomeClass {
    let someProperty: SomeType = {
        // create a default value for someProperty inside this closure
        // someValue must be of the same type as SomeType
        return someValue
        }()
}
</code></pre>

<p>注意大括号后面的括弧，这是告诉Swift来执行这个闭包，如果不写括弧，其实是把闭包附值给了属性，而不是闭包执行的结果。</p>

<pre><code>注意
如果使用闭包来初始化属性，记得实例的其他的部分还没有被初始化，所以不能在闭包里使用其他属性，self也不能用，还不能调用实例方法。
</code></pre>

<pre><code class="swift">struct Checkerboard {
    let boardColors: [Bool] = {
        var temporaryBoard = [Bool]()
        var isBlack = false
        for i in 1...10 {
            for j in 1...10 {
                temporaryBoard.append(isBlack)
                isBlack = !isBlack
            }
            isBlack = !isBlack
        }
        return temporaryBoard
        }()
    func squareIsBlackAtRow(row: Int, column: Int) -&gt; Bool {
        return boardColors[(row * 10) + column]
    }
}
</code></pre>

<p>每当一个Checkerboard创建时，boardColors对应的闭包都会执行。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Language guide: Inheritance]]></title>
    <link href="http://zxhfirefox.github.io/blog/2014/10/19/language-guide-t-inheritance/"/>
    <updated>2014-10-19T00:38:17+08:00</updated>
    <id>http://zxhfirefox.github.io/blog/2014/10/19/language-guide-t-inheritance</id>
    <content type="html"><![CDATA[<p>一个类可以从其他类继承方法，属性和其他特性。当一个类继承另一个类的时候，我们把继承的类叫子类，把被继承的类叫父类。继承是Swift里类区别于其他类型非常重要的一个区别。</p>

<p>在Swift里，类可以调用和访问父类的方法，属性，角标，也可以通过他们自己重写这些方法，属性，角标来实现自己的行为。Swift会通过检查重写定义是否和父类匹配来帮助你检查重写的正确性。</p>

<p>类还可以给父类的属性添加观察者，来使得自己在父类属性变化的时候得到通知。观察者可以添加给任何属性，不论是存储的还是计算的。</p>

<h5>定义一个基类</h5>

<p>任何类，如果它没有从其他类继承，那它就是一个基类。</p>

<pre><code>注意
Swift的类并不是从一个全局基类继承的。
</code></pre>

<pre><code class="swift">class Vehicle {
    var currentSpeed = 0.0
    var descriptioin: String {
        return "traveling at \(currentSpeed) miles per hour"
    }
    func makeNoise(){
    }
}
</code></pre>

<p>上面的例子定义了一个Vehicle类。有1个存储属性，1个计算属性，1个实例方法。</p>

<pre><code class="swift">let someVehicle = Vehicle()
println("Vehicle: \(someVehicle.description)")
</code></pre>

<p>创建了一个实例，并调用了实例方法。</p>

<h5>子类</h5>

<p>子类是从一个父类继承的类。子类从父类继承特性，你也可以改进这些特性，也可以添加新的特性。</p>

<p>定义子类的语法如下：</p>

<pre><code class="swift">class SomeSubClass : SomeSuperClass {
}
</code></pre>

<p>我们定义一个Vehicle的子类：</p>

<pre><code class="swift">class Bicycle : Vehicle {
    var hasBasket = false
}
</code></pre>

<p>Bicycle类继承自Vehicle类，包含Vehicle所有的特性，并添加了自己新的属性hasBasket。</p>

<p>Bicycle也可以被其他类继承。</p>

<pre><code class="swift">class Tandem: Bicycle {
    var currentNumberOfPassengers = 0
}
</code></pre>

<p>Tandem继承了所有Bicyle的特性，也继承了所有Vehicle的特性。</p>

<h5>重写</h5>

<p>一个子类为一个从父类继承的方法，属性，角标提供自己的实现，叫做重写。</p>

<p>使用 override关键字来标示重写。这样做可以明确标示出你在重写而不是误操作。如果错误的使用了 override关键字，编译器会报错。</p>

<h6>访问父类的方法，属性和角标</h6>

<p>当你自己重写一个方法，属性或角标时，你或许需要访问父类的实现。例如，你可能只是在父类的实现基础上做一些改进。</p>

<p>对于这种情况，你可以使用 super 来访问父类的方法，属性，角标的实现。例如： super.someMethod(), super.someProperty, super[someIndex]。</p>

<h6>重写方法</h6>

<pre><code class="swift">class Train: Vehicle {
    override func makeNoise(){
        println("Choo Choo")
    }
}
</code></pre>

<h6>重写属性</h6>

<p>你可以重写一个父类的属性，或是给一个父类的属性添加观察者。</p>

<h6># 重写属性的getter和setter</h6>

<p>你可以重写任何一个继承的属性，不论是存储的还是计算的。对于子类来说，属性是计算的还是存储的时不知道的，子类只知道他继承了一个特定类型的属性以及它的名字。所有你必须正确的子类里给出类型和名字。</p>

<p>你可以把父类一个只读的属性在子类实现为可读可写的属性，但是你不能把父类一个可读可写的属性重写为一个只读的属性。</p>

<pre><code>注意
如果你在重写属性时给出了setter，那你必须也得给出getter。如果你不想修改getter的返回值，可以直接返回super.someProperty。
</code></pre>

<pre><code class="swift">class Car: Vehicle {
    var gear = 1
    override var description: String {
        return super.descripton + " in gear \(gear)"
    }
}
</code></pre>

<h6># 重写属性观察者</h6>

<p>你可以通过重写属性来给父类的属性添加观察者。</p>

<pre><code>注意
你不能给父类的常量存储属性或只读的计算属性添加观察者。因为这些属性的值不能改变，所以也没有willSet和didSet。

另外，你不即能给一个属性重写getter和setter，还给它添加观察者。
</code></pre>

<pre><code class="swift">class AudomaticCar : Car {
    override var currentSpees: Double {
        didSet {
            gear = Int(currentSpeed / 10.0) + 1
        }
    }
}
</code></pre>

<p>每当你修改一个AudomaticCar的currentSpeed属性，都会触发这个观察者来给gear设定适当的值。</p>

<pre><code class="swift">let automatic = AutomaticCar()
automatic.currentSpeed = 35.0
println("AutomaticCar: \(automatic.description)")
</code></pre>

<h5>防止重写</h5>

<p>你可以把一个属性，方法，角标标记为 final 来禁止子类重写。</p>

<p>任何尝试重写一个 final 的方法，属性，角标都会造成编译错误。</p>

<p>你可以把整个类标记为 final 来禁止这个类被继承。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Language Guide: Subscripts]]></title>
    <link href="http://zxhfirefox.github.io/blog/2014/10/19/language-guide-subscript/"/>
    <updated>2014-10-19T00:37:12+08:00</updated>
    <id>http://zxhfirefox.github.io/blog/2014/10/19/language-guide-subscript</id>
    <content type="html"><![CDATA[<p>类，结构体，枚举可以定义角标。角标是用来访问集合，列表或序列的元素的一种简写。使用角标可以访问和修改元素。例如，你访问数组的元素使用someArray[index]，访问字典的元素使用someDictionary[key]。</p>

<p>我们可以给一个类型添加多个角标，选择哪个角标是由传进来的索引的类型决定。角标不限于一个维度，你可以定义为角标定义多个输入。</p>

<h5>角标语法</h5>

<p>角标允许你在实例后面使用方括号来通过特定的值来查询这个实例。他们的语法和方法，属性的很相似。使用subscirpt关键字定义角标，并给出参数和返回值。角标和方法不同，角标可以是可读可写，也可以是只读，这种行为是通过一个类似于计算属性的 getter和 setter来表达。</p>

<pre><code class="swift">subscript(index: Int) -&gt; Int {
    get {
    }
    set(newValue){
    }
}
</code></pre>

<p>newValue的类型和角标返回的类型一致。和计算属性一样，你不提供newValue的话，一个默认的newValue会给你。</p>

<p>和只读的计算属性一样，你可以不写get。</p>

<pre><code class="swift">subscript(index: Int) -&gt; Int {
}
</code></pre>

<p>例如：</p>

<pre><code class="swift">struct TimesTable {
    let multiplier: Int
    subscript(index: Int) -&gt; Int {
        return multiplier * index
    }
}
let threeTimesTable = TimesTable(multiplier: 3)
println("six times three is \(threeTimesTable[6])")
</code></pre>

<h5>使用角标</h5>

<p>角标的确切含义取决于它使用的上下文。一般用来访问集合，列表或序列的元素。你可以使用角标实现任何适用于你自己类或结构体的方式。</p>

<p>例如Swift的Dictionary实现了角标，使得我们可以使用角标来访问字典里的元素。</p>

<pre><code>注意
Swift的Dictionary实现了通过角标获取对应key的value。但是是optional的，因为对应的key可能没有值存在。
</code></pre>

<h5>角标选项</h5>

<p>角标可以接受任何数量，任何类型的参数。角标也可以返回任何值。角标可以使用变量参数，变长参数，但是不能使用in-out参数，也不能有默认值参数。</p>

<p>一个类或结构体可以提供它需要的任意多的角标实现，使用哪个角标实现，由传入的参数类型来决定。这样子多个角标实现的方式叫做角标重载。</p>

<p>最常用的角标是获取一个单个的参数。</p>

<pre><code class="swift">struct Matrix {
    let rows: Int, columns: Int
    var grid: [Double]
    init(rows: Int, columns: Int) {
        self.rows = rows
        self.columns = columns
        grid = Array(count: rows * columns, repeatedValue: 0.0)
    }
    func indexIsValidForRow(row: Int, column: Int) -&gt; Bool {
        return row &gt;= 0 &amp;&amp; row &lt; rows &amp;&amp; column &gt;= 0 &amp;&amp; column &lt; columns
    }
    subscript(row: Int, column: Int) -&gt; Double {
        get {
            assert(indexIsValidForRow(row, column: column), "Index out of range")
            return grid[(row * columns) + column]
        }
        set {
            assert(indexIsValidForRow(row, column: column), "Index out of range")
            grid[(row * columns) + column] = newValue
        }
    }
}
</code></pre>

<p>上面的例子里，Matrix定义了一个需要两个参数的角标来提供元素的访问。</p>

<pre><code class="swift">var matrix = Matrix(rows: 2, columns: 2)
matrix[0, 1] = 1.5
matrix[1, 0] = 3.2
</code></pre>

<p>注意grid数组的初始化方式，和角标里作为越界检查的断言。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Language Guide: Methods]]></title>
    <link href="http://zxhfirefox.github.io/blog/2014/10/19/language-guide-q-methods/"/>
    <updated>2014-10-19T00:36:13+08:00</updated>
    <id>http://zxhfirefox.github.io/blog/2014/10/19/language-guide-q-methods</id>
    <content type="html"><![CDATA[<p>方法是关联到特殊类型的函数。类，结构体，枚举都可以定义实例方法，实例方法绑定到具体的实例。他们也都可以定义类型方法，类型方法关联到类型。类型方法和ObjC的类方法是相似的。</p>

<p>事实上，结构体和枚举可以定义方法是Swift和C，ObjC的主要区别之一。在ObjC里，只有类是可以定义方法的。在Swift里，类，结构体和枚举都可以定义方法。</p>

<h5>实例方法</h5>

<p>实例方法是属于一个类，结构体，枚举的实例的函数。他们要么提供访问实例属性，要么提供和实例相关的功能来支持这些实例。实例方法的语法和函数完全一样。</p>

<p>你把一个实例方法写在一个类型的大括号里。一个实例方法默认可以访问这个类型的所有其他方法和属性。实例方法仅能被类型的某个实例调用。没有实例，是无法调用实例方法的。</p>

<p>下面的例子：</p>

<pre><code class="swift">class Counter {
    var count = 0
    func increment() {
        count++
    }
    func incrementBy(amount: Int) {
        count += amount
    }
    func reset() {
        count = 0
    }
}
</code></pre>

<p>Counter类定义了一些实例方法。还定义了一个属性。</p>

<pre><code class="swift">let counter = Counter()
// the initial counter value is 0
counter.increment()
// the counter's value is now 1
counter.incrementBy(5)
// the counter's value is now 6
counter.reset()
// the counter's value is now 0
</code></pre>

<h6>方法的外部和本地变量名</h6>

<p>函数参数可以既有一个供外部使用的名字，还可以有一个供内部使用的名字。这点对于方法也是，因为方法仅仅是关联了一个类型的函数。然而，本地和外部名字的默认表现在函数和方法之间是有区别的。</p>

<p>Swift的方法和ObjC的很相似，和ObjC一样，Swift的方法的第一个参数总是有一个介词来修饰，例如with，for，by等等。使用介词，可以使方法调用读起来更像普通的句子。Swift通过使用一套不同于函数参数名字的方式来使这种命名规则得以继续。</p>

<p>特别的，Swift总是会给一个方法的第一个参数一个默认的内部名字，并且默认的给其他位置的参数同时内部和外部名字。这种规则和我们熟悉ObjC的方法调用的规则是一致的。</p>

<pre><code class="swift">class Counter {
    var count: Int = 0
    func incrementBy(amount: Int, numberOfTimes: Int) {
        count += amount * numberOfTimes
    }
}
</code></pre>

<p>incrementBy方法有两个参数，amount和numberOfTimes。默认的，Swift认为amount只是本地名字，而numberOfTimes既是本地名字，又是外部名字。</p>

<pre><code class="swift">let counter = Counter()
counter.incrementBy(5, numberOfTimes: 3)
</code></pre>

<p>你不需要为第一个参数定义外部的名字，因为它的目的可以从方法名得出，incrementBy。第二个参数，却需要一个外部参数来指出它的意义。</p>

<p>这个默认行为相当于你在第二个参数开始的所有参数都使用了 # 来标记。</p>

<pre><code class="swift">func incrementBy(amount: Int, #numberOfTimes: Int) {
    count += amount * numberOfTimes
}
</code></pre>

<p>上面描述的这种默认行为使得Swift的方法定义和ObjC很相似，调用起来更自然。</p>

<h6>修改方法外部参数名字的行为</h6>

<p>有时候，给方法的一个参数也给一个外部名字是有用的，尽管这不是默认行为。你可以显式给出一个名字，也可以给第一个参数加一个 # 来使用和本地名字一样的相同的外部名字。</p>

<p>相反的，如果不想给第二个以及其他参数给出外部名字，你可以使用 _ 来修改外部参数。</p>

<h6>self属性</h6>

<p>每一个类型的实例都有一个默认的属性叫 self，它总是和实例自己相一致。在方法里，是用self来引用当前的实例。</p>

<pre><code class="swift">func increment() {
    self.count++
}
</code></pre>

<p>事实上，你不需要经常使用self。如果你不写self，Swift会假设你在访问当前实例的一个属性或方法。</p>

<p>但是，如果你的方法的一个参数和一个属性的名字一样，那么你需要明确的使用self来区分参数和自己的属性。</p>

<pre><code class="swift">struct Point {
    var x = 0.0, y = 0.0
    func isToTheRightOfX(x: Double) -&gt; Bool {
        return self.x &gt; x
    }
}
let somePoint = Point(x: 4.0, y: 5.0)
if somePoint.isToTheRightOfX(1.0) {
    println("This point is to the right of the line where x == 1.0")
}
</code></pre>

<h6>在实例方法里修改值类型</h6>

<p>结构体和枚举是值类型，默认的，值类型的属性是不能在自己的实例方法被修改的。</p>

<p>但是，如果你需要在一个实例方法里修改结构体或枚举的属性，你可以把方法改成 mutating行为的。这个方法就可以在方法内部修改实例的属性，而且这些被修改的属性也会反映到真实的属性里。这种方法也可以直接把一个全新的实例附值给 self 属性，然后这个新实例将会在方法结束后代替原来的实例。</p>

<pre><code class="swift">struct Point {
    var x = 0.0, y = 0.0
    mutating func moveByX(deltaX: Double, y deltaY: Double) {
        x += deltaX
        y += deltaY
    }
}
var somePoint = Point(x: 1.0, y: 1.0)
somePoint.moveByX(2.0, y: 3.0)
println("The point is now at (\(somePoint.x), \(somePoint.y))")
</code></pre>

<p>使用 mutating 关键字来修饰func定义。上面的例子中，moveByX方法修改了自己的属性。</p>

<p>注意，你不能在一个常量结构体或枚举上调用 mutating方法，因为他们的属性不能被改变，即使他们的属性是变量。</p>

<pre><code class="swift">let fixedPoint = Point(x: 3.0, y: 3.0)
fixedPoint.moveByX(2.0, y: 3.0)
// this will report an error
</code></pre>

<h6>在一个 mutating 方法里给 self 附值</h6>

<p>mutating 方法可以把一个全新的实例附值给 self。</p>

<pre><code class="swift">struct Point {
    var x = 0.0, y = 0.0
    mutating func moveByX(deltaX: Double, y deltaY: Double) {
        self = Point(x: x + deltaX, y: y + deltaY)
    }
}
</code></pre>

<p>这个版本的moveByX返回一个全新的Point。</p>

<p>枚举的 mutating方法可以给 self 附值一个新的枚举成员。</p>

<pre><code class="swift">enum TriStateSwitch {
    case Off, Low, High
    mutating func next() {
        switch self {
        case Off:
            self = Low
        case Low:
            self = High
        case High:
            self = Off
        }
    }
}
var ovenLight = TriStateSwitch.Low
ovenLight.next()
// ovenLight is now equal to .High
ovenLight.next()
// ovenLight is now equal to .Off
</code></pre>

<h5>类型方法</h5>

<p>实例方法，如上所述，是在一个类型的具体实例上调用的方法。我们也可以定义调用在类型本身的方法。这种类型的方法叫类型方法。在类里添加类型方法使用 class关键字，在结构体和枚举里定义类型方法使用 static 关键字。</p>

<pre><code>注意
在ObjC里，你只能给类定义类型方法。在Swift里，你可以给类，结构体，枚举定义类型方法。
</code></pre>

<p>类型方法也是用 . 来调用，不过 . 的左边不是实例，而是类型。</p>

<pre><code class="swift">class SomeClass {
    class func someTypeMethod() {
        // type method implementation goes here
    }
}
SomeClass.someTypeMethod()
</code></pre>

<p>在类型方法里， self 属性默认指向的就是类型本身，而不是实例。对于结构体和枚举，你可以使用 self 来区分静态属性和静态方法参数，就和实例方法一样。</p>

<p>更广泛来说，在类型方法里使用的任何未加修饰的方法和属性名字都会在类型级别寻找。类型方法可以调用类型方法，可以访问静态属性。</p>

<pre><code class="swift">struct LevelTracker {
    static var highestUnlockedLevel = 1
    static func unlockLevel(level: Int) {
        if level &gt; highestUnlockedLevel { highestUnlockedLevel = level }
    }
    static func levelIsUnlocked(level: Int) -&gt; Bool {
        return level &lt;= highestUnlockedLevel
    }
    var currentLevel = 1
    mutating func advanceToLevel(level: Int) -&gt; Bool {
        if LevelTracker.levelIsUnlocked(level) {
            currentLevel = level
            return true
        } else {
            return false
        }
    }
}
</code></pre>

<pre><code class="swift">class Player {
    var tracker = LevelTracker()
    let playerName: String
    func completedLevel(level: Int) {
        LevelTracker.unlockLevel(level + 1)
        tracker.advanceToLevel(level + 1)
    }
    init(name: String) {
        playerName = name
    }
}
</code></pre>

<pre><code class="swift">var player = Player(name: "Argyrios")
player.completedLevel(1)
println("highest unlocked level is now \(LevelTracker.highestUnlockedLevel)")
// prints "highest unlocked level is now 2"
</code></pre>

<pre><code class="swift">player = Player(name: "Beto")
if player.tracker.advanceToLevel(6) {
    println("player is now on level 6")
} else {
    println("level 6 has not yet been unlocked")
}
// prints "level 6 has not yet been unlocked"
</code></pre>
]]></content>
  </entry>
  
</feed>

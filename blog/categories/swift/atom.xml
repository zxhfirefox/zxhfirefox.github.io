<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: swift | zxhfirefox's Blog]]></title>
  <link href="http://zxhfirefox.github.io/blog/categories/swift/atom.xml" rel="self"/>
  <link href="http://zxhfirefox.github.io/"/>
  <updated>2014-10-06T15:14:09+08:00</updated>
  <id>http://zxhfirefox.github.io/</id>
  <author>
    <name><![CDATA[zxhfirefox]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Language Guide: Enumetations]]></title>
    <link href="http://zxhfirefox.github.io/blog/2014/10/06/language-guide-enumetations/"/>
    <updated>2014-10-06T14:42:46+08:00</updated>
    <id>http://zxhfirefox.github.io/blog/2014/10/06/language-guide-enumetations</id>
    <content type="html"><![CDATA[<p>枚举是给一系列相关的值定义一个通用的类型，让你在使用这些值的时候可以保证类型安全。</p>

<p>如果你熟悉C，你应该知道C里的枚举是把一些有意义的名字附值给一系列整数。Swift里的枚举更加灵活，你不需要为每一个成员都定义一个值。如果枚举成员有对应的值（raw值），这个值可以是整数，字符串，字符，或是浮点数。（注：没有关联值的枚举是Hashable的）</p>

<p>另外，枚举成员可以给出任何类型的关联值。更像其他语言里的unions和variants。你可以把相关成员的通用集合定义为枚举的一部分，每一部分又可以和不同类型的关联值关联到一起。</p>

<p>在Swift里，枚举是头等成员。它又有许多成员是以前只有类才有的特性，例如，用来更好给出枚举当前值的计算属性，和枚举值相关的成员函数。枚举还可以定义初始化函数来给出枚举初始值，也可以被扩展来增加原来没有的功能，还能够实现协议。</p>

<h5>枚举语法</h5>

<p>用enum关键字定义枚举。</p>

<pre><code class="swift">enum SomeEnumeration {
}
</code></pre>

<p>例如：</p>

<pre><code class="swift">enum CompassPoint {
    case North
    case South
    case East
    case West
}
</code></pre>

<p>定义在枚举里的值（North&hellip;)叫做枚举成员值（或成员）。case关键字用来标示新的成员。</p>

<pre><code>注意
和C,ObjC不一样，Swift的枚举成员并没有默认的和整数相关联。
</code></pre>

<p>多个枚举值可以写在同一行，用逗号隔开。</p>

<pre><code class="swift">enum Planet{
    case Mercury, Venus, Earth, Mars, Jupiter, Saturn, Uranus, Neptune
}
</code></pre>

<p>每个枚举都定义了一个新的类型。和其他类型一样，都应该由大写字母开头。用单数不要用复数。</p>

<pre><code class="swift">var direction = CompassPoint.West
</code></pre>

<p>上面direction的类型被推断为CompassPoint。在此之后，你可以直接用 . 来更新它的值。</p>

<pre><code class="swift">direction = .East
</code></pre>

<p>因为它的类型已经知道了，所以你不用再写出它的类型。</p>

<h5>用switch语句来匹配枚举值</h5>

<pre><code class="swift">direction = .South
switch direction {
case .North:
    println("Lots of planets have a north")
case .South:
    println("Watch out for penguins")
case .East:
    println("Where the sun rises")
case .West:
    println("Where the skies are blue")
}
</code></pre>

<p>在流程控制里，我们提到switch语句必须是穷举的。如果上面我们没有写.West的case，这段代码就无法编译。穷举保证了枚举值不会被忽略。</p>

<p>如果不适合给每个枚举值都写case，可以使用default来做。</p>

<pre><code class="swift">let somePlanet = Planet.Earth
switch somePlanet {
case .Earth:
    println("Mostly harmless")
default:
    println("Not a safe place for humans")
}
</code></pre>

<h5>关联值（associated value）</h5>

<p>上面的例子里，枚举值都是使用他们自己作为值。但是有时候，你如果能够给枚举值关联一些其他类型的值会很有用。这将让你可以存储额外的信息到每个枚举值，并使他们在用的时候可以变化。</p>

<p>你可以给枚举值定义任何类型的关联值，而且同一个枚举下不同枚举值可以有不同类型的关联值。像这样子的枚举在其他语言里，可能叫discriminated unions，tagged unions，或variants。</p>

<p>例如，一个库存管理系统，需要记录两种不同的条码，有些商品用的UPC-A的1维条码，只用到了0-9这些数字，每一个条码都有一个数字系统号，然后5个制造商号，5个产品号和一个校检号。另外一个些商品使用二维码来标示，可以使用IOS 8859-1的任何字符，可以编码一个长度达2953的字符串。</p>

<p>如果我们可以把UPC-A条码表示为4个整数，二维码表示为一个字符串将会很方便。</p>

<p>在Swift里，定义如下：</p>

<pre><code class="swift">enum Barcode {
    case UPCA(Int,Int,Int,Int)
    case QRCode(String)
}
</code></pre>

<p>这段代码理解为，定义一个枚举类型，叫Barcode，它要么是一个关联了4个整数的UPCA值，要么是一个关联了一个字符串的QRCode值。</p>

<p>这个定义只是定义了类型，并没有给出真实的值。任何Barcode类型的常量或变量都可以存储Barcode.UPCA或Barcode.QRCode。</p>

<p>新的barcode可以用任何一个case来创建。</p>

<pre><code class="swift">var code = Barcode.UPCA(8,85909,51226,3)
</code></pre>

<p>同一个产品可以被赋给不同的枚举值。</p>

<pre><code class="swift">code = .QRCode("ABCDEFGHIJKLMNOP")
</code></pre>

<p>Barcode类型的常量或变量可以存储UPCA和QRCode任意一种，但是在任何时间都只能是一种。</p>

<p>barcode的值也可以通过switch来区分，不过，这次，关联值可以被拆解出来作为switch语句的一部分。</p>

<pre><code class="swift">switch productBarcode {
case let .UPCA(numberSystem, manufacturer, product, check):
    println("UPC-A: \(numberSystem), \(manufacturer), \(product), \(check).")
case let .QRCode(productCode):
    println("QR code: \(productCode).")
}
</code></pre>

<p>注：这里我们也可以在多写一些分支加上where语句。</p>

<h6>原始值（raw value）</h6>

<p>除了上面说的关联值，作为另外一种方式，枚举可以有原始值，他们必须是同一类型的。</p>

<pre><code class="swift">enum ASCIIControlCharacter : Character {
    case Tab = "\t"
    case LineFeed = "\n"
    case CarriageReturn = "\r"
}
</code></pre>

<p>这里ASCIIControlCharacter的原始值的类型是Character。</p>

<p>注意原始值和关联值是不一样的。原始值在你定义枚举时就已经给出了。对于某一个枚举成员，原始值是固定不变的。关联值是你在给一个常量或变量赋值时才给出，而且每次都可以不一样。</p>

<p>原始值可以是字符串，字符，整数或浮点数。每一个原始值在枚举定义时必须唯一。如果是整数，会自动递增。</p>

<pre><code class="swift">enum Planet: Int {
    case Mercury = 1, Venus, Earth, Mars, Jupiter, Saturn, Uranus, Neptune
}
</code></pre>

<p>上面重新定义了Planet枚举，它的原始值是整数，第一个从1开始，后面的依次递增。</p>

<p>使用 toRaw 来访问枚举的原始值。</p>

<pre><code class="swift">let earthIndex = Planet.Earth.toRaw() //earthIndex is 3 and is an Int.
</code></pre>

<p>用 fromRaw 来尝试把一个值作为原始值转换到枚举值。</p>

<pre><code class="swift">let possiblePlanet = Planet.fromRaw(7) //possiblePlanet的类型是 Planet?。
</code></pre>

<p>因为不是所有的整数都能转换到这个枚举值，所以 fromRaw返回的是一个optional。如果你给出的值无法转换到枚举，那么 fromRaw返回的就是nil。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Language Guide: Closures]]></title>
    <link href="http://zxhfirefox.github.io/blog/2014/10/06/language-guide-closures/"/>
    <updated>2014-10-06T14:41:52+08:00</updated>
    <id>http://zxhfirefox.github.io/blog/2014/10/06/language-guide-closures</id>
    <content type="html"><![CDATA[<p>闭包是一段独立的功能，可以在代码之间传递和使用。Swift里的闭包和C，ObjC里的block，以及其他语言里的lambda表达式是相似的。</p>

<p>闭包可以捕获和存储定义在定义闭包的上下文里的任何变量和常量的引用。这被叫做遮盖(closing over)这些常量和变量，正说明了闭包的概念。Swift会帮你处理所有这些捕获时的内存管理。</p>

<p>在上一章函数里，全局和嵌套函数，其实是闭包的特殊情况。闭包有三种形式：</p>

<ul>
<li>全局函数是闭包，它有名字，但是不会捕获任何值。</li>
<li>嵌套函数是闭包，它有名字，并且会捕获包含函数里值。</li>
<li>闭包表达式是无名闭包，有简单的语法，从包裹他们的上下文里捕获值。</li>
</ul>


<p>Swift的闭包表达式有着清晰，简洁的风格，并被优化过，鼓励在一般情况下写出简洁，不杂乱的语法。这些优化包括：</p>

<ul>
<li>从上下文推断参数和返回值类型。</li>
<li>从单个表达式的闭包自动返回值。</li>
<li>参数名缩写。</li>
<li>尾部闭包语法。</li>
</ul>


<h5>闭包表达式</h5>

<p>嵌套函数，是在大函数里定义有名字的，独立的代码块的很方便的方法。然后，有时候我们需要写出更简短的，不需要全部定义和名字的类似函数的结构，特别是你在把函数当做参数和返回值的时候。</p>

<p>闭包表达式是一种通过简洁，集中的语法来写内连(inline)闭包的方式。闭包表达式经过优化在不损失清晰性的前提写出简短的代码。</p>

<h6>sorted函数</h6>

<p>Swift标准库里的sorted函数用来排序一个已知类型的数组，基于你传递给它的排序闭包。一旦配需结束，它返回一个排好序的数组。原来的数组并没有被sorted函数改变。</p>

<p>下面是我们要排序的数组：</p>

<pre><code class="swift">let names = ["Chris","Alex","Ewa","Barry","Daniella"]
</code></pre>

<p>sorted的函数接受2个参数，一个是要排序的数组，另一个是一个闭包，接受两个参数，他们的类型需要和数组元素的类型一致，返回一个Bool值，来表示如果第一个参数应该排在第二个参数之前，那么就是true，反之则是false。</p>

<p>这个例子我们排的是String，所以闭包的类型应该是(String,String) -> Bool。</p>

<p>一种方式，我们写出排序的函数，然后把它传递给sorted函数。</p>

<pre><code class="swift">func backwards(s1:String, s2:String) -&gt; Bool {
    return s1 &gt; s2
}
var reversed = sorted(names,backwards)
</code></pre>

<p>如果s1大于s2，返回true，意思是如果s1大于s2，那么s1应该排在s2的前面。对于字符串里的字符来说，大于就是在字母表里排在后面。也就是说&#8217;B&#8217;大于&#8217;A&#8217;。这样就给出了字母表反序的排列。</p>

<p>然而，这是一个相对比较长的写法，关键部分其实只有 a > b，我们应该用闭包表达式来写。</p>

<h6>闭包表达式</h6>

<p>闭包表达式的语法如下：</p>

<pre><code>{ (parameters) -&gt; (return type) in 
    statements
}
</code></pre>

<p>闭包表达式的语法，可以使用常量参数，变量参数和inout参数。不能有默认值。不定长参数可以使用，但是必须在最后一个。元组可以作为参数和返回值使用。</p>

<pre><code class="swift">reversed = sorted(names, { (s1: String, s2: String) -&gt; Bool in
    return s1 &gt; s2
})
</code></pre>

<p>注意，这里的参数和返回值和之前通过定义函数来做的时候是一样的。然而，在闭包表达式里，参数和返回值是包裹在大括号里的，而不是在外面。</p>

<p>闭包表达式body的开始由 in 来标记。这个关键字说明了闭包的参数和返回值声明的结束，闭包的body的开始。</p>

<p>因为这个闭包的body很短，我们可以把它写在一行里。</p>

<pre><code class="swift">reversed = sorted(names, { (s1: String, s2: String) -&gt; Bool in return s1 &gt; s2 } )
</code></pre>

<h6>从上下文推断类型</h6>

<p>因为这个排序闭包作为参数传递给一个函数，Swift可以通过sorted的第二个参数的类型来推断出这个闭包的类型。sorted函数的这个参数需要一个(String,String)->Bool类型的闭包，这意味着我们其实不用在闭包表达式里写出这个类型，因为所有的类型都可以推断出来，那->和参数名字周围的括弧可以省略掉。</p>

<pre><code class="swift">reversed = sorted(names,{s1,s2 in return s1 &gt; s2})
</code></pre>

<p>当我们把一个内连的闭包表达式传递给一个函数时，我们总是能够推断出他的参数和返回值类型，也就是说，这种情况下，你永远都不需要把闭包的完整格式写出来。</p>

<p>尽管如此，你仍热可以把类型明确的写出来，事实上，如果这样可以增加代码的可读性，就应该写出来。在上面sorted的例子里，闭包的目的就是排序，而且认为它就是在处理String类型也不会有问题，因为它是用来帮助排序一个字符串数组的。</p>

<h6>从单个表达式的闭包自动返回值</h6>

<p>单个表达式的闭包可以自动返回唯一的表达式的值，所以不需要写return。</p>

<pre><code class="swift">reversed = sorted(names,{s1,s2 in s1 &gt; s2})
</code></pre>

<h6>参数名缩写</h6>

<p>Swift自动为内连闭包提供参数的缩写，他们是$0,$1,$2 &hellip;。</p>

<p>如果我们是用缩写的参数名，那么我们就不用写出参数列表，而这些缩写的参数的类型也会被推断出来。in 也可以被省略掉。</p>

<pre><code class="swift">reversed = sorted(names, { $0 &gt; $1})
</code></pre>

<h6>操作符函数</h6>

<p>其实，上面的例子我们可以写的更短。Swift的String类型定义了 > 作为一个函数，接受2个String，返回一个Bool。这个正好满足我们sorted函数的要求。因此，我们可以直接传入 >，Swift会推断出你想要它做的事情。</p>

<pre><code class="swift">reversed = sorted(names, &gt;)
</code></pre>

<h5>尾部闭包</h5>

<p>如果你把一个闭包做为函数参数的最后一个传递给一个函数，你可以把这个闭包用尾部闭包的语法来写。尾部闭包的写法是把这个闭包写在括弧的后面，而不是包裹在括弧里。</p>

<pre><code class="swift">func someFunctionThatTakesAClosure(closure: ()-&gt;() ){
// body here
}
someFunctionThatTakesAClosure({
// body here
})
someFunctionThatTakesAClosure() {
// body here
}
</code></pre>

<pre><code>注意
如果比个闭包表达式是一个函数的唯一一个参数，你通过尾部闭包来提供这个参数。那么你可以不写（）。
</code></pre>

<p>上面的sorted的例子也可以用尾部闭包来写。</p>

<pre><code class="swift">reversed = sorted(names) { $0 &gt; $1 }
</code></pre>

<p>尾部闭包在处理闭包函数体很大的时候非常有用。例如，Swift的Array有个map函数，接受一个闭包作为唯一的参数。这个闭包会在每个数组元素上调用，然会一个新的值，然后map函数会把所有这些作为一个新的数组返回。</p>

<pre><code class="swift">let digitNames = [
    0: "Zero", 1: "One", 2: "Two", 3: "Three", 4: "Four",
    5: "Five", 6: "Six", 7: "Seven", 8: "Eight", 9: "Nine"
    ]
let numbers = [16,58,510]
</code></pre>

<pre><code class="swift">let strings = numbers.map {
    (var number) -&gt; String in
    var output = ""
    while number &gt; 0 {
        output = digitNames[number % 10]! + output // 注意 !
        number /= 10
    }
    return output
}
</code></pre>

<p>map方法调用上面的闭包。你不需要给出number的类型。</p>

<p>这个例子，number参数被定义成了var，所以你可以改变它的值。并且明确给出了闭包的返回值类型是一个String。</p>

<pre><code>注意
在通过角标访问digitNames的时候，后面的那个！，因为角标访问字典回复的时个optional，我们应该判断是否为nil。不过这个例子里，不可能出现 nil，所以没有判断直接解包。
</code></pre>

<p>这个例子很好的展示了使用尾部闭包来把闭包的功能紧凑的挨着调用函数而不用把闭包放在函数的括弧里。</p>

<h5>捕获值</h5>

<p>闭包从定义它自己的上下文里捕获常量和变量的值。然后，闭包就可以在闭包体内引用和修改这些值，即使最开始定义这些值的作用域已经不存在了。</p>

<p>最简单的闭包就是嵌套函数。一个嵌套函数可以捕获包裹函数的参数，以及所有的定义在包裹函数内的常量和变量。</p>

<pre><code class="swift">func makeIncrementor (forIncrement amount: Int) -&gt; () -&gt; Int {
    var runningTotal = 0
    func incrementor() -&gt; Int {
        runningTotal += amount
        return runningTotal
    }
    return incrementor
}
</code></pre>

<p>上面例子，makeIncrementor的返回值是一个类型为() -> Int的函数。</p>

<p>makeIncrementor定义了一个runningTotal，来存储当前makeIncrementor的runningTotal，初始值是0。</p>

<p>makeIncrementor的唯一参数amount是一个Int值，每次调用incrementor，都会把这个amount加到runningTotal上面。</p>

<p>makeIncrementor还定义了一个嵌套函数incrementor，它来做真正的增加操作。</p>

<p>如果我们单独来看incrementor函数，它是很奇怪的。</p>

<p>他没有定义任何参数，但是却引用了runningTotal和amount。它是把这个值捕获了。</p>

<p>incrementor并没有修改amount，所以他只是拷贝的一份。然而，对于runningTotal，incrementor每次调用都会修改它的值。所以incrementor事实上是捕获了一份引用，而不是简单的拷贝值。捕获引用可以确保runningTotal在makeIncrementor调用结束后不消失，这样下次调用incrementor的时候就会存在。</p>

<pre><code>注意
Swift会决定什么值需要拷贝，什么需要捕获引用。你不需要做任何事。Swift也负责所有的内存管理。
</code></pre>

<pre><code class="swift">let incrementByTen = makeIncrementor(forIncrement:10)
incrementByTen() // 10
incrementByTen() // 20
incrementByTen() // 30
</code></pre>

<p>如果你定义一个新的incrementor，他会存储它自己的，新的一个runningTotal。调用之前定义的incrementByTen并不会干扰这个新的。</p>

<pre><code class="swift">let incrementBySeven = makeIncrementor(forIncrement: 7)
incrementBySeven() // 7
incrementByTen()  // 40
</code></pre>

<pre><code>注意
如果你把闭包附值给了一个类实例的属性，并且这个闭包捕获了这个类实例或它的成员，这将是一个循环引用。你需要使用捕获列表来处理。
</code></pre>

<h5>闭包是引用类型</h5>

<p>上面的例子里，incrementBySeven和incrementByTen是常量。但是这些常量引用的闭包依旧可以修改他们捕获的runningTotal的值。这是因为函数和闭包是引用类型。</p>

<p>无论何时你把一个函数或闭包附值给一个常量或变量，你都是把它的引用附值给了常量或变量。上面的例子，是说incrementByTen的引用是个常量，(注：就是它不能在引用其他闭包）而不是闭包本身是常量。</p>

<p>这也意味着，同一个闭包可以被多个变量或常量引用。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Language Guide: Functions]]></title>
    <link href="http://zxhfirefox.github.io/blog/2014/10/05/language-guide-functions/"/>
    <updated>2014-10-05T14:40:40+08:00</updated>
    <id>http://zxhfirefox.github.io/blog/2014/10/05/language-guide-functions</id>
    <content type="html"><![CDATA[<p>函数是用来完成某一任务的独立的一段代码。函数名标示了它用来做什么，也用来调用这个函数。</p>

<p>Swift统一的函数语法，既可以不要参数名字来表达简单的C语言的函数，也可以给出内部和外部参数名字来表达ObjC里复杂的函数。参数可以提供默认值，也可以做为输入输出参数，在函数执行后，改变传进来的值。</p>

<p>Swift里每一个函数都一个一个类型，这个类型由参数类型和返回值类型组成。我们可以把这个类型和Swift里其他类型同等对待。这样，可以非常方便的把函数作为参数或返回值。函数也可以定义在其他函数里。</p>

<h6>定义和调用函数</h6>

<p>当你定义一个函数时，你可以可选的定义一个或多个有类型的参数作为输入，并且或者定义一个类型的值作为函数调用后的返回值。</p>

<p>每个函数都有一个函数名，描述了这个函数是做什么的。为了使用这个函数，你通过把输入参数传递给这个函数名来调用这个函数。一个函数的参数必须按照定义的顺序传递给函数。</p>

<pre><code class="swift">func sayHello(person: String) -&gt; String {
    let greeting = "Hello, " + person + "!"
    return greeting
}
</code></pre>

<p>func来定义一个函数，用 ->来分割参数和返回值。</p>

<h5>函数参数和返回值</h5>

<p>Swift函数的参数和返回值非常的灵活。</p>

<h6>多参数函数</h6>

<pre><code class="swift">func halfOpenRangeLength(start: Int, end: Int) -&gt; Int {
    return end - start
}
</code></pre>

<h6>无参数函数</h6>

<pre><code class="swift">func sayHelloWorld() -&gt; String{
    return "Hello,World"
}
</code></pre>

<h6>无返回值函数</h6>

<pre><code class="swift">func sayGoodbye(person: String) {
    println("Goodbye, \(person)")
}
</code></pre>

<pre><code>注意
严格来讲，sayGoodbye还是有返回值的。函数在没有声明返回值的时候会返回一个Void类型的特殊值，也就是一个空的元组，()。
</code></pre>

<p>函数的返回值可以被忽略。</p>

<pre><code>注意
函数的返回值可以被忽略，但是函数如果声明了返回值，那么它必须返回一个值，否则编译错误。
</code></pre>

<h6>多返回值函数</h6>

<p>可以使用元组来把多个值组合起来返回。</p>

<pre><code class="swift">func minMax(array: [Int]) -&gt; (min:Int,max:Int){
    var currentMin = array[0]
    var currentMax = array[0]
    for value in array {
        if value &gt; currentMax {
            currentMax = value
        else if value &lt; currentMin {
            currentMin = value
        }
    }
    return (currentMin,currentMax)
}
</code></pre>

<h6>optional的元组返回类型</h6>

<p>如果函数返回的元组在有些时候不存在，那么可以把返回的元组声明为optional的。</p>

<pre><code>注意
一个optional的元组(Int,Int)? 和一个包含optional值的元组(Int?,Int?)是不一样的。
</code></pre>

<p>上面的minMax没有做安全检查，如果数组没空，访问array[0]是有问题的。</p>

<pre><code class="swift">func minMax(array: [Int]) -&gt; (min:Int,max:Int)? {
    if array.isEmpty { return nil }
    var currentMin = array[0]
    var currentMax = array[0]
    for value in array {
        if value &gt; currentMax {
            currentMax = value
        else if value &lt; currentMin {
            currentMin = value
        }
    }
    return (currentMin,currentMax)
}
</code></pre>

<p>使用optional绑定来检查返回值。</p>

<h6>函数参数的名字</h6>

<p>上面所有的函数都定义了参数的名字。</p>

<pre><code class="swift">func someFunction(parameterName :Int){
}
</code></pre>

<p>但是，这些名字都只能在函数内部使用，而不能在调用函数时使用。这样的参数名字一般叫做本地参数名。</p>

<h6>外部参数名</h6>

<p>有些时候，如果能够在调用函数的时候提供参数的名字，来说明每个参数的意思是很有用的。</p>

<p>你可以在本地参数名前面加一个外部参数名，用空格隔开。</p>

<pre><code class="swift">func someFunction(externalParameterName localParameterName :Int){
}
</code></pre>

<pre><code>注意
如果你定义了外部参数名，那这个名字必须在调用时使用。
</code></pre>

<p>例如：</p>

<pre><code class="swift">func join(s1: String, s2: String, joiner: String) -&gt; String {
    return s1 + joiner + s2
}
</code></pre>

<p>调用时:</p>

<pre><code class="swift">join("hello","world",",")
</code></pre>

<p>使用外部参数名：</p>

<pre><code class="swift">func join(string s1: String, toString s2: String, withJoiner joiner: String) -&gt; String {
    return s1 + joiner + s2
}
</code></pre>

<p>调用时：</p>

<pre><code class="swift">join(string: “hello", toString: "world" withJoiner: ”,"）
</code></pre>

<h6>外部参数名简写</h6>

<p>如果你的外部参数名，和本地参数名的名字一样的话，你不需要写两遍，而是在参数名前面加 # 。</p>

<pre><code class="swift">func containsCharacter(#string: String, #characterToFind: Character) -&gt; Bool {
    for character in string {
        if character == characterToFind {
            return true
        }
    }
    return false
}
</code></pre>

<h6>默认参数值</h6>

<p>你可以给任意一些参数提供默认值，如果有默认值，那么在调用时，你可以不传递参数。</p>

<pre><code>注意
你应该把有默认参数值的参数放在参数列表的最后，这样确保调用时的没有默认值的参数顺序是对的。
</code></pre>

<p>例子：</p>

<pre><code class="swift">func join(string s1: String, toString s2: String,
    withJoiner joiner: String = " ") -&gt; String {
        return s1 + joiner + s2
}
</code></pre>

<p>调用时，如果不给第三个参数</p>

<pre><code class="swift">join(string: "hello", toString: "world")
</code></pre>

<p>如果给了第三个参数</p>

<pre><code class="swift">join(string: "hello", toString: "world", withJoiner: "-")
</code></pre>

<h6>有默认值的外部参数名</h6>

<p>在大多数情况下，如果一个参数有默认值，它应该对应的有一个外部参数名。这样可以确保在调用时，实参传递给了正确的形参。</p>

<p>为了简化这个步骤，Swift为每一个有默认值的参数一个外部参数名，和内部参数名一致，就好像你写了 # 一样。</p>

<pre><code>注意
你可以通过写一个 _ 作为外部参数名来不用这个特性，但是有默认值的参数对应有外部参数名是比较好的做法。
</code></pre>

<h6>不定长的参数</h6>

<p>一个不定长的参数，接受0个或多个某一类型的参数。在参数类型后面加 &hellip; 来表示不定长参数。</p>

<p>传入到不定长参数的实参会作为一个数组存在。</p>

<pre><code class="swift">func arithmeticMean(numbers: Double...) -&gt; Double {
    var total: Double = 0
    for number in numbers {
        total += number
    }
    return total / Double(numbers.count)
}
</code></pre>

<pre><code>注意
一个函数最多只能有一个不定长参数，而且必须是参数列表的最后一个。如果一个函数有默认值参数和不定长参数，先写默认值参数，再写不定长参数。
</code></pre>

<h6>常量和变量参数</h6>

<p>函数参数默认是常量，如果你在函数里改变参数的值，会造成编译错误。</p>

<p>但是，有时候能够使用一个可变的参数的拷贝会很方便。你可以声明参数为var来做到这一点。</p>

<pre><code class="swift">func alignRight(var string: String, count: Int, pad: Character) -&gt; String {
    let amountToPad = count - countElements(string)
    if amountToPad &lt; 1 {
        return string
    }
    let padString = String(pad)
    for _ in 1...amountToPad {
        string = padString + string
    }
    return string
}
</code></pre>

<pre><code>注意
你对var的参数做的改变只在当次函数调用时有用。在函数外部不可见。var的参数也只在函数调用期间存在。
</code></pre>

<h6>输入输出函数</h6>

<p>变量参数只能在函数内起作用，如果你希望你对一个参数做的改变可以在函数调用结束后依然有效，你需要把它声明为输入输出参数。</p>

<p>在参数前面加上 inout 来标示一个输入输出参数。</p>

<p>你只能给 inout参数传递一个变量，而不能传递常量或字面量。你在实参前面加一个 &amp; 来标示这个参数是作为 inout 参数传入的。</p>

<pre><code>注意
inout 参数不能有默认值，也不能作为不定长参数。如果标记为 inout，也不能再标记let或者var。
</code></pre>

<pre><code class="swift">func swapTwoInts(inout a: Int, inout b: Int) {
    let temporaryA = a
    a = b
    b = temporaryA
}
</code></pre>

<p>调用时：</p>

<pre><code class="swift">var someInt = 3
var anotherInt = 107
swapTwoInts(&amp;someInt, &amp;anotherInt)
println("someInt is now \(someInt), and anotherInt is now \(anotherInt)")
</code></pre>

<pre><code>注意
inout参数和函数返回值不一样。
</code></pre>

<h5>函数类型</h5>

<p>每个函数都有函数类型，由参数类型和返回值类型组成。</p>

<pre><code class="swift">func addTwoInts(a: Int, b: Int) -&gt; Int {
    return a + b
}
func multiplyTwoInts(a: Int, b: Int) -&gt; Int {
    return a * b
}
</code></pre>

<p>上面两个函数的类型都是 (Int,Int) -> (Int)。读作一个函数类型，接受2个Int类型的参数，返回一个Int类型的值。</p>

<p>另一个例子：</p>

<pre><code class="swift">func printHello() {
    println("hello")
}
</code></pre>

<p>它的函数类型是 () -> ()，读作不接受参数，返回Void。</p>

<h6>使用函数类型</h6>

<p>使用函数类型和其他类型一模一样。</p>

<pre><code class="swift">var mathFunc: (Int,Int) -&gt; Int = addTwoInts
</code></pre>

<h6>函数类型作为参数类型</h6>

<p>可以把函数类型作为参数类型，这让调用者可以传入一个函数来帮助实现我们的函数。</p>

<pre><code class="swift">func printMathResult(mathFunction: (Int, Int) -&gt; Int, a: Int, b: Int) {
    println("Result: \(mathFunction(a, b))")
}
printMathResult(addTwoInts, 3, 5)
</code></pre>

<h6>函数类型作为返回值类型</h6>

<pre><code class="swift">func stepForward(input: Int) -&gt; Int {
    return input + 1
}
func stepBackward(input: Int) -&gt; Int {
    return input - 1
}
func chooseStepFunction(backwards: Bool) -&gt; (Int) -&gt; Int {
    return backwards ? stepBackward : stepForward
}
var currentValue = 3
let moveNearerToZero = chooseStepFunction(currentValue &gt; 0) //注：let而不是var
println("Counting to zero:")
// Counting to zero:
while currentValue != 0 {
    println("\(currentValue)... ")
    currentValue = moveNearerToZero(currentValue)
}
println("zero!")
</code></pre>

<h5>嵌套函数</h5>

<p>目前见到的所有函数都是全局函数，被定义在一个全局作用域内。我们也可以在函数内定义其他函数。</p>

<p>嵌套函数默认为外部是不可见的。但是可以被包含函数调用。包含函数也可以返回内嵌函数，让外部可以在其他作用域被调用。</p>

<pre><code class="swift">func chooseStepFunction(backwards: Bool) -&gt; (Int) -&gt; Int {
    func stepForward(input: Int) -&gt; Int { return input + 1 }
    func stepBackward(input: Int) -&gt; Int { return input - 1 }
    return backwards ? stepBackward : stepForward
}
var currentValue = -4
let moveNearerToZero = chooseStepFunction(currentValue &gt; 0)
// moveNearerToZero now refers to the nested stepForward() function
while currentValue != 0 {
    println("\(currentValue)... ")
    currentValue = moveNearerToZero(currentValue)
}
println("zero!")
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Language Guide: Control Flow]]></title>
    <link href="http://zxhfirefox.github.io/blog/2014/10/04/language-guide-control-flow/"/>
    <updated>2014-10-04T14:39:29+08:00</updated>
    <id>http://zxhfirefox.github.io/blog/2014/10/04/language-guide-control-flow</id>
    <content type="html"><![CDATA[<p>Swift提供了和类C语言相似的流程控制语句。包括for和while来做循环，if和switch来做分支，break和continue来做打断。</p>

<p>除了支持for，Swift还加入了for-in来简化字符串，数组，字典，区间和其他序列的遍历。</p>

<p>Swift的switch也比C的要强大许多，case不会默认的执行下一个case，避免了忘写break带来的bug。case也可以匹配其他的模式，包括字符串，区间，并且可以cast到某个特定类型。匹配的值可以绑定到临时变量，这样在case里面就可以使用，复杂的case可以通过添加where来表达。</p>

<p><em>注：这里很多的内容都是和C，ObjC一样的，所以很多地方都省略了，重点翻译了Swift里的特性和一些需要特别注意的地方。</em></p>

<h5>For循环</h5>

<p>两种：</p>

<ul>
<li>for-in</li>
<li>for</li>
</ul>


<h6>for-in</h6>

<p>使用for-in来循环遍历一个序列的元素。</p>

<pre><code class="swift">for index in 1...5 {
    println("\(index) times 5 is \(index * 5)")
}
</code></pre>

<p>上面的循环里，index是常量，每次遍历被赋予新值。</p>

<p>如果不需要每次遍历给出的值，可以用 _ 来接受遍历给出值。</p>

<h6>for</h6>

<p>和C一样的for循环。</p>

<pre><code class="swift">for var index = 0; index &lt; 3; ++index {
    println("index is \(index)")
}
</code></pre>

<p>index只在for循环语句内可见。如果想在for语句后访问index，必须在for语句之前声明。</p>

<p>注意如果在for循环外使用index的值，那么++index和index++是不一样的。</p>

<h5>while循环</h5>

<p>两种：</p>

<ul>
<li>while</li>
<li>do-while</li>
</ul>


<h6>while</h6>

<h6>do-while</h6>

<h5>条件语句</h5>

<p>if和switch</p>

<h6>if</h6>

<h6>switch</h6>

<p>switch语句必须是穷举的，这意味着，switch的所有case的组合必须覆盖了条件值可以取值的所有范围。</p>

<p>switch语句，不会在执行完一个case之后继续执行下一个case。</p>

<p>条件值，可以用范围来区分case。</p>

<pre><code class="swift">let count = 3_000_000_000_000
let things = "stars in the Milky Way"
var naturalCount: String
switch count {
case 0:
    naturalCount = "no"
case 1...3:
    naturalCount = "a few"
case 4...9:
    naturalCount = "several"
case 10...99:
    naturalCount = "tens of"
case 100...999:
    naturalCount = "hundreds of "
case 1000...999_999:
    naturalCount = "thousands of"
default:
    naturalCount = "millions of "
}
</code></pre>

<p>条件值，也可是元组。元组的每个元素都可以匹配，使用 _ 来匹配任意值。</p>

<pre><code class="swift">let somePoint = (1,1)
switch somePoint {
case (0,0):
    println("origin")
case (\_,0):
    println("x axis")
case (0,_):
    println("y axis")
case (-2...2,-2...2):
    println(" in a square")
defualt:
    println("out of square")
}
</code></pre>

<p>上面的例子里，和C不一样，Swift允许多个case包含相同的值，（0，0）满足4个分支。然而，如果有多个匹配，那么只执行第一个匹配。</p>

<p>switch的case可以把匹配的值绑定到临时变量，以便在case的代码中使用。</p>

<pre><code class="swift">let point = (2,0)
switch point {
case (let x,0):
    println("on x axis with x = \(x)")
case (0,let y):
    println("on y axis with y = \(y)")
case let (x,y):
    println("x = \(x), y = \(y)")
}
</code></pre>

<p>上面的x，y是常量，如果声明为var，也只能在case语句内改变。</p>

<p>switch的case可以使用where来表达复杂的case条件。</p>

<pre><code class="swift">let point = (1,-1)
switch point {
case let(x,y) where x == y:
    println("point on the line x == y")
case let(x,y) where x == -y:
    println("point on the line x == -y")
case let(x,y):
    println("arbitrary point")
}
</code></pre>

<h5>控制转换语句</h5>

<ul>
<li>continue</li>
<li>break</li>
<li>fallthrough</li>
<li>return</li>
</ul>


<h6>continue</h6>

<h6>break</h6>

<h6>fallthrough</h6>

<p>Swift里，switch的case默认不会fallthrough，如果需要，那么用fallthrough。</p>

<h6>标签语句</h6>

<p>嵌套switch或者循环在其他的switch和循环里，能够写出非常复杂的控制语句。然后循环和switch都使用break来终止执行。那么，如果能够明确的说明终止到哪一个循环或switch语句是很有用的。对于continue也有这样的使用场景。</p>

<p>为了达到这个目标，我们可以在循环或switch语句上加上标签，然后在break和continue的时候写上标签，来告诉程序跳转到哪里继续执行。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Language Guide: Collection Types]]></title>
    <link href="http://zxhfirefox.github.io/blog/2014/10/03/language-guide-collection-types/"/>
    <updated>2014-10-03T14:37:37+08:00</updated>
    <id>http://zxhfirefox.github.io/blog/2014/10/03/language-guide-collection-types</id>
    <content type="html"><![CDATA[<p>Swift提供了两种容器类型，数组和字典。数组相同类型对象的有序列表。字典存储相同类型的无序的值的组合，每个值都可以通过一个标示符（键）来查询。</p>

<p>Swift里数组和字典对他们所包含的值的类型是知道的。这意味着，你不能插入不同类型的值。这也意味着，当你从他们中取值时，取到的值的类型也是确定的。</p>

<pre><code>注意
数组和字典底层是通过泛型容器来实现的。
</code></pre>

<h5>容器的可变性</h5>

<p>如果你把一个容器附值给一个变量，它就是可变的，意味着你可以添加，删除，替换它里面的元素。相反，如果你把一个容器附值给一个常量，它就是不可变的，它的大小和内容就不能被改变。</p>

<pre><code>注意
如果可能，应该尽可能的声明不可变容器。
</code></pre>

<h5>数组</h5>

<p>数组有序的存储相同类型的值。相同的值可以出现多次。</p>

<p>Swift数组可以存储的值的类型是有限定的，不像ObjC的NSArray和NSMutableArray一样，他们不知道自己里面存的是什么类型的值。Swift数组对于它存储的值总是明确的，要么是明确写出类型，要么通过类型推断得到。这个类型不一定是类，可以是Int这样的类型。</p>

<h6>数组类型简写语法</h6>

<p>数组的类型，写全了是Array<SomeType>，也可以简写为[SomeType]。两者是一样的。</p>

<h6>数组字面量</h6>

<p>我们可以通过数组字面量来创建一个数组。数字字面量就是一系列值，用逗号隔开，包含在一组方括号里。</p>

<p>[value1, value2,value3]</p>

<pre><code class="swift">var shoppingList = ["apple","orange"]
</code></pre>

<h6>访问和修改数组</h6>

<p>通过数组的属性，方法，和角标可以访问数组的元素。</p>

<p>计算数组有多少元素，用count方法。</p>

<pre><code class="swift">println("the shopping list has \(shoppingList.count) items")
</code></pre>

<p>用isEmpty属性来判断count是否为0.</p>

<pre><code class="swift">if shoppingList.isEmpty {
    println("shopping list is empty")
}
</code></pre>

<p>通过append方法来给数组添加元素。</p>

<pre><code class="swift">shoppingList.append("banana")
</code></pre>

<p>或者，使用 += 来添加一个其他的数组的所有元素。</p>

<pre><code class="swift">shoppingList += ["book"]
shoppingList += ["pen", "butter"]
</code></pre>

<p>使用角标来获取数组的某个元素。</p>

<pre><code class="swift">var firstItem = shoppingList[0]
</code></pre>

<p>注意数组从0开始。</p>

<p>你也可以使用角标来修改数组的元素</p>

<pre><code class="swift">shoppingList[0] = "eggs"
</code></pre>

<p>还可以使用角标来批量修改数组某个范围的所有元素。</p>

<pre><code class="swift">shoppList[2...4] = ["display","computer"]
</code></pre>

<pre><code>注意
不能通过角标来给数组添加元素，如果你的角标超出了数组元素的个数，就是运行时错误。
</code></pre>

<p>使用insert（atIndex：）方法来在特定的位置插入元素</p>

<pre><code class="swift">shoppingList.insert"flower", atIndex:0)
</code></pre>

<p>同样的，使用removeAtIndex来删除某个特定位置的元素</p>

<pre><code class="swift">let flower = shoppingList.removeAtIndex(0)
</code></pre>

<p>删除造成的任何空缺都会被处理掉，所以数组的第一个元素已经改变。</p>

<p>你可以使用removeLast来删除最后一个元素。</p>

<h6>遍历一个数组</h6>

<p>使用for-in来遍历整个数组</p>

<pre><code class="swift">for item in shoppList{
    println(item)
}
</code></pre>

<p>如果你需要每个元素的索引，那么使用全局幻术enumerate来取代数组，enumerate函数会返回一个索引和元素的二元组。</p>

<pre><code class="swift">for (index,item) in enumerate(shoppingList) {
    println("Item\(index+1): \(item)")
}
</code></pre>

<h6>创建和初始化数组</h6>

<p>用下面的语法来创建一个特定类型的空数组</p>

<pre><code class="swift">var someInts = [Int]()
</code></pre>

<p>另外，如果上下文已经给出了类型信息，那么可以直接用[]来创建数组。</p>

<pre><code class="swift">someInts.append(3)
someInts = []
</code></pre>

<p>Swift的数组还提供了可以创建确定长度，并给出元素初始值的初始化函数。</p>

<pre><code class="swift">var threeDoubles = [Double](count:3,repeatedValue:0.0)
</code></pre>

<p>用 + 可以把两个数组合并为一个数组。</p>

<h5>字典</h5>

<p>字典是用来存储相同类型的值的容器，每个值都有一个唯一的key，作为这个值的标示。和数组不同，字典的元素是无序的。使用唯一的key来获取对应的值。</p>

<pre><code>注意
Swift的字典对于类型也是明确的，和ObjC的NSDictionary和NSMutableDictionay不同。
</code></pre>

<h6>字典类型简写</h6>

<p>字典的类型，写全了是Dictionary&lt;KeyType,ValueType>。可以简写为[KeyType : ValueType]，两者是一样的。</p>

<h6>字典字面量</h6>

<p>可以通过字典字面量来创建字典，和数组很相似。</p>

<p>[key1 : value1, key2 : value2, key3 : value3]</p>

<pre><code class="swift">var airports = ["TYO" : "Tokyo", "DUB" : "Dublin"]
</code></pre>

<h6>访问和修改字典</h6>

<p>通过方法，属性，或角标来访问和修改字典。字典内元素的个数用count计算。</p>

<pre><code class="swift">println("The airports dictionary has \(airports.count) items")
</code></pre>

<p>使用isEmpty来判断count是否为0.</p>

<pre><code class="swift">if airports.isEmpty {
    println("empty")
}
</code></pre>

<p>通过角标来添加元素。</p>

<pre><code class="swift">airports["LHR"] = "London"
</code></pre>

<p>也可以通过角标来改变元素。</p>

<pre><code class="swift">airports["LHR"] = "London Heathrow"
</code></pre>

<p>也可以使用updateValue（forKey：）来添加或更新值。和角标一样，如果没有旧的值，就添加，如果有，则更新。但是，和角标不一样，updateValue会返回旧的值，你可以通过这个判断是做了更新还是添加。</p>

<p>updateValue返回一个optional，所以你需要检查是否为nil。</p>

<p>你也可以用角标来获取某个key对应的值。但是因为这个值可能不存在，所以返回的是一个optional的值。使用的时候需要判断是否为nil。</p>

<pre><code class="swift">if let name = airports["DUB"] {
    println("the name is \(name)")
}else{
    println("no airport")
}
</code></pre>

<p>可以使用角标来删除某个key对应的元素。</p>

<pre><code class="swift">airports["APL"] = "Apple"
airports["APL"] = nil
</code></pre>

<p>另外，也可以使用removeValueForKey来删除键值对。如果有值，返回删除的值，如果没有，返回nil。</p>

<h6>遍历字典</h6>

<p>使用for-in来遍历字典，每次返回的时一个（key，value）的二元组。</p>

<pre><code class="swift">for (code, name) in airports {
    println("\(code) : \(name)")
}
</code></pre>

<p>你可以通过字典的keys或values属性来单独获得keys和values。</p>

<p>如果你需要把keys和values传递给一个需要数组的api，那么你需要用keys和values来创建一个数组。</p>

<pre><code class="swift">let codes = [String](airports.keys)
let names = [String](airports.values)
</code></pre>

<pre><code>注意
因为字典是无序的，那么获取keys，values或者key-value对的时候的顺序是不确定的。
</code></pre>

<h6>创建一个空的字典。</h6>

<pre><code class="swift">var namesOfInts = [String:Int]()
</code></pre>

<p>在上下文已知类型的时候可以使用 [ : ]来创建空的字典。</p>

<pre><code class="swift">namesOfInts = ["ten":10]
namesOfInts = [:]
</code></pre>

<h6>字典Key类型的哈希值</h6>

<p>一个类型要想作为字典的key，必须是可以哈希的。一个哈希值就是对于所有对象的一个值，用来判断两个值是否相等。</p>

<p>Swift的所有基础类型，String，Int，Double，Bool都默认有哈希值。没有关联值的枚举成员值默认也有哈希值。</p>

<pre><code>注意
你可以通过实现Hashable协议来让你自定义的值可以作为字典的key来使用。实现这个协议，必须定义一个Int类型的hashValue属性，还必须实现==操作符。
</code></pre>
]]></content>
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: swift | zxhfirefox's Blog]]></title>
  <link href="http://zxhfirefox.github.io/blog/categories/swift/atom.xml" rel="self"/>
  <link href="http://zxhfirefox.github.io/"/>
  <updated>2014-10-26T23:33:28+08:00</updated>
  <id>http://zxhfirefox.github.io/</id>
  <author>
    <name><![CDATA[zxhfirefox]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Language Guide: Conclusion]]></title>
    <link href="http://zxhfirefox.github.io/blog/2014/10/26/language-guide-h-conclusion/"/>
    <updated>2014-10-26T23:28:48+08:00</updated>
    <id>http://zxhfirefox.github.io/blog/2014/10/26/language-guide-h-conclusion</id>
    <content type="html"><![CDATA[<p>从9月14号开始翻译到今天（10月26号），终于很粗糙的把苹果关于Swift的第一篇文档（The Swift Programming Language）的重要部分（Welcome to Swift 和 Language Guie）翻译完毕。</p>

<p>关于语言参考（Language Reference）部分，我不打算翻译了，因为这些是一些语法定义的细节。大部分都是我们在工作不需要的，但是有一些部分是我们在使用Swift一些高级特性时最好知道的细节，所以，以后也许会单独的翻译那些细节。</p>

<p>在翻译过程中的一些问题需要在这里总结出来。</p>

<!-- more -->


<h4>特殊语境内，专业名词的翻译。</h4>

<p>对于这一个，我在翻译时有很多地方很纠结。有些专用的词我们应该给出比较专业的翻译，而我其实水平是达不到的。。。</p>

<p>想到的解决办法就是，首先，要有一个索引，来指出文章中的特殊的英文单词和我们翻译后的单词的对照。其次，在文章中使用到这个翻译的地方，同时给出原有英文。</p>

<h4>按照原文翻译，还是加入我们自己的理解</h4>

<p>这也是一个问题，开始很多地方，本来是想着按照原文的意思来翻译。后来发现有时候不太好表达，有时候原文很多废话，最后我也就会加入一些我自己的理解，并且直接忽略了一些无用的废话。</p>

<h4>最后</h4>

<p>看完这些，可能会觉得这次的翻译，对于我自己很有帮助，但是如果真的给别人去读，可能帮助并不大。。。</p>

<p>所以，这次的翻译，作为给读者的建议：</p>

<p>如果你能阅读原文，最好阅读原文。</p>

<p>如果你不能阅读原文，最好也参照原文来读。</p>

<h4>最最后</h4>

<p>苹果关于Swift总共2篇主要的文档，那么下面自然是要继续翻译下一篇。</p>

<p>Using Swift with Cocoa and Objective-C</p>

<p>这次，我会尽量改进前面说到的两个问题，不过也许可能大概改进不了多少= =</p>

<p>如果你读到了任何错误，请告诉我，谢谢。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Language Guide: Advanced Operators]]></title>
    <link href="http://zxhfirefox.github.io/blog/2014/10/26/language-guide-h-advanced-operators/"/>
    <updated>2014-10-26T23:28:03+08:00</updated>
    <id>http://zxhfirefox.github.io/blog/2014/10/26/language-guide-h-advanced-operators</id>
    <content type="html"><![CDATA[<p>除了在基础操作符里提到的那些操作符，Swift还提供了一些高级操作符。这些包含了位操作符。</p>

<p>和C里算数操作符不一样，Swift的算数操作符不会溢出。溢出行为会被捕获并报错。如果不想要这种行为，可以使用另外一套操作符，默认是会溢出的。所有这种操作符都是新加一个 &amp; 。</p>

<p>当我们定义自定义类时，我们可以提供一些Swift里的一些标准操作符。Swift简化了这一过程。</p>

<p>我们并不被限制在已有的操作符。Swift里我们可以定义任意的中缀，前缀和后缀，附值操作符，还可以自定义优先级和关联度。这些操作符可以在代码像已有操作符一样使用，我们甚至可以扩展已有操作符来支持自定义操作符。</p>

<!-- more -->


<h3>位操作符</h3>

<p>位操作符让我们可以处理数据结构里的单个原始数据，经常用于底层变成，例如，图形编程和设备驱动制作。位操作符在我们处理外来原始数据时也很有用，例如自定义协议的编码和解码。</p>

<p>Swift支持所有C定义的位操作符。</p>

<h4>按位取反</h4>

<p>~ 反转一个数字的所有位。</p>

<pre><code>    Input 00001111
          11110000 Result
</code></pre>

<p>按位取反操作符是前缀操作符，出现在操作数前，没有空格。</p>

<pre><code class="swift">let initialBits: UInt8 = 0b00001111
let invertedBits = ~initialBits  // equals 11110000
</code></pre>

<h4>按位与</h4>

<p>&amp; 把两个数组按位组合，结果的值只有两个参数都是1是才是1，其他都是0。</p>

<pre><code>    Input1 11111100
           00111100 Result
    Input2 00111111      
</code></pre>

<pre><code class="swift">let firstSixBits: UInt8 = 0b11111100
let lastSixBits: UInt8  = 0b00111111
let middleFourBits = firstSixBits &amp; lastSixBits  // equals 00111100
</code></pre>

<h4>按位或</h4>

<p>| 把两个数组按位组合，结果的值只要有1个参数都是1是就是1，其他都是0。</p>

<pre><code>    Input1 10110010
           11111110 Result
    Input2 01011110
</code></pre>

<pre><code class="swift">let someBits: UInt8 = 0b10110010
let moreBits: UInt8 = 0b01011110
let combinedbits = someBits | moreBits  // equals 11111110
</code></pre>

<h4>按位异或</h4>

<p>^ 操作符，组合两个数字，当两个数字位的值相同时，结果是0，不相同时是1。</p>

<pre><code>    Input1 00010100
           00010001 Result
    Input2 00000101
</code></pre>

<pre><code class="swift">let firstBits: UInt8 = 0b00010100
let otherBits: UInt8 = 0b00000101
let outputBits = firstBits ^ otherBits  // equals 00010001
</code></pre>

<h4>按位左移和右移操作符</h4>

<p>&lt;&lt; 和 >> 分别把一个数字的所有位向左和向右移动特定数字位。</p>

<p>按位移动操作符相当于对数字做乘以2的指数幂或除以2指数幂。往左一位相当于乘以2，往右相当于除以2.</p>

<h4>无符号整数的位移</h4>

<ol>
<li>现有位移动到指定的位置。</li>
<li>任何超出边界的位都被遗弃。</li>
<li>剩余空位补0.</li>
</ol>


<p>这种叫做逻辑位移。</p>

<pre><code class="swift">let shiftBits: UInt8 = 4   // 00000100 in binary
shiftBits &lt;&lt; 1             // 00001000
shiftBits &lt;&lt; 2             // 00010000
shiftBits &lt;&lt; 5             // 10000000
shiftBits &lt;&lt; 6             // 00000000
shiftBits &gt;&gt; 2             // 00000001
</code></pre>

<p>我们可以使用位移来编码和解码。</p>

<pre><code class="swift">let pink: UInt32 = 0xCC6699
let redComponent = (pink &amp; 0xFF0000) &gt;&gt; 16    // redComponent is 0xCC, or 204
let greenComponent = (pink &amp; 0x00FF00) &gt;&gt; 8   // greenComponent is 0x66, or 102
let blueComponent = pink &amp; 0x0000FF           // blueComponent is 0x99, or 153
</code></pre>

<h4>有符号整数的位移</h4>

<p>有符号的位移要比无符号数的位移复杂许多，主要是和有符号数在内存的表示方式有关。</p>

<p>有符号数使用第一位来作为符号位，标示正数还是负数。0是正数，1是负数。</p>

<p>剩余的位是值位，正数就是按照整数本身来存储的。</p>

<pre><code>    0 000 0100 = 4
</code></pre>

<p>负数，就不一样了，他们存储的是他们值的绝对值减掉2的n次幂，n是值位的个数。如果是Int8，那么n就是7，减去的就是128。</p>

<pre><code>    1 111 1100 = -4
    0 111 1100 = 124
</code></pre>

<p>负数的编码叫做补码。它有一些优点。</p>

<p>首先做加法时，我们可以直接加，包括符号位，然后舍弃任何超出范围的位。</p>

<pre><code>    0 1111 1100 = -4
+   0 1111 1111 = -1
=   1 1111 1011 = -5
</code></pre>

<p>其次，使用补码，我们在位移时可以像处理正数一样。但是有个额外的规则。
    *   在右移时，补位用符号位而不是0。</p>

<pre><code>    1111111         01111111
    11111111        001111111
</code></pre>

<p>这样就确保了在位移后，数字的符号位不会变化，叫做算数位移。</p>

<p>因为正数和负数存储的特殊方式，右移他们都是把它们向0靠近。保留符号位意味着负数还是负数，同时更加接近0。</p>

<h3>溢出操作符</h3>

<p>如果我们尝试把一个超出存储范围的数字附值给一个常量或变量，Swift会报错。</p>

<p>例如，Int16的值的范围是-32768到32767。</p>

<pre><code class="swift">var potentialOverflow = Int16.max
// potentialOverflow equals 32767, which is the largest value an Int16 can hold
potentialOverflow += 1
// this causes an error
</code></pre>

<p>在这种时候，我们需要提供错误处理。
    *   加   &amp;+
    *   减   &amp;-
    *   乘   &amp;*
    *   除   &amp;/
    *   取余 &amp;%</p>

<h4>值上溢出</h4>

<pre><code class="swift">var willOverflow = UInt8.max
// willOverflow equals 255, which is the largest value a UInt8 can hold
willOverflow = willOverflow &amp;+ 1
// willOverflow is now equal to 0
</code></pre>

<pre><code>    0 1111 1111 = 255
&amp;+  0 0000 0001 =   1
=   1 0000 0000 =   0
</code></pre>

<h4>值下溢出</h4>

<pre><code class="swift">var willUnderflow = UInt8.min
// willUnderflow equals 0, which is the smallest value a UInt8 can hold
willUnderflow = willUnderflow &amp;- 1
// willUnderflow is now equal to 255
</code></pre>

<pre><code>    0000 0000 = 0
&amp;-  0000 0001 = 1
=   1111 1111 = 255
</code></pre>

<p>有符号数也会发生下溢出。符号数减法时，所有位都参与，包括符号位。</p>

<pre><code class="swift">var signedUnderflow = Int8.min
// signedUnderflow equals -128, which is the smallest value an Int8 can hold
signedUnderflow = signedUnderflow &amp;- 1
// signedUnderflow is now equal to 127
</code></pre>

<pre><code>    1000 0000 = -128
&amp;-  0000 0001 = 1
=   0111 1111 = 127
</code></pre>

<p>上面的这些溢出的结构，都是在最大值后回到了最小值，或者最小值后回到了最大值。</p>

<h4>除以0</h4>

<p>当我们尝试除以0或者对0取余时，会报错。</p>

<pre><code class="swift">let x = 1
let y = x / 0
</code></pre>

<p>然后如果用溢出操作符时，返回0.</p>

<pre><code class="swift">let x = 1
let y = x &amp;/ 0
// y is equal to 0
</code></pre>

<h3>优先级和关联性</h3>

<p>操作符的优先级是说某些操作符优先于其他操作符进行计算。</p>

<p>操作符的关联性是说，如果两个相同优先级的操作符在一起时，是算到左边还是右边。这样想，他们和他们左边的表达式在一起，或者他们和他们右边的表达式在一起。</p>

<p>当我们考虑表达式如果计算时，优先级和关联性很重要。</p>

<pre><code class="swift">2 + 3 * 4 % 5
// this equals 4
</code></pre>

<pre><code>注意
Swift的操作符优先级和关联性和C，ObjC中得很相似，并且更可预测。但是这意味着他不一样，所以在使用时需要注意。
</code></pre>

<h3>操作符函数</h3>

<p>类和结构体可以提供现有操作符的自定义实现，这叫做操作符重载。</p>

<pre><code class="swift">struct Vector2D {
    var x = 0.0, y = 0.0
}
func + (left: Vector2D, right: Vector2D) -&gt; Vector2D {
    return Vector2D(x: left.x + right.x, y: left.y + right.y)
}
</code></pre>

<p>这个操作符函数被定义为全局函数，函数名和操作符匹配。因为是中缀操作符，所以有两个参数。</p>

<pre><code class="swift">let vector = Vector2D(x: 3.0, y: 1.0)
let anotherVector = Vector2D(x: 2.0, y: 4.0)
let combinedVector = vector + anotherVector
// combinedVector is a Vector2D instance with values of (5.0, 5.0)
</code></pre>

<h4>前缀和后缀操作符</h4>

<p>上面的例子是一个中缀操作符，类和结构体也可以提供一元操作符，可以区分前缀和后缀。</p>

<p>我们需要在函数前面写上 prefix 或 postfix来表示操作符是前缀还是后缀。</p>

<pre><code class="swift">prefix func - (vector: Vector2D) -&gt; Vector2D {
    return Vector2D(x: -vector.x, y: -vector.y)
}
</code></pre>

<pre><code class="swift">let positive = Vector2D(x: 3.0, y: 4.0)
let negative = -positive
// negative is a Vector2D instance with values of (-3.0, -4.0)
let alsoPositive = -negative
// alsoPositive is a Vector2D instance with values of (3.0, 4.0)
</code></pre>

<h4>组合附值操作符</h4>

<p>组合附值操作符把附值操作符（=）和其他操作符组合起来。例如，+=是说把加法和附值操作符合为一个操作符。我们实现时需要把一个参数定义为 inout。</p>

<pre><code class="swift">func += (inout left: Vector2D, right: Vector2D) {
    left = left + right
}
</code></pre>

<pre><code class="swift">var original = Vector2D(x: 1.0, y: 2.0)
let vectorToAdd = Vector2D(x: 3.0, y: 4.0)
original += vectorToAdd
// original now has values of (4.0, 6.0)
</code></pre>

<p>我们可以把前缀或后缀与组合附值操作符结合使用。</p>

<pre><code class="swift">prefix func ++ (inout vector: Vector2D) -&gt; Vector2D {
    vector += Vector2D(x: 1.0, y: 1.0)
    return vector
}
var toIncrement = Vector2D(x: 3.0, y: 4.0)
let afterIncrement = ++toIncrement
// toIncrement now has values of (4.0, 5.0)
// afterIncrement also has values of (4.0, 5.0)
</code></pre>

<pre><code>注意
我们无法重载默认的附值操作符（=）。另外，三元条件操作符（a?b:c）也不能被重载。
</code></pre>

<h4>相等操作符</h4>

<p>自定义的类和结构体，默认并会有 == 和 != 操作符。</p>

<pre><code class="swift">func == (left: Vector2D, right: Vector2D) -&gt; Bool {
    return (left.x == right.x) &amp;&amp; (left.y == right.y)
}
func != (left: Vector2D, right: Vector2D) -&gt; Bool {
    return !(left == right)
}
</code></pre>

<p>我们实现了 == 之后，在实现 != 时只需要取反即可。</p>

<pre><code class="swift">let twoThree = Vector2D(x: 2.0, y: 3.0)
let anotherTwoThree = Vector2D(x: 2.0, y: 3.0)
if twoThree == anotherTwoThree {
    println("These two vectors are equivalent.")
}
// prints "These two vectors are equivalent."
</code></pre>

<h3>自定义操作符</h3>

<p>我们可以自定义和实现一些操作符。</p>

<p>新的操作符，定义在全局范围，使用 operator 关键字，标示为 prefix，infix或者postfix。</p>

<pre><code class="swift">prefix operator +++ {}
</code></pre>

<p>我们定义了一个 +++ 操作符，它对于Swift没有任何意义。所以可以被用于Vector2D。</p>

<pre><code class="swift">prefix func +++ (inout vector: Vector2D) -&gt; Vector2D {
    vector += vector
    return vector
}
var toBeDoubled = Vector2D(x: 1.0, y: 4.0)
let afterDoubling = +++toBeDoubled
// toBeDoubled now has values of (2.0, 8.0)
// afterDoubling also has values of (2.0, 8.0)
</code></pre>

<h4>自定义中缀操作符的优先级和关联性</h4>

<p>我们自定义中缀操作符时，还需要给出优先级和关联性。</p>

<p>关联性可以是，left，right或none。默认是none。优先级默认是100。</p>

<pre><code class="swift">infix operator +- { associativity left precedence 140 }
func +- (left: Vector2D, right: Vector2D) -&gt; Vector2D {
    return Vector2D(x: left.x + right.x, y: left.y - right.y)
}
let firstVector = Vector2D(x: 1.0, y: 2.0)
let secondVector = Vector2D(x: 3.0, y: 4.0)
let plusMinusVector = firstVector +- secondVector
// plusMinusVector is a Vector2D instance with values of (4.0, -2.0)
</code></pre>

<pre><code>注意
我们在定义前缀和后缀操作符时，不需要给出优先级。但是如果我们一个操作数同时使用前缀和后缀操作符时，后缀操作符优先执行。
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Language Guide: Access Controll]]></title>
    <link href="http://zxhfirefox.github.io/blog/2014/10/26/language-guide-h-access-contoll/"/>
    <updated>2014-10-26T23:27:07+08:00</updated>
    <id>http://zxhfirefox.github.io/blog/2014/10/26/language-guide-h-access-contoll</id>
    <content type="html"><![CDATA[<p>访问控制限制了我们从其他源文件和模块的代码访问我们代码能力。这一特性可以让你隐藏你实现的细节，并且给出一个预先定义的接口来暴露可以被访问的代码。</p>

<p>我们可以把访问控制添加到类型级别（类，结构体，枚举），也可以添加到单独的属性，方法，初始化函数和角标。协议可以被限制到特性的上下文，就像全局常量，变量和函数。</p>

<p>除了增加不同程度的访问限制，Swift通过特定环境给出特定默认访问级别来减少了需要明确给出访问级别的代码。事实上，如果我们在写一个单目标（single-target）的app，我们或许永远都不需要明确给出访问限制。</p>

<pre><code>注意
我们代码里可以被添加访问限制的内容（属性，类型，方法等等）在下文中都被引用为“个体”（entity）。
</code></pre>

<!-- more -->


<h3>模块和源文件</h3>

<p>Swift的访问控制模型是基于模块和源文件的概念。</p>

<p>一个模块（module）是代码分发的一个单一单元，一个框架或一个app可以作为一个单一单元编译，它可以被其他模块使用import来导入。</p>

<p>在Xcode里的每一个编译目标都在Swift里作为分开的模块对待。如果我们把我们app的部分代码分开组织成一个独立的框架（或许是为了封装，然后可以在多个app里使用），那么所有在这个框架内的定义都会作为这个独立模块的一部分，然后就可以被导入到这个app和其他app内使用。</p>

<p>一个源文件是在一个模块里的一个单独的Swift源代码文件。尽管我们一般在一个源文件里只定义一个类型，但是单个源文件可以定义多个类型。</p>

<h3>访问级别</h3>

<p>Swift提供了三种访问级别。这些级别和个体（entity）定义的源文件有关，也和这些源文件属于的模块有关。
    *   public，允许在他们自己定义的模块里的任何源文件都可以使用，并且那些导入了这个模块的任何模块也能使用。通常，我们使用public来提供框架的公开API。
    *   internal，允许在他们自己定义的模块里的任何源文件都可以使用，但是不能被模块外的源文件使用。通常，我们使用interval来提供app或框架内部使用的结构。
    *   private，限制了只有在同一个源文件内可以使用。使用private来保护代码的实现细节。</p>

<p>public是最高的访问级别，private是最低的访问级别</p>

<h4>访问级别指引原则</h4>

<p>Swift的访问级别有一个总领的原则：没有个体的访问级别可以定义成其他的更低的访问级别。</p>

<p>例如：
    *   一个public的变量不能被定义成一个internal或private类型。因为这个类型或许不能在所有地方被访问到。
    *   一个函数不能有比他们参数和返回值更高的访问街边，因为函数可能在他的组成类型不可用的时候被调用。</p>

<h4>默认访问级别</h4>

<p>所有的个体（除了极少数），在你不明确给出访问级别时，默认的访问级别都是internal。这样，很多情况下你都不用给出访问级别。</p>

<h4>单目标app的访问级别</h4>

<p>当我们在写一个单目标的app时，所有app内的代码应该只能在app内访问。默认的访问级别internal已经满足这一要求。所以，我们不用特别给出访问级别。但是，我们或许在某些地方需要把一些实现定义为private。</p>

<h4>框架的访问级别</h4>

<p>当我们开发框架时，我们需要把框架的公开API定义成public的。</p>

<pre><code>注意
任何的框架内的实现都还是默认的internal，或是private。我们仅仅把公开的API设定为public
</code></pre>

<h3>访问控制语法</h3>

<p>我们使用public，internal，private关键字来表示访问控制。</p>

<pre><code class="swift">public class SomePublicClass {}
internal class SomeInternalClass {}
private class SomePrivateClass {}

public var somePublicVariable = 0
internal let someInternalConstant = 0
private func somePrivateFunction() {}
</code></pre>

<p>如果我们不需要特别给出，使用默认的internal时，我们就可以不写。</p>

<pre><code class="swift">class SomeInternalClass {}              // implicitly internal
var someInternalConstant = 0            // implicitly internal
</code></pre>

<h3>自定义类型</h3>

<p>当我们需要给自定义类型设置访问控制级别时，在定义时的时候给出即可，这样这些类型就可以在访问控制允许的地方被使用。</p>

<p>类型的访问控制级别也会影响它的成员（属性，方法，初始化函数，角标）的默认访问级别。如果类型的访问级别是private，那么所有成员都是private。如果类型的访问级别是internal或public，成员的默认访问级别就是internal。</p>

<pre><code>注意
如上所述，public的类型的方法默认是internal的，不是public的。如果我们希望某个成员是public，需要明确指出。
</code></pre>

<pre><code class="swift">public class SomePublicClass {          // explicitly public class
    public var somePublicProperty = 0    // explicitly public class member
    var someInternalProperty = 0         // implicitly internal class member
    private func somePrivateMethod() {}  // explicitly private class member
}
class SomeInternalClass {               // implicitly internal class
    var someInternalProperty = 0         // implicitly internal class member
    private func somePrivateMethod() {}  // explicitly private class member
}
private class SomePrivateClass {        // explicitly private class
    var somePrivateProperty = 0          // implicitly private class member
    func somePrivateMethod() {}          // implicitly private class member
}
</code></pre>

<h4>元组类型</h4>

<p>元组的访问级别是它的所有元素中访问级别最低的元素的访问级别。例如，如果一个元组含有2个不同类型的元素，一个internal，一个private，那么这个元组的访问级别就是private。</p>

<pre><code>注意
元组的访问级别并不和类，结构体，枚举，函数一样是单独定义的。它的访问级别实在使用时推断出来的，不能显式的定义。
</code></pre>

<h4>函数类型</h4>

<p>函数的访问级别是通过计算它的参数和返回值类型的最低访问级别决定的。如果函数计算后的访问级别和上下文默认的不一致，我们需要明确给出函数的访问级别。</p>

<pre><code class="swift">func someFunction() -&gt; (SomeInternalClass, SomePrivateClass) {
    // function implementation goes here
}
</code></pre>

<p>这个全局函数，没有明确给出访问级别，如果我们认为他是internal的，那就错了，事实上，这段代码无法编译。</p>

<p>这个函数的返回类型是一个元组，元组的元素一个是internal的类，一个是private的类。那么元组的访问级别就是private。</p>

<p>因为元组的访问级别是private的，我们需要把函数标示为private才能编译通过。</p>

<pre><code class="swift">private func someFunction() -&gt; (SomeInternalClass, SomePrivateClass) {
    // function implementation goes here
}
</code></pre>

<p>我们不能把这个函数标记为public或是默认的internal。因为这个函数使用者无法使用private的返回值。</p>

<h4>枚举类型</h4>

<p>枚举的各种情况自动和枚举的访问级别一致。我们没法给枚举的case单独给出访问级别。</p>

<pre><code class="swift">public enum CompassPoint {
    case North
    case South
    case East
    case West
}
</code></pre>

<p>上面定义这个枚举和他的case都是公开的。</p>

<h4>原始值和关联值</h4>

<p>枚举使用任何原始值和关联值的访问级别都必须枚举的访问级别要高。我们不能在一个internal的枚举里使用private的原始值或关联值。</p>

<h4>嵌套类型</h4>

<p>定义在private里的嵌套类型默认是private的。</p>

<p>定义在public里的嵌套类型默认是internal的。</p>

<p>如果我们希望一个在public里的嵌套类型是public的，我们明确给出。</p>

<h3>子类</h3>

<p>我们可以继承从当前上下文可以访问的任何类。子类的访问级别不会高于父类的，例如，我们无法继承自一个internal的，自身是public得类。</p>

<p>另外，我们可以重写任何的在上下文可以访问的父类的成员（方法，属性，初始化函数，角标）。</p>

<p>重写可以让子类的元素比父类更加可被访问。下面的例子里，public的类A，定义了private的方法someMethod，但是，子类B把someMethod重写成了internal。</p>

<pre><code class="swift">public class A {
    private func someMethod() {}
}
internal class B: A {
    override internal func someMethod() {}
}
</code></pre>

<p>甚至于子类的成员可以去调用父类的更低的访问许可的成员，只要这个父类的调用在上下文里是允许的（意思是，在一个源文件里，调用父类的private犯法，或是在一个模块里，调用父类的internal方法）。</p>

<pre><code class="swift">public class A {
    private func someMethod() {}
}
internal class B: A {
    override internal func someMethod() {
        super.someMethod()
    }
}
</code></pre>

<p>因为类A和B定义在一个源文件里，所以B的someMethod可以调用A的private的someMethod。</p>

<h3>常量，变量，属性和角标</h3>

<p>一个常量，变量，属性不能比他们的类型更加的公开。例如，我们不能给一个public的属性写一个private类型。同时，角标也不能比索引类型或返回类型更加公开。</p>

<p>如果一个常量，变量，属性或角标使用了private的类型，那么他们自己也必须是private的。</p>

<pre><code class="swift">private var privateInstance = SomePrivateClass()
</code></pre>

<h4>Getter和Setter</h4>

<p>常量，变量，属性和角标的Getter和Setter自动的和他们属于的常量，变量，属性和角标的访问级别一样。</p>

<p>我们可以给变量，属性，角标比他们的对应的getter更低的setter来限制写。通过在var和subscript前面写internal(set)和private(set)。</p>

<pre><code>注意
注意规则既可以在存储属性上使用，也可以在计算属性上使用。即使我们没有给存储属性明确的给出一个getter和setter。Swift会自动生成他们。
</code></pre>

<pre><code class="swift">struct TrackedString {
    private(set) var numberOfEdits = 0
    var value: String = "" {
        didSet {
            numberOfEdits++
        }
    }
}
</code></pre>

<p>TrackedString结构体的存储属性numberOfEdits被设置为private(set)。而value和TrackedString本身都是默认的internal。numberOfEdits的getter依然是默认的internal。</p>

<pre><code class="swift">var stringToEdit = TrackedString()
stringToEdit.value = "This string will be tracked."
stringToEdit.value += " This edit will increment numberOfEdits."
stringToEdit.value += " So will this one."
println("The number of edits is \(stringToEdit.numberOfEdits)")
// prints "The number of edits is 3"
</code></pre>

<p>事实上，如果需要我们可以显式给出getter和setter的访问级别。</p>

<pre><code class="swift">public struct TrackedString {
    public private(set) var numberOfEdits = 0
    public var value: String = "" {
        didSet {
            numberOfEdits++
        }
    }
    public init() {}
}
</code></pre>

<h3>初始化函数</h3>

<p>自定义的初始化函数的访问级别必须少于或等于他们的类型。除了需要的初始化函数，一个需要的初始化函数必须和它的类型有着同样的访问级别。</p>

<p>和函数和方法一样，初始化函数的参数的访问级别不能比初始化函数更低。</p>

<h4>默认初始化函数</h4>

<p>Swift会给任何的结构体和基类提供一个没有任何参数的默认初始化函数，只要这些结构体或基类的所有属性都有默认值，并且自己没有定义任何的初始化函数。</p>

<p>默认初始化函数的访问级别和类型的一致，除非类型是public的。如果类型是public的，默认初始化函数就是internal的。如果我们需要一个public的，我们需要自己定义。</p>

<h3>协议</h3>

<p>我们可以给协议也设置访问级别，这样可以限制实现协议的类型。</p>

<p>协议里所有的要求的访问级别和协议一致。</p>

<pre><code>注意
如果我们把协议定义为public，那协议的所有要求都必须是public的实现。这一点和其他类型不一样，一个public的类型可能有internal的成员。
</code></pre>

<h4>协议继承</h4>

<p>如果我们继承一个协议，那么新的协议至少要和已有协议一样的访问限制。我们不能继承一个internal的协议而定义成public的。</p>

<h4>协议实现</h4>

<p>类型可以实现比自己访问级别更低的协议。例如，我们定义一个public类型，然后可以实现一些internal的协议。</p>

<p>类型实现协议后的上下文是类型访问级别和协议访问级别的最小值。例如，如果类型是public，协议是internal，那么类型的协议实现就是internal。</p>

<p>如果我们写或者扩展一个类型来实现一个协议，我们必须确保类型对于协议要求的实现至少要和类型对于协议实现的访问级别一致。例如，如果一个public类型要实现一个internal的协议，那这个类型对于协议要求的实现至少要是internal的。</p>

<pre><code>注意
在Swift，和ObjC一样，协议实现是全局的，我们不可能在一个程序里，让一个类型通过两种不同的方式实现一个协议。
</code></pre>

<h3>扩展</h3>

<p>我们可以在当一个类，结构体，枚举可以被访问的时候扩展他们。在扩展里添加的任何成员都和原始成员一样有默认的访问级别。例如，如果我们扩展一个public类型，任何新添加的成员的默认访问级别都是internal。</p>

<p>但是，我们可以给扩展设置一个访问级别来修改所有扩展里添加的成员的访问级别。这个新设置的访问级别依然可以被单个成员的访问级别所覆盖。</p>

<h4>在扩展中实现协议</h4>

<p>如果一个扩展是用来实现协议，那么我们不能在这样扩展中重新给出扩展的访问级别。相反，协议本身的访问级别被用来给扩展里的新成员提供默认访问级别。</p>

<h3>泛型</h3>

<p>泛型函数和泛型类型的访问级别是他们本身和类型参数的访问级别的最小值。</p>

<h3>类型别名</h3>

<p>对于访问级别，任何的类型别名都被认为是独立的类型。一个类型别名可以有比原始类型更低或相等的访问级别。例如，一个私有类型别名可以作为一个private，internal，public的类型的别名，但是一个public的类型别名不能做为一个internal或private的类型的别名。</p>

<pre><code>注意
这一规则在实现协议时使用的关联类型同样适用。
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Language Guide: Generics]]></title>
    <link href="http://zxhfirefox.github.io/blog/2014/10/26/language-guide-generics/"/>
    <updated>2014-10-26T23:25:21+08:00</updated>
    <id>http://zxhfirefox.github.io/blog/2014/10/26/language-guide-generics</id>
    <content type="html"><![CDATA[<p>泛型可以帮助我们写出灵活的，可重用的函数和类型，他们可以使用任何类型来满足我们的要求。我们可以写出目的明确，抽象清晰的代码。</p>

<p>泛型是Swift最强大的几个特性之一，并且Swift的标准库很多都是用泛型来做的。事实上，我们可能没有意识到，但是我们已经一直在用泛型了。例如，Array和Dictionary类型都是泛型集合。我们可以创建一个元素为Int的数组，也可以创建一个元素为String的数组，或者其他任何Swift的类型。相同的，我们也可以创建不同类型的字典。</p>

<!-- more -->


<h3>泛型所解决的问题</h3>

<p>下面是交换2个Int的一个函数：</p>

<pre><code class="swift">func swapTwoInts(inout a: Int, inout b: Int) {
    let temporaryA = a
    a = b
    b = temporaryA
}
</code></pre>

<p>我们使用他们来交换2个整数。</p>

<pre><code class="swift">var someInt = 3
var anotherInt = 107
swapTwoInts(&amp;someInt, &amp;anotherInt)
println("someInt is now \(someInt), and anotherInt is now \(anotherInt)")
// prints "someInt is now 107, and anotherInt is now 3"
</code></pre>

<p>swapTwoInts是可用的，但是他只能交换两个Int，如果我们需要交换两个String，或者Double，我们就需要再写更多的方法，例如swapTwoStrings和swapTwoDoubles。</p>

<pre><code class="swift">func swapTwoStrings(inout a: String, inout b: String) {
    let temporaryA = a
    a = b
    b = temporaryA
}
func swapTwoDoubles(inout a: Double, inout b: Double) {
    let temporaryA = a
    a = b
    b = temporaryA
}
</code></pre>

<p>我们可以发现，这三个函数的函数体是很相似的，唯一不同的就是处理的参数类型。</p>

<p>如果我们可以写出一个函数，他可以交换任意两个类型，那么我们的代码就会很简洁，而泛型就是为了这一目的而存在的语言特性。</p>

<pre><code>注意
上面三个函数，有一个隐含的要求，就是a和b的类型是一样的，如果他们的类型不一样，也就不可能交换他们的值。
</code></pre>

<h3>泛型函数</h3>

<p>泛型函数可以使用任何值。</p>

<pre><code class="swift">func swapTwoValues&lt;T&gt;(inout a: T, inout b: T) {
    let temporaryA = a
    a = b
    b = temporaryA
}
</code></pre>

<p>swapTwoValues的函数体和swapTwoInts的完全一样，但是，函数的第一行区别很大。</p>

<pre><code class="swift">func swapTwoInts(inout a: Int, inout b: Int)
func swapTwoValues&lt;T&gt;(inout a: T, inout b: T)
</code></pre>

<p>泛型的版本，有一个占位符类型（这里是 T），而不是特定的某个类型（例如Int，String）。占位符类型没有说任何关于类型的信息，但是却表示了a和b必须是同一类型。真正的类型会在调用时决定。</p>

<p>另一个不同是泛型函数的名字后面跟着占位符类型，包裹在一个尖括号里。尖括号告诉Swift T是一个类型名字的占位符，因为他是占位符，Swift不会去寻找真实的T类型。</p>

<pre><code class="swift">var someInt = 3
var anotherInt = 107
swapTwoValues(&amp;someInt, &amp;anotherInt)
// someInt is now 107, and anotherInt is now 3
var someString = "hello"
var anotherString = "world"
swapTwoValues(&amp;someString, &amp;anotherString)
// someString is now "world", and anotherString is now "hello"
</code></pre>

<p>我们可以给swapTwoValues传递Int或String或任何类型。</p>

<pre><code>注意
swapTwoValues的名字来自于Swift的标准库的swap函数。如果我们需要，可以直接使用。
</code></pre>

<h3>类型参数</h3>

<p>在上面的例子里，T是一个类型参数。类型参数表示了一个占位符类型，紧跟着函数名，包裹在尖括号里。</p>

<p>我们表明一个类型参数之后，我们就可以定义这个类型的参数（例子里的a和b），或者返回值类型，或者在函数体里使用。不论如何，这个占位符类型都会被调用时的实际类型所取代。</p>

<p>我们可以提供多个类型参数，都写在尖括号里，逗号隔开。</p>

<h3>命名类型参数</h3>

<p>简单的情况下，泛型函数和泛型类型只会用到一个类型参数（例如上面的例子和Array），传统上就使用T来表示。然而我们可以使用任何符合规则的标示符。</p>

<p>如果我们在写比较复杂的泛型函数和泛型类型，他们需要多个类型参数，那么给类型参数一些有意义的名字就非常有意义了。例如，Swift的Dictionay类型，有两个类型参数，分别是Key和Value。</p>

<pre><code>注意
类型参数的名字应该是首字母大写的驼峰格式，这样说明他是一个类型的占位符。
</code></pre>

<h3>泛型类型</h3>

<p>除了泛型函数，Swift还允许我们定义自己的泛型类型。这些自定义的类，结构体，枚举可以使用任何类型作为类型参数，就和Array，Dictionary一样。</p>

<p>这部分我们将实现一个泛型的集合，栈。栈是一个有序的集合，和数组很像。但存取方式有很大区别，数组允许在任意地方存取，而栈，只能从最顶部的元素存取。</p>

<pre><code>注意
UINavigationController的push和pop，就是栈的一个很好的例子。在你需要后进先出得时候，就应该使用栈。
</code></pre>

<pre><code class="swift">struct IntStack {
    var items = [Int]()
    mutating func push(item: Int) {
        items.append(item)
    }
    mutating func pop() -&gt; Int {
        return items.removeLast()
    }
}
</code></pre>

<p>这是一个非泛型的栈的定义。我们用一个数组来作为内部存数的容器，然后实现push和pop。</p>

<pre><code class="swift">struct Stack&lt;T&gt; {
    var items = [T]()
    mutating func push(item: T) {
        items.append(item)
    }
    mutating func pop() -&gt; T {
        return items.removeLast()
    }
}
</code></pre>

<p>IntStack只能处理Int类型，我们把它改写为泛型之后，就可以处理任何类型。</p>

<p>注意，占位符类型T，在三个地方使用：
    *   创建一个items的属性，是T类型的一个空数组
    *   标明push函数接受的参数必须是T类型
    *   标明pop函数返回的类型是T类型</p>

<pre><code class="swift">var stackOfStrings = Stack&lt;String&gt;()
stackOfStrings.push("uno")
stackOfStrings.push("dos")
stackOfStrings.push("tres")
stackOfStrings.push("cuatro")
// the stack now contains 4 strings
</code></pre>

<pre><code class="swift">let fromTheTop = stackOfStrings.pop()
// fromTheTop is equal to "cuatro", and the stack now contains 3 strings
</code></pre>

<h3>扩展一个泛型类型</h3>

<p>当我们扩展一个泛型类型时，我们不需要在扩展定义时给出类型参数列表。原始类型的类型参数列表在我们的扩展内自动可见的，类型参数的名字也和原始类型一致。</p>

<p>下面，我们扩展Stack类型，添加一个返回顶部元素的只读的计算属性。</p>

<pre><code class="swift">extension Stack {
    var topItem: T? {
        return items.isEmpty ? nil : items[items.count - 1]
    }
}
</code></pre>

<p>注意，没有这里扩展没有给出类型参数，而是直接使用了Stack原始定义时的T。</p>

<pre><code class="swift">if let topItem = stackOfStrings.topItem {
    println("The top item on the stack is \(topItem).")
}
// prints "The top item on the stack is tres."
</code></pre>

<h3>类型限制</h3>

<p>swapTwoValues和Stack可以使用任何类型，但是，有时候我们需要限定只有特殊的类型才可以作为参数传递给泛型函数和泛型类型。类型限制就表明了类型参数必须是继承自某个类，或是必须实现了某个协议或协议组。</p>

<p>例如，Swift的Dictionary类型就限制了可以作为键的类型，这个类型必须是可以哈希的。也就是说，必须可以给出一种方式来使得自己是唯一的。而字典使用这个哈希来检查是否已经有相同的key存在，如果没有这个限制，字典就无法知道是否改插入还是替换某一个键，也无法根据键来找到对应的值。</p>

<p>这个要求是强制在Dictionary的键的类型上，必须实现Hashable协议。Swift的所有基础类型（Int，String，Double，Bool）都实现了这一协议。</p>

<p>我们可以定义自己的类型限制。像Hashable这样的抽象帮我们定义了一些概念上的特性，而不是特定的类型。</p>

<h4>类型限制语法</h4>

<p>我们在类型参数列表里的参数后面加上冒号，跟着需要继承的类或需要实现的协议来定义类型限制。</p>

<pre><code class="swift">func someFunction&lt;T: SomeClass, U: SomeProtocol&gt;(someT: T, someU: U) {
    // function body goes here
}
</code></pre>

<p>上面的函数，定义了两个类型参数，T和U，他们两个分别需要继承自SomeClass和实现SomeProtocol。</p>

<h4>类型限制实践</h4>

<p>下面是一个非泛型的函数，来在一个数组里查找某个值第一次出现的索引。</p>

<pre><code class="swift">func findStringIndex(array: [String], valueToFind: String) -&gt; Int? {
    for (index, value) in enumerate(array) {
        if value == valueToFind {
            return index
        }
    }
    return nil
}
let strings = ["cat", "dog", "llama", "parakeet", "terrapin"]
if let foundIndex = findStringIndex(strings, "llama") {
    println("The index of llama is \(foundIndex)")
}
// prints "The index of llama is 2"
</code></pre>

<p>这种查找，不单对于String需要，其他类型也会需要。所以我们应该写成泛型的。</p>

<pre><code class="swift">func findIndex&lt;T&gt;(array: [T], valueToFind: T) -&gt; Int? {
    for (index, value) in enumerate(array) {
        if value == valueToFind {
            return index
        }
    }
    return nil
}
</code></pre>

<p>我们这么写后，并没有办法编译，因为在我们检查value == valueToFind的时候，不是所有的Swift类型都定义了 == 操作符。比如我们自己定义的类型，相等的意义并不是Swift可以给我们提供的。所以我们无法保证每个T都满足要求。</p>

<p>尽管如此，Swift标准科定义了一个Equatable的协议，它需要任何实现的类型提供 == 和 != 操作符用来比较。所有的Swift标准类型都实现了这一协议。</p>

<p>那么所有的实现了Equatable得类型都是在findIndex中使用，这样我们就需要限制我们的类型必须是实现了Equatable协议的类型。</p>

<pre><code class="swift">func findIndex&lt;T: Equatable&gt;(array: [T], valueToFind: T) -&gt; Int? {
    for (index, value) in enumerate(array) {
        if value == valueToFind {
            return index
        }
    }
    return nil
}
let doubleIndex = findIndex([3.14159, 0.1, 0.25], 9.3)
// doubleIndex is an optional Int with no value, because 9.3 is not in the array
let stringIndex = findIndex(["Mike", "Malcolm", "Andrea"], "Andrea")
// stringIndex is an optional Int containing a value of 2
</code></pre>

<h3>关联的类型</h3>

<p>当我们定义协议的时候，可以声明一个或多个关联的类型来作为协议定义的一部分。一个关联的类型就是给定一个类型的占位符，然后可以在协议定义中使用。真实的类型，直到协议被真实实现的时候才会确定。关联的类型由 typealias 关键字声明。</p>

<h4>关联类型实践</h4>

<pre><code class="swift">protocol Container {
    typealias ItemType
    mutating func append(item: ItemType)
    var count: Int { get }
    subscript(i: Int) -&gt; ItemType { get }
}
</code></pre>

<p>我们定义了一个Container协议，里面关联了一个ItemType。</p>

<p>Container协议定义了一个方法来追加元素，一个属性来获取元素数量，一个角标来访问元素。</p>

<p>它没有说明，元素是如何存储的，也没有说明元素的类型是什么。一个实现这个协议的类型，只需要实现上面三点要求即可。</p>

<p>任何实现Container协议的类型必须可以说明它存储的元素类型。确切来讲，就是他必须保证只有正确的类型可以被添加到容器内，或者被访问。</p>

<p>为了描述这种要求，Container协议需要一种方法来说明容器元素的类型，但是它又不需要知道是什么类型。</p>

<p>为了达到这点要求，Container声明了一个关联类型ItemType。Container协议没有定义ItemType，而是把ItemType作为一种方式来表示容器内的元素类型，并在协议定义中使用它来确保协议的行为是正确的。</p>

<pre><code class="swift">struct IntStack: Container {
    // original IntStack implementation
    var items = [Int]()
    mutating func push(item: Int) {
        items.append(item)
    }
    mutating func pop() -&gt; Int {
        return items.removeLast()
    }
    // conformance to the Container protocol
    typealias ItemType = Int
    mutating func append(item: Int) {
        self.push(item)
    }
    var count: Int {
        return items.count
    }
    subscript(i: Int) -&gt; Int {
        return items[i]
    }
}
</code></pre>

<p>这是一个非泛型的Container协议的实现。它把ItemType定义为了Int。</p>

<p>因为Swift强大的类型推导，我们其实可以不写 typealias ItemType = Int，因为通过append方法，就可以推导出容器元素的类型了。</p>

<pre><code class="swift">struct Stack&lt;T&gt;: Container {
    // original Stack&lt;T&gt; implementation
    var items = [T]()
    mutating func push(item: T) {
        items.append(item)
    }
    mutating func pop() -&gt; T {
        return items.removeLast()
    }
    // conformance to the Container protocol
    mutating func append(item: T) {
        self.push(item)
    }
    var count: Int {
        return items.count
    }
    subscript(i: Int) -&gt; T {
        return items[i]
    }
}
</code></pre>

<p>这一次，我们用泛型的方式来实现Container容器，因为我们用T来作为append方法的参数的类型,Swift会把ItemType关联到T。</p>

<h4>扩展一个已有类型来给出关联类型</h4>

<p>我们可以通过扩展类型来增加协议的实现。这也包括了还有关联类型的协议。</p>

<p>Swift的Array已经提供了append方法，count属性和角标。这些正好满足了Container协议。这样我们就可以简单的写一个扩展来让Array实现Container协议。</p>

<pre><code class="swift">extension Array: Container {}
</code></pre>

<p>Array已有的append方法和角标会告诉Swift如何正确的推导ItemType的类型。</p>

<h3>Where分句</h3>

<p>类型限制，可以让我们定义关联到泛型函数和泛型类型的类型参数的要求。</p>

<p>有时候我们需要能给关联类型也定义要求。我们可以通过在类型参数列表上添加where分句来做到这一点。where分句使得我们可以要求一个关联的类型必须实现某个协议，或者某个类型参数和关联的类型必须一样。我们把where分句就写在类型参数列表的后面。</p>

<pre><code class="swift">func allItemsMatch&lt;
    C1: Container, C2: Container
    where C1.ItemType == C2.ItemType,C1.ItemType: Equatable&gt;
    (someContainer: C1,anotherContainer: C2) -&gt; Bool {
         // check that both containers contain the same number of items
        if someContainer.count != anotherContainer.count {
            return false
        }
        // check each pair of items to see if they are equivalent
        for i in 0..&lt;someContainer.count {
            if someContainer[i] != anotherContainer[i] {
                return false
            }
        }
         // all items match, so return true
        return true
}
</code></pre>

<p>allItemsMatch的函数有2个参数，他们都是实现了Container协议的容器，这里我们使用where分句添加了一些限制，使得整个参数的要求变成了：
    *   C1和C2都必须实现Container协议
    *   C1的ItemType和C2的ItemType必须一致
    *   C1的ItemType必须实现Equatable协议，因为C1和C2的ItemType一致，所以C2的ItemType也是实现了Equatable的。</p>

<p>第二，三个要求是由where分句增加的。</p>

<pre><code class="swift">var stackOfStrings = Stack&lt;String&gt;()
stackOfStrings.push("uno")
stackOfStrings.push("dos")
stackOfStrings.push("tres")

var arrayOfStrings = ["uno", "dos", "tres"]

if allItemsMatch(stackOfStrings, arrayOfStrings) {
    println("All items match.")
} else {
    println("Not all items match.")
}
// prints "All items match."
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Language Guide: Protocols]]></title>
    <link href="http://zxhfirefox.github.io/blog/2014/10/25/language-guide-w-protocols/"/>
    <updated>2014-10-25T10:26:20+08:00</updated>
    <id>http://zxhfirefox.github.io/blog/2014/10/25/language-guide-w-protocols</id>
    <content type="html"><![CDATA[<p>一个协议定义了一系列满足某些特定需要的方法，属性和其他要求的一个蓝图。协议本身并不提供这些要求的具体实现，它只负责描述这些要求。然后，协议可以被类，结构体，枚举来实现提供这些要求的真正实现。</p>

<p>协议可以要求实现协议的类型有特殊的实例属性，实例方法，类型方法，操作符和角标。</p>

<!-- more -->


<h3>协议语法</h3>

<p>定义协议和定义类，结构体，枚举很相似。</p>

<pre><code class="swift">protocol SomeProtocol {
    // protocol definition goes here
}
</code></pre>

<p>当类型实现协议时，把协议写在类型名字后面，由冒号隔开，多个协议之间由逗号分开。</p>

<pre><code class="swift">struct SomeStructure: FirstProtocol, AnotherProtocol {
    // structure definition goes here
}
</code></pre>

<p>如果类有父类，要把父类写在协议的前面。</p>

<pre><code class="swift">class SomeClass: SomeSuperclass, FirstProtocol, AnotherProtocol {
    // class definition goes here
}
</code></pre>

<h3>属性要求</h3>

<p>协议可以要求实现的类型提供实例属性或类属性。协议并不表明是存储属性还是计算属性，它只给出类型和名字，同时说明是只读的还是可读可写的。</p>

<p>如果一个协议规定的属性是可读可写的，那么实现类型不就能通过常量存储属性或只读计算属性来满足。如果协议规定的属性是只读的，那么实现类型可以通过任何属性来实现，就算你在实现时同时给出了setter也是可以的。</p>

<p>属性要求总是写成变量形式的。getter和setter用 set 和 get 标示。</p>

<pre><code class="swift">protocol SomeProtocol {
    var mustBeSettable: Int { get set }
    var doesNotNeedToBeSettable: Int { get }
}
</code></pre>

<p>类型属性总是用class 来标示，即使实现的类型是值类型，具体实现里用的是 static。</p>

<pre><code class="swift">protocol AnotherProtocol {
    class var someTypeProperty: Int { get set }
}
</code></pre>

<p>下面的例子:</p>

<pre><code class="swift">protocol FullyNamed {
    var fullName: String { get }
}
</code></pre>

<p>只定义了一个属性要求。</p>

<pre><code class="swift">struct Person: FullyNamed {
    var fullName: String
}
let john = Person(fullName: "John Appleseed")
// john.fullName is "John Appleseed"
</code></pre>

<p>Person实现了协议，通过一个存储的属性。</p>

<pre><code class="swift">class Starship: FullyNamed {
    var prefix: String?
    var name: String
    init(name: String, prefix: String? = nil) {
        self.name = name
        self.prefix = prefix
    }
    var fullName: String {
        return (prefix != nil ? prefix! + " " : "") + name
    }
}
var ncc1701 = Starship(name: "Enterprise", prefix: "USS")
// ncc1701.fullName is "USS Enterprise"
</code></pre>

<p>Starship也实现了这个协议，通过一个计算属性。</p>

<h3>方法要求</h3>

<p>协议可以要求实现类型去实现特定的实例方法和类型方法。这些方法在协议里的定义和他们实现时一模一样，只是没有大括号和函数体。变长参数也是可以的，规则和普通方法一样。</p>

<pre><code>注意
协议定义的方法和普通方法语法一样，但是不能允许给出参数默认值。
</code></pre>

<p>和类型属性要求一样，在类型方法要求前面添加 class 关键字。即使是值类型去实现这个方法。</p>

<pre><code class="swift">protocol SomeProtocol {
    class func someTypeMethod()
}
protocol RandomNumberGenerator {
    func random() -&gt; Double
}
</code></pre>

<p>上面是两个协议，一个定义了一个类型方法，一个定义了一个实例方法。</p>

<pre><code class="swift">class LinearCongruentialGenerator: RandomNumberGenerator {
    var lastRandom = 42.0
    let m = 139968.0
    let a = 3877.0
    let c = 29573.0
    func random() -&gt; Double {
        lastRandom = ((lastRandom * a + c) % m)
        return lastRandom / m
    }
}
let generator = LinearCongruentialGenerator()
println("Here's a random number: \(generator.random())")
// prints "Here's a random number: 0.37464991998171"
println("And another one: \(generator.random())")
// prints "And another one: 0.729023776863283"
</code></pre>

<h3>可变方法要求</h3>

<p>如果我们定义协议实例方法需要修改实例本身，我们也需要在协议定义中，给方法加上 mutating 关键字。这样使得结构体和枚举可以实现协议。</p>

<pre><code>注意
如果我们在协议定义时，给出 mutating，当我们用一个类实现协议时，就不用写 mutating，但是如果是结构体和枚举，是必须要写得。
</code></pre>

<pre><code class="swift">protocol Togglable {
    mutating func toggle()
}
</code></pre>

<p>我们定义了一个协议，包含一个mutating的方法。</p>

<pre><code class="swift">enum OnOffSwitch: Togglable {
    case Off, On
    mutating func toggle() {
        switch self {
        case Off:
            self = On
        case On:
            self = Off
        }
    }
}
var lightSwitch = OnOffSwitch.Off
lightSwitch.toggle()
// lightSwitch is now equal to .On
</code></pre>

<p>我们在枚举OnOffSwitch上实现了协议。</p>

<h3>初始化函数要求</h3>

<p>协议可以定义特殊的初始化函数要求。</p>

<pre><code class="swift">protocol SomeProtocol {
    init(someParameter: Int)
}
</code></pre>

<h4>类实现</h4>

<p>我们可以把协议要求的初始化函数实现为指定初始化函数或便利初始化函数，但是都需要加上 required。</p>

<pre><code class="swift">class SomeClass: SomeProtocol {
    required init(someParameter: Int) {
        // initializer implementation goes here
    }
}
</code></pre>

<p>使用 required 保证了我们给所有子类提供了显式的或是继承的初始化函数。</p>

<pre><code>注意
如果类是 final，则我们可以不写 required的。
</code></pre>

<p>如果一个子类重写了一个父类的指定初始化函数，并且实现了一个协议的初始化函数，required 和 override 则都需要写。</p>

<pre><code class="swift">protocol SomeProtocol {
    init()
}
class SomeSuperClass {
    init() {
        // initializer implementation goes here
    }
}
class SomeSubClass: SomeSuperClass, SomeProtocol {
    // "required" from SomeProtocol conformance; "override" from SomeSuperClass
    required override init() {
        // initializer implementation goes here
    }
}
</code></pre>

<h4>可失败的初始化函数要求</h4>

<p>协议可以定义可失败的初始化函数要求。</p>

<p>一个可失败的初始化要求可以被一个可失败的或者不可失败的初始化函数实现。一个不可失败的初始化函数可以被一个不可失败的或是一个自动解包的可失败初始化函数实现。</p>

<h3>协议也是类型</h3>

<p>协议不会提供它定义的任何要求的实现。然而，协议却可以作为一个类型来使用。</p>

<p>因为它也是类型，所以我们可以把它用在任何一个类型允许的地方。例如：
    *   作为参数或返回值
    *   作为常量，变量或属性
    *   作为字典，数组或其他集合的元素的类型</p>

<pre><code>注意
因为协议是类型，所以首字母应该大写
</code></pre>

<pre><code class="swift">class Dice {
    let sides: Int
    let generator: RandomNumberGenerator
    init(sides: Int, generator: RandomNumberGenerator) {
        self.sides = sides
        self.generator = generator
    }
    func roll() -&gt; Int {
        return Int(generator.random() * Double(sides)) + 1
    }
}
</code></pre>

<p>我们定义了Dice类，它有一个RandomNumberGenerator的属性。</p>

<pre><code class="swift">var d6 = Dice(sides: 6, generator: LinearCongruentialGenerator())
for _ in 1...5 {
    println("Random dice roll is \(d6.roll())")
}
// Random dice roll is 3
// Random dice roll is 5
// Random dice roll is 4
// Random dice roll is 5
// Random dice roll is 4
</code></pre>

<h3>代理</h3>

<p>代理，是一种设计模式，它可以让一个类或结构体把自己的一部分责任代理给其他类型的实例。这个设计模式通过把代理过去的责任封装到一个协议里，然后实现了协议的类型就可以作为代理来提供这部分功能。代理可以用来相应某些特定的时间，或者从不知道底层类型的数据获取数据。</p>

<pre><code class="swift">protocol DiceGame {
    var dice: Dice { get }
    func play()
}
protocol DiceGameDelegate {
    func gameDidStart(game: DiceGame)
    func game(game: DiceGame, didStartNewTurnWithDiceRoll diceRoll: Int)
    func gameDidEnd(game: DiceGame)
}
</code></pre>

<p>我们定义了2个协议，DiceGame和GiceGameDelegate。</p>

<pre><code class="swift">class SnakesAndLadders: DiceGame {
    let finalSquare = 25
    let dice = Dice(sides: 6, generator: LinearCongruentialGenerator())
    var square = 0
    var board: [Int]
    init() {
        board = [Int](count: finalSquare + 1, repeatedValue: 0)
        board[03] = +08; board[06] = +11; board[09] = +09; board[10] = +02
        board[14] = -10; board[19] = -11; board[22] = -02; board[24] = -08
    }
    var delegate: DiceGameDelegate?
    func play() {
        square = 0
        delegate?.gameDidStart(self)
        gameLoop: while square != finalSquare {
            let diceRoll = dice.roll()
            delegate?.game(self, didStartNewTurnWithDiceRoll: diceRoll)
            switch square + diceRoll {
            case finalSquare:
                break gameLoop
            case let newSquare where newSquare &gt; finalSquare:
                continue gameLoop
            default:
                square += diceRoll
                square += board[square]
            }
        }
        delegate?.gameDidEnd(self)
    }
}
</code></pre>

<pre><code class="swift">class DiceGameTracker: DiceGameDelegate {
    var numberOfTurns = 0
    func gameDidStart(game: DiceGame) {
        numberOfTurns = 0
        if game is SnakesAndLadders {
            println("Started a new game of Snakes and Ladders")
        }
        println("The game is using a \(game.dice.sides)-sided dice")
    }
    func game(game: DiceGame, didStartNewTurnWithDiceRoll diceRoll: Int) {
        ++numberOfTurns
        println("Rolled a \(diceRoll)")
    }
    func gameDidEnd(game: DiceGame) {
        println("The game lasted for \(numberOfTurns) turns")
    }
}
</code></pre>

<pre><code class="swift">let tracker = DiceGameTracker()
let game = SnakesAndLadders()
game.delegate = tracker
game.play()
// Started a new game of Snakes and Ladders
// The game is using a 6-sided dice
// Rolled a 3
// Rolled a 5
// Rolled a 4
// Rolled a 5
// The game lasted for 4 turns
</code></pre>

<h3>通过扩展来实现协议</h3>

<p>我们可以通过扩展一个类型来实现协议，即使我们拿不到这个类型的源代码。扩展可以添加属性，方法，角标，也可以添加协议的实现。</p>

<pre><code>注意
已有的实例也会具有新扩展实现的协议。
</code></pre>

<pre><code class="swift">protocol TextRepresentable {
    func asText() -&gt; String
}
</code></pre>

<pre><code class="swift">extension Dice: TextRepresentable {
    func asText() -&gt; String {
        return "A \(sides)-sided dice"
    }
}
</code></pre>

<p>我们扩展Dice来实现了TextRepresentable协议。</p>

<pre><code class="swift">let d12 = Dice(sides: 12, generator: LinearCongruentialGenerator())
println(d12.asText())
// prints "A 12-sided dice"
</code></pre>

<p>我们就可以使用asText方法了。</p>

<h4>通过扩展来声明协议实现</h4>

<p>如果一个类型已经实现了协议的所有要求，但是没有说明它实现了协议。我们可以通过一个扩展来说明。</p>

<pre><code class="swift">struct Hamster {
    var name: String
    func asText() -&gt; String {
        return "A hamster named \(name)"
    }
}
extension Hamster: TextRepresentable {}
</code></pre>

<pre><code class="swift">let simonTheHamster = Hamster(name: "Simon")
let somethingTextRepresentable: TextRepresentable = simonTheHamster
println(somethingTextRepresentable.asText())
// prints "A hamster named Simon"
</code></pre>

<p>这样，Hamster实例可以被当做TextRepresentable类型。</p>

<pre><code>注意
类型不是简单的满足协议的要求就算实现协议了，他们必须声明他们实现了协议。
</code></pre>

<h3>协议类型集合</h3>

<p>协议可以作为集合元素的类型。</p>

<pre><code class="swift">let things: [TextRepresentable] = [game, d12, simonTheHamster]
for thing in things {
    println(thing.asText())
}
// A game of Snakes and Ladders with 25 squares
// A 12-sided dice
// A hamster named Simon
</code></pre>

<p>注意thing的类型是TextRepresentable，而不是具体的其他类型。然而，因为它的类型是TextRepresentable，TextRepresentable能做的任何事情，它们都可以做。</p>

<h3>协议继承</h3>

<p>协议可以从一个或多个协议继承，而且还可以在这些基础上添加新的要求。协议的继承语法和类的继承语法是一样的。</p>

<pre><code class="swift">protocol InheritingProtocol: SomeProtocol, AnotherProtocol {
    // protocol definition goes here
}
</code></pre>

<pre><code class="swift">protocol PrettyTextRepresentable: TextRepresentable {
    func asPrettyText() -&gt; String
}
</code></pre>

<p>这里我们定义了一个新的协议，继承自TextRepresentable。</p>

<pre><code class="swift">extension SnakesAndLadders: PrettyTextRepresentable {
    func asPrettyText() -&gt; String {
        var output = asText() + ":\n"
        for index in 1...finalSquare {
            switch board[index] {
            case let ladder where ladder &gt; 0:
                output += "▲ "
            case let snake where snake &lt; 0:
                output += "▼ "
            default:
                output += "○ "
            }
        }
        return output
    }
}
println(game.asPrettyText())
// A game of Snakes and Ladders with 25 squares:
// ○ ○ ▲ ○ ○ ▲ ○ ○ ▲ ▲ ○ ○ ○ ▼ ○ ○ ○ ○ ▼ ○ ○ ▼ ○ ▼ ○
</code></pre>

<h3>只给类的协议</h3>

<p>我们可以限制实现协议的类型只能是类，而不能是结构体和枚举。通过在协议继承列表的最前面加一个 class 来限制实现协议的类型只能是类。</p>

<pre><code class="swift">protocol SomeClassOnlyProtocol: class, SomeInheritedProtocol {
    // class-only protocol definition goes here
}
</code></pre>

<pre><code>注意
仅当协议的实现需要区分值和引用的不同语意时使用只给类的协议。
</code></pre>

<h3>协议组合</h3>

<p>有时候要求一个类型同时实现多个协议是有用的。我们可以把多个协议组合成一个协议。写成protocol&lt;SomeProtocl, AnotherProtocol>。我们可以在尖括号里写任意多得协议。</p>

<pre><code class="swift">protocol Named {
    var name: String { get }
}
protocol Aged {
    var age: Int { get }
}
struct Person: Named, Aged {
    var name: String
    var age: Int
}
func wishHappyBirthday(celebrator: protocol&lt;Named, Aged&gt;) {
    println("Happy birthday \(celebrator.name) - you're \(celebrator.age)!")
}
let birthdayPerson = Person(name: "Malcolm", age: 21)
wishHappyBirthday(birthdayPerson)
// prints "Happy birthday Malcolm - you're 21!"
</code></pre>

<p>上面的例子里，我们定义2个协议，由一个结构体实现2个协议。定义了一个函数接受一个组合协议的类型。</p>

<pre><code>注意
协议组合并没有定义一个新的，永久的类型。相反，是临时的定义了一个局部的组合了其他协议的协议。
</code></pre>

<h3>检查协议实现</h3>

<p>我们可以使用 is 和 as 操作符来检查协议实现和把实例转换到特定协议类型。检查协议实现和检查类型是一样的。
    *   如果实例实现了协议，is 返回true，如果没有，返回 false。
    *   as？ 返回一个optional的协议类型，如果实例没有实现协议，返回nil。
    *   as 返回一个一个特定的协议类型，如果实例没有实现协议，运行时错误。</p>

<pre><code class="swift">@objc protocol HasArea {
    var area: Double { get }
}
</code></pre>

<pre><code>注意
如果我们要检查一个协议是否被实例实现，我们必须把协议标记上 @objc。这个标记意味着这个协议可以在ObjC代码中使用。即使你打算在ObjC中使用，你如果想对实例做检查，协议也必须标记为 @objc。

另外，标记为@objc的协议只能被类实现，而不能被结构体和枚举实现。
</code></pre>

<pre><code class="swift">class Circle: HasArea {
    let pi = 3.1415927
    var radius: Double
    var area: Double { return pi * radius * radius }
    init(radius: Double) { self.radius = radius }
}
class Country: HasArea {
    var area: Double
    init(area: Double) { self.area = area }
}
class Animal {
    var legs: Int
    init(legs: Int) { self.legs = legs }
}
let objects: [AnyObject] = [
    Circle(radius: 2.0),
    Country(area: 243_610),
    Animal(legs: 4)
]
for object in objects {
    if let objectWithArea = object as? HasArea {
        println("Area is \(objectWithArea.area)")
    } else {
        println("Something that doesn't have an area")
    }
}
// Area is 12.5663708
// Area is 243610.0
// Something that doesn't have an area
</code></pre>

<h3>可选的协议要求</h3>

<p>我们可以在协议里定义可选的要求。这些要求可以不被实现的类型实现。可选的要求前面用 optional来标示。</p>

<p>一个可选的协议要求可以使用optional链来调用，来检查一个类型实现了协议，但没有实现可选的要求。</p>

<p>我们在可选的要求后面加？来调用。可选的属性和方法，总会返回一个optional的值。来表示是否成功访问或调用，来反映这个可选的要求是否被实现。</p>

<pre><code>注意
可选的协议要求只能在@objc的协议里。
</code></pre>

<pre><code class="swift">@objc protocol CounterDataSource {
    optional func incrementForCount(count: Int) -&gt; Int
    optional var fixedIncrement: Int { get }
}
</code></pre>

<pre><code>注意
严格来说，我们可以定义一个类，实现CounterDataSource，但不给出任何实现。
</code></pre>

<pre><code class="swift">@objc class Counter {
    var count = 0
    var dataSource: CounterDataSource?
    func increment() {
        if let amount = dataSource?.incrementForCount?(count) {
            count += amount
        } else if let amount = dataSource?.fixedIncrement? {
            count += amount
        }
    }
}
</code></pre>

<pre><code class="swift">class ThreeSource: CounterDataSource {
    let fixedIncrement = 3
}
var counter = Counter()
counter.dataSource = ThreeSource()
for _ in 1...4 {
    counter.increment()
    println(counter.count)
}
// 3
// 6
// 9
// 12
class TowardsZeroSource: CounterDataSource {
    func incrementForCount(count: Int) -&gt; Int {
        if count == 0 {
            return 0
        } else if count &lt; 0 {
            return 1
        } else {
            return -1
        }
    }
}
counter.count = -4
counter.dataSource = TowardsZeroSource()
for _ in 1...5 {
    counter.increment()
    println(counter.count)
}
// -3
// -2
// -1
// 0
// 0
</code></pre>
]]></content>
  </entry>
  
</feed>

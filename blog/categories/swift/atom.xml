<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: swift | zxhfirefox's Blog]]></title>
  <link href="http://zxhfirefox.github.io/blog/categories/swift/atom.xml" rel="self"/>
  <link href="http://zxhfirefox.github.io/"/>
  <updated>2014-09-27T16:31:33+08:00</updated>
  <id>http://zxhfirefox.github.io/</id>
  <author>
    <name><![CDATA[zxhfirefox]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Language Guide: The Basics]]></title>
    <link href="http://zxhfirefox.github.io/blog/2014/09/27/language-guide-the-basics/"/>
    <updated>2014-09-27T15:54:49+08:00</updated>
    <id>http://zxhfirefox.github.io/blog/2014/09/27/language-guide-the-basics</id>
    <content type="html"><![CDATA[<p>Swift是一门iOS和OS X app开发的新语言，尽管如此，如果你用过C或者ObjC，Swift里很多部分你都不会陌生的。</p>

<p>Swift提供了C和ObjC所有的基础类型，包括Int来表示整数，Double和Float表示浮点数，Bool表示布尔值，String表示文本数据。Swift也提供了两个重要的集合类型，Array和Dictionary。</p>

<p>和C一样，Swift通过一个名字来标识变量，用变量来存储和引用相应的值。Swift也大量使用不可变的变量，也就是常量，但是要比C里的常量更加优秀。在你需要表示一些不可变的值的时候，使用常量让代码更安全，更清晰。</p>

<p>除了相似的类型，Swift也提供了在ObjC中没有的类型，例如元组。元组让你可以创建和传递一组值。你可以使用元组来把一组值作为一个组合的值从函数返回。</p>

<p>Swift也提出了Opional类型，用来表示一个没有的值。Optional表示要么这里有个值，就是x，要么这里就没有值。Optional有点像在ObjC中使用 nil,但是Optional可以用于任何类型，而不单是类。Optional比 nil指针更安全，而且更具有表达力，它也是Swift中许多特性的核心。</p>

<p>Optional是Swift是一个类型安全的语言的一个例子。Swift帮助你来清晰你的代码可以使用的类型。如果你的代码期望一个字符串，那么类型系统会禁止你传入一个整数。这样你就可以在开发阶段发现许多的错误。</p>

<h4>常量和变量</h4>

<p>常量和变量把一个名字（例如 maximumNumberOfLoginAttempts 或 welcomeMessage）和一个特定类型的值（例如 10 或者 &ldquo;Hello&#8221;）关联起来。常量的值，一旦设置之后就不能改变，而变量的值是可以改变的。</p>

<h5>声明变量和常量</h5>

<p>常量和变量必须在使用前被声明。用 let 来声明常量， var 来声明变量。下面这个例子：</p>

<pre><code class="ru">let maximumNumberOfLoginAttempts = 10
var currentLoginAttempt = 0
</code></pre>

<p>这段代码被理解为：</p>

<p>“声明一个常量，叫做 maximumNumberOfLoginAttempts，它的值是10。然后声明一个变量，叫做 currentLoginAttempt，它的初始值是 0.“</p>

<p>这个例子里，最大登录尝试次数是常量，而当前登录尝试次数是变量。</p>

<p>你可以在一行代码里声明多个常量或变量，用 , 分开：</p>

<pre><code class="ru">var x = 0.0, y = 0.0, z = 0.0
</code></pre>

<pre><code>注意
如果一个值不会改变，那么就把它声明为常量。只把那些会改变的值生命为变量。
</code></pre>

<h5>类型标注</h5>

<p>你可以在声明变量或常量时提供一个类型标注，来清晰的说明这个常量或变量可以存储的类型。在变量或常量的名字后面加一个冒号，一个空格，然后在跟上类型的名字。</p>

<p>下面这个例子里，表示了一个字符串类型的变量 welcomeMessage:</p>

<pre><code class="ru">var welcomeMessage: String
</code></pre>

<p>声明里的冒号，可以理解为&#8221;&hellip;的类型&hellip;&ldquo;，所以，上面的代码可以理解为，声明一个变量，它的名字叫 welcomeMessage， 它的类型是 String。</p>

<p>“它的类型是 String”的意思是可以存储任何字符串值。</p>

<p>welcomeMessage 现在就可以被附值给任何字符串值。</p>

<pre><code class="ru">welcomeMessage = "Hello"
</code></pre>

<p>你可以在一行代码里声明多个同一类型的变量，由逗号分开，只需要在最后一个变量的后面加上类型标注。</p>

<pre><code class="ru">var red, green, blue: Double
</code></pre>

<pre><code>注意
实际上你很少需要去写类型标注。如果你给变量或常量一个初始化值，Swift可以推断出这个值的类型。
</code></pre>

<h5>常量和变量命名</h5>

<p>常量和变量的名字可以包含几乎所有的字符，包含unicode字符：</p>

<pre><code class="ru">let 你好 = "你好，世界"
</code></pre>

<p>常量和变量的名字不能包含空格字符，数学符号，箭头，私有或错误的Unicode字符，画线或画方框字符。也不能用数字开头，但是数字可以在其他任何地方。</p>

<p>一旦你声明了一个特定类型的常量或变量，你就不能再声明同样名字的常量或变量，也不能用它来存储不同类型的值。也不能从一个变量改到常量，反之亦然。</p>

<pre><code>注意
如果你需要定义一个常量或变量，它的名字和Swift的关键字一样，那你需要用 ` 来包含这个名字。但是除非必要，你不应该使用这样的名字。
</code></pre>

<p>一个改变一个已有的变量的值为另一个类型匹配的值。下面的例子：</p>

<pre><code class="ru">var friendlyWelcome = "Hello!"
firendlyWelcome = "Bonjour!"
</code></pre>

<p>和变量不同，常量的值一旦设置就无法改变，尝试改变的话，编译就会出错。</p>

<pre><code class="ru">let languageName = "Swift"
languageName = "Swift++" //compile error
</code></pre>

<h5>打印常量和变量</h5>

<p>你可以用 println 函数来打印一个常量或变量的值：</p>

<pre><code class="ru">println(friendlyWelcome)
</code></pre>

<p>println 是一个全局函数，可以用来打印值到一个合适的输出，它会在最后打印一个换行符。在Xcode里，println 会打印到 console里。（还有一个函数，print，和println一样，但是不会打印换行符）</p>

<p>println 打印你传给它的任意字符串。</p>

<pre><code class="ru">println("This is a string")
</code></pre>

<p>println 函数可以打印更复杂的log信息，和Cocoa的NSLog一样。这些信息可以包含变量或常量的值。</p>

<p>Swift 使用字符串插入来把常量或变量的名字作为占位符插入到一个长字符串里，并让Swift用变量或常量到值来代替这个名字。把名字放到圆括号里，在圆括号前面加一个反斜杠：</p>

<pre><code class="ru">println("The current value of friendlyWelcome is \(friendlyWelcome)"
</code></pre>

<pre><code>注意
你在字符串插入时可用的选项在字符串插入中有详细介绍
</code></pre>

<h5>注释</h5>

<p>用注释来在代码中加入一段不会执行的文本，作为注解或给自己的提醒。注释在编译时会被忽略。</p>

<p>Swift注释和C的注释很相似。 单行注释由两个斜杠开始 (//):</p>

<pre><code class="ru">// a comment
</code></pre>

<p>多行注释开始于一个斜杠和一个星号 (/*)，结束于一个星号和一个斜杠 (*/)</p>

<pre><code class="ru">/* comment
with multiple lines */
</code></pre>

<p>和C不一样，Swift里多行注释可以嵌套在其他多行注释里。</p>

<pre><code class="ru ">/* first comment
/* senond comment nested in first comment */
end of first comment */
</code></pre>

<p>可以嵌套的多行注释让你在注释代码的时候非常方便。</p>

<h5>分号</h5>

<p>Swift不像其他很多语言，要求你在每一个语句后面都加上分号，不过如果你愿意，你可以加。但是如果你在一行代码里写了多个语句，分号就是必须的：</p>

<pre><code class="ru">let cat = "cat"; println(cat)
</code></pre>

<h5>整数</h5>

<p>整数是没有小数部分的数字，例如42和－32.整数可以有符号的（正数，0，负数），也可以是无符号的（正数，0）。</p>

<p>Swift提供了8，16，32，64位的有符号和无符号整数。这些整数都有和C很相似的规则，8位无符号整数的类型是 UInt8，32位有符号整数是 Int32。和Swift里其他类型一样，所有这些整数类型都是首字母大写的。</p>

<h6>整数边界</h6>

<p>你可以通过 min 和 max 属性来访问每一个整数类型的最小值和最大值。</p>

<pre><code class="ru">let minValue = UInt8.min
let maxValue = UInt8.max
</code></pre>

<p>这些属性的值都是对应不同数字类型的，所以可以在类型匹配的表达式中使用。</p>

<h6>Int</h6>

<p>绝大多数时间，你不需要选择特定大小的整数类型，Swift提供了一个额外的整数类型 Int，它和当前系统单个字的大小一致：
*   在32位系统上，Int就是Int32
*   在64位系统上，Int就是Int64</p>

<p>除非你需要特定长度的整数，就使用 Int 就好了。这样代码会更一致，更好操作。即使在32位系统上，Int的范围 －2,147,483,648到2,147,483,647在很多情况也足够大了。</p>

<h6>UIint</h6>

<p>Swift也提供无符号大整数，UInt，它也和当前系统单个字的大小一致。
*   在32位系统上，Int就是UInt32
*   在64位系统上，Int就是UInt64</p>

<pre><code>注意
仅仅在需要的时候使用 UInt，一致的使用Int可以帮助代码一致，减少不同类型之间转换和类型推断。
</code></pre>

<h5>浮点数</h5>

<p>浮点数是有小数部分的数字，例如3.1415, 0.1, -2.714。</p>

<p>浮点数比Int类型表示和存储的数字范围大出许多。Swift提供了两类浮点数：
*   Double 表示了64位的浮点数。
*   Float 表示了32位的浮点数。</p>

<pre><code>注意
Double至少有15个小数位，Float至少有6个小数位。
</code></pre>

<h5>类型安全和类型推断</h5>

<p>Swift是类型安全的语言。一个类型安全的语言鼓励你在代码中清晰的表述你需要的类型。例如如果你的代码需要一个String，那就不能传递一个Int。</p>

<p>因为Swift是类型安全的，它会在编译时把任何类型不匹配的都标示为错误。这样你就可以在开发阶段捕获和修复这些错误。</p>

<p>类型检查帮助你使用不同类型的时候避免错误。然而，这不代表你必须把每一个变量或常量的类型都写出来。如果你给出值的类型，Swift会通过类型推断来推导出相应的类型。类型推导可以在编译的时候，根据你提供的值来推导出对应的类型。</p>

<p>因为有了类型推导，Swift比C和ObjC而言，很少需要你给出类型。常量和变量都还是有类型的，但绝大多数工作都已经为你做好了。</p>

<p>类型推断，在你声明变量或常量的同时给予一个初始值的时候，非常方便。你在声明变量和常量时，直接赋给字面量（字面量是你在代码中直接出现的值，例如42和3.14）</p>

<p>比如，如果你给一个常量附值42，而没有给出类型，Swift会把它推断成为一个Int。</p>

<pre><code class="ru">let meaningOfLife = 42
</code></pre>

<p>同样，如果你给你常量附值一个浮点数，Swift会把它推断为Double。</p>

<pre><code class="ru">let pi = 3.14159
</code></pre>

<p>Swift在推断浮点数时总是优先选择Double。</p>

<p>如果你混合整数和浮点数在同一个表达式中，那么Double会成为表达式的值的类型。</p>

<pre><code class="ru">let anotherPi = 3 + 0.14159
</code></pre>

<p>字面量 3 并没有显式类型，所以Double成为了最后的推导结果。</p>

<h5>数字字面量</h5>

<p>整数字面量可以写为：
*   一个十进制数，没有前缀。
*   一个二进制数，0b前缀。
*   一个八进制数，0o前缀。
*   一个十六进制数，0x前缀。</p>

<p>下面的数字都表示了十进制的 17:</p>

<pre><code class="ru">let dec = 17
let bin = 0b10001
let oct = 0o21
let hex = 0x11
</code></pre>

<p>浮点数可以表示为十进制（无前缀）和十六进制（0x前缀）。它们必须在小数点两边都有数字。它们也可以有一个指数，十进制用大写或小写的e，十六进制用大写或小写的p。</p>

<p>有指数的十进制数，需要乘以以10为基的指数：
*   1.25e2，就是1.25*10*10，就是125.0
*   1.25e－2，就是1.25/100，就是0.0125</p>

<p>有指数的十六进制数，需要乘以以2为基的指数：
*   0xFp2，就是15*2*2,就是60.0
*   0xFp-2，就是15/4，就是3.75</p>

<p>下面这些字面量都是十进制的 12.1875:</p>

<pre><code class="ru">let dec = 12.1875
let exp = 1.21875e1
let hex = 0xC.3p0
</code></pre>

<p>数字字面量可以添加额外的格式来让它们更易读。整数和浮点数都可以加额外的0和包含下划线来提高可读性。这些格式不会改变字面量的值：</p>

<pre><code class="ru ">let pedding = 000123.456
let oneMillion = 1_000_000
let justOverOneMillion = 1_000_000.000_000_1
</code></pre>

<h5>数字类型转换</h5>

<p>在一般情况下使用Int类型，即使这个值可能不会为负的。使用默认整数类型使得字面量也可以很好匹配。</p>

<p>在一些特殊情况下，例如数据来自外部，为了提供性能，优化内存使用或其他优化，可以使用特殊大小的整数类型。使用这些整数类型可以有效的捕获边界溢出。</p>

<h6>整数转换</h6>

<p>不同的整数类型所能存储的整数范围是不一样的。一个Int8类型只能存－128到127，而UInt8只能存0到255。如果尝试把范围外的值赋给一个变量或常量，会报编译错误。</p>

<pre><code class="ru">let cannotBeNegative: UInt8 = -1
let tooBig: Int8 = Int8.max + 1
</code></pre>

<p>因为每一个数字类型都能存不同范围的值，你必须在每种情况下来做类型转换。这种转换可以避免转换错误，并且使得代码里类型转换是明确的。</p>

<p>要把一个数字类型转到另一个类型，你用现有的值去初始化一个需要类型的变量或常量。下面的例子里：</p>

<pre><code class="swift">let twoThousand: UInt16 = 2_000
let one: UInt8 = 1
let twoThousandAndOne = twoThousand + UInt16(one)
</code></pre>

<p>常量one和twoThousand不是同一类型的，所以不能做加法，需要把one转到UInt16来做。</p>

<p>SomeType(ofInitialValue)是调用一个类型的初始化函数（initializer），并传给它一个初始值的默认方式。在底层，UInt16有一个初始化函数，接受一个UInt8值来初始化这个UInt16值。这里你不能传递任何类型，而必须是UInt16提供了初始化函数的类型。我们将在扩展中讲解如何扩展现有的类型来提供能够接受新类型的初始化函数。</p>

<h6>整数和浮点数转换</h6>

<p>在整数和浮点数之前转换必须是显式的：</p>

<pre><code class="swift">let three = 3
let pointOneFourOneFiveNine = 0.14159
let pi = Double(three) + pointOneFourOneFiveNine
</code></pre>

<p>这里，three被用来创建一个Double值，这样加号两边都是同一类型。如果没有这个转换，加法运算式不允许的。</p>

<p>浮点数到整数的转换也必须式显式的：</p>

<pre><code class="ru">let integerPi = Int(pi)
</code></pre>

<p>像这样用浮点数初始化整数，浮点数总是被截断的。这意味着4.75变成4，－3.9变成－3.</p>

<pre><code>注意
变量和常量的组合和字面量的组合不一样。字面量3和字面量0.14159可以直接相加而不用类型转换。结果的类型会在计算完毕后由编译器推导出来。
</code></pre>

<h5>类型别名</h5>

<p>类型别名允许给现有类型定义一个别名。使用typealias来定义。</p>

<p>当你需要使用一个更加有意义的名字来替换现有的类型的时候，类型别名是很有用的。例如：</p>

<pre><code class="ru">typealias AuidoSample = UInt16
</code></pre>

<p>一旦你定义了一个类型别名，那你就可以把它当作原来的类型使用。</p>

<pre><code class="ru">var maxAmplitudeFound = AudioSample.min
</code></pre>

<p>这里，AudioSample是UInt16的别名。所以可以调用min来获取UInt16的最小值。</p>

<h5>布尔值</h5>

<p>Swift提供一个布尔类型，叫Bool。布尔值可以理解为逻辑值，因为它们只能是true或者false。Swift提供了2个布尔常量，true和false。</p>

<pre><code class="ru">let orangesAreOrange = true
let turnipsAreDelicious = false
</code></pre>

<p>orangesAreOrange和turnipsAreDelicious都被推断为Bool类型。和上面的Int和Double一样，你不需要写出类型，而只需要用true或false来初始化它们。类型推导使得代码更简练，更可读。</p>

<p>布尔值在用在条件判断的时候非常有用，例如if：</p>

<pre><code class="ru">if turnipsAreDelicious {
    println("Mmm,tasty turnips!")
}else{
    println("Eww,turnips are horrible.")
}
</code></pre>

<p>条件语句将在流程控制中详细讲解。</p>

<p>Swift的类型安全不允许把非布尔值作为布尔值使用。下面的会编译错误：</p>

<pre><code class="ru">let i = 1
if i {
}
</code></pre>

<p>然而，下面的是可以的：</p>

<pre><code class="ru">let i = 1
if i == 1{
}
</code></pre>

<p>i == 1 的结果是布尔类型，所以下面的代码是对的。操作符在基本操作符中介绍。</p>

<p>和其他类型安全的例子一样，这样做可以避免不小心的错误，并使得代码的意图总是很清楚。</p>

<h5>元组</h5>

<p>元组把多个值组合成为一个单独的值。元组里的值可以是任何的值，而且可以不一样。</p>

<p>下面的例子里，（404,&ldquo;Not Found&rdquo;)是一个表示http状态码的元组，一个http状态码是你访问一个web服务器返回的一个特定值，404表示你请求的网页不存在。</p>

<pre><code class="ru">let http404Error = (404,"Not Found")
</code></pre>

<p>这个元组，组合了一个整数和一个字符串，一个数字和一个人类可读的描述。它可以理解为一个类型是(Type,String)的元组。</p>

<p>你可以从任何类型的组合来创建元组，它们可以包含任意多不同的类型。</p>

<p>你可以把元组多值拆解出来：</p>

<pre><code class="ru">let (statusCode, statusMessage) = http404Error
println("code is \(statusCode)")
println("message is \(statusMessage)")
</code></pre>

<p>如果你只需要某些元组的值，那在你拆解元组的时候，用 _ 来忽略你不需要的值：</p>

<pre><code class="ru">let (justCode,_) = http404Error
println("code is \(justCode)")
</code></pre>

<p>另外，你可以通过索引值来访问的元组值，从0开始：</p>

<pre><code class="ru">println("code is \(http404Error.0)")
println("message is \(http404Error.1)")
</code></pre>

<p>你也可以在创建元组时，给每一个单独的元素定一个名字：</p>

<pre><code class="ru">let http200Status = (statusCode: 200, description: "OK")
</code></pre>

<p>如果元组的元素有名字，那你可以直接通过这些名字来访问这些元素：</p>

<pre><code class="ru">println("code is \(http200Status.statusCode)")
println("message is \(http200Status.description)")
</code></pre>

<p>元组在函数需要返回多个值的时候非常有用。比如一个函数用来获取网页可以返回一个(Int,String)的元组，这样可以把更多有用的信息返回给调用者。</p>

<pre><code>注意
元组只是在把相关的值组合起来时很方便，但是不应该被用来创建复杂的数据结构。复杂的数据结构应该用类或结构体来表示。
</code></pre>

<h5>Optionals</h5>

<p>当一个值可能不存在的时候，你就需要Optionals。一个Optional的意思是
*   如果有值，那么它就是这个值
*   如果没有值，那就是根本没有值</p>

<pre><code>注意
optional的概念在C和ObjC中不存在。最相似的是ObjC的函数可以返回nil表示值的不存在。然而，ObjC的nil只能用于对象，不能用于基础类型，结构体和枚举，对于这些类型，ObjC返回某个特定的值来表示值不存在。这里意味着调用者知道这个特殊值的意思是没有值。Swift的Optional允许你来表示对于任何类型的值不存在的情况，不需要其他特殊常量。
</code></pre>

<p>下面这个例子说明 optional是非常有用的。String有个toInt的方法，它尝试把String转换到一个Int。然而，不是所有的字符串都能转换到整数，&#8221;123“可以转换到123，但是&#8221;hello&#8221;却不行。</p>

<pre><code class="ru">let possibleNumber = "123"
let convertedNumber = possibleNumber.toInt()
</code></pre>

<p>因为toInt可能失败，所以它返回一个optional的Int，而不是Int。一个optional的Int,写成Int?，而不是Int。问号的意思是这个值可能存在，也可能不存在。</p>

<h6>nil</h6>

<p>你给一个optional附值为 nil， 可以把一个optional的值设置为无值的状态。</p>

<pre><code class="ru">var serverResponseCode: Int? = 404
serverResponseCode = nil
</code></pre>

<pre><code>注意
nil不能用于非optional的常量或变量。如果你需要这种不存在的状态，你需要把变量和常量声明为optioanl的。
</code></pre>

<p>如果你声明一个optional的值，而没有给初始值，那它会附值为 nil。</p>

<pre><code class="ru">var surveyAnswer: String?
</code></pre>

<pre><code>注意
Swift的nil和ObjC的nil不一样，在ObjC里，nil表示一个不存在的对象。而在Swift里，nil不是指针，它是某个类型的值不存在的表现。任何类型的optional都可以设置为nil，不仅仅是对象。
</code></pre>

<h6>if语句和强制解包（unwrap）</h6>

<p>你可以用if语句，拿optioanl和nil比较来知道这个optional是否包含一个值。</p>

<p>如果一个optional包含值，那么它就不等于nil：</p>

<pre><code class="ru">if convertedNumber != nil {
    prinln("has a number")
}
</code></pre>

<p>一旦你确定optional确实包含一个值，那么你可以在optional的名字后面加一个感叹号 ！来访问它所包含的值。这个感叹号的意思是说，“我知道里面有值，请使用这个值”，这就叫做强制解包：</p>

<pre><code class="ru">if convertedNumber != nil {
    prinln("has an integer \(convertedNumber!)")
}
</code></pre>

<pre><code>注意
如果用 ！尝试访问一个不存在值的optional，将造成运行时错误。所以必须在确认optional有值的情况下使用！
</code></pre>

<h6>optional绑定</h6>

<p>使用optional绑定来查看一个optional是否还有值，如果有，则把它绑定到一个临时的常量或变量上。optional绑定可以用在if和while语句中来查看otional的值，并把值拿出来给后续使用。</p>

<p>我们可以重写上面的例子：</p>

<pre><code class="ru">if let actualNumber = possibleNumber.toInt() {
    println("actualNumber \(actualNumber)")
}else{
    println("not a number")
}
</code></pre>

<p>这段代码的意思是 “如果possibleNumber.toInt()返回的optional还有一个值，把这个值附值给actualNumber“。</p>

<p>如果这个转变成功了，这个actualNumber就可以在if的第一个分支里使用，并且被optional的值初始化了，所以就不用 ！来访问真正的值了。</p>

<p>optional绑定里，你可以使用常量或变量。如果你打算在if的第一个分支里改变actualNumber的值，你可以下 if var actualNumber，这样optional的值就成为一个变量而不是常量。（[zxh]，这里改变的也是actualNumber，而不是optional本身，如果在绑定一次，值其实没有彼岸花）。</p>

<h6>自动解包的Optional</h6>

<p>如上所述，optional暗示了一个常量或变量可能是没有值的。optional可以通过if语句来查看是否有值，也可以通过optional绑定而被有条件的解包来使用真正的值。</p>

<p>有些时候，从程序结构的角度来说，如果一个optional如果被设置之后，它将永远都会有个值。在这种情况下，如果能够不用在每次需要访问这个值的时候去检查并且解包的话，是非常有意义的，因为我们可以确认它肯定有值。</p>

<p>这一类optional被定义为自动解包的optional。你在optional的类型后面，不写？而写一个！来标示它是一个自动解包的optional。</p>

<p>当一个optional的值可以确认在第一次定义之后永远都有一个值，使用自动解包的optional是有意义的。它的主要应用场景是在类初始化的时候。</p>

<p>在底层，自动解包的optional还是个optional。但是可以被当作非optional来用，不需要每次都解包。下面的例子展示了自动解包的optional和普通optional的区别：</p>

<pre><code class="ru">let posiibleString: String? = "an optional string"
let forcedString: String = possibleString!

let assumedString: String! = "an implicitly unwrapped optional string"
let implicitString: String = assumedString
</code></pre>

<p>你可以认为自动解包的optional在每次被访问的时候都自动的被解包了。而不用每次访问都在后面加！，只需要在声明的时候在类型后面加！。</p>

<pre><code>注意
如果你在一个自动解包的optional不包含值的时候访问了它，这会是个运行时错误。这和普通optional的情况一模一样。
</code></pre>

<p>你也可以把自动解包的optional当作普通的optional来用：</p>

<pre><code class="ru">if assumedString != nil {
    println(assumedString)
}
</code></pre>

<pre><code>注意
如果一个optional在某个时间会没有值，那就不要使用自动解包的optional。对于在声明周期中有可能为nil的时候总是用普通的optional。
</code></pre>

<h5>断言</h5>

<p>optionals让你可以检查一个可能存在也可能不存在的值，并在不存在值的时候写出优雅的处理方式。但是有些时候，如果一个值不存在，程序就无法继续进行。这时候，你应该使用断言来结束代码的执行来调试出现值不存在的原因。</p>

<h6>使用断言来调试</h6>

<p>一个断言是在运行时对一个条件是否为true的检查。从字面意思说就是，断言一个条件为true。在执行任何代码之前，使用断言来确定某个特定的条件为true。如果为true，代码执行，如果为false，代码停止执行，程序退出。</p>

<p>如果你在开发阶段触发了断言，那么就能清楚的看到这个断言的位置，并可以查看造成断言的原因。断言也允许你提供一些调试信息。</p>

<p>使用全局函数 assert 来写一个断言。传给她一个条件表达式，和当条件表达式是false的时候的一个提示信息。</p>

<pre><code class="ru">let age = -3
assert(age &gt;= 0, "a age can not be less than 0")
</code></pre>

<p>这个例子了，如果age >= 0为true，后续代码执行，如果为false，则程序退出。</p>

<p>断言信息不是必须的。</p>

<pre><code class="ru">assert(age &gt;= 0)
</code></pre>

<h6>何时使用断言</h6>

<p>当一个条件有可能是false，但是你的代码又要求它必须是true的时候使用断言。比较好的地方如下：</p>

<ul>
<li>把一个脚标传入到一个自定义的脚标实现，这个值可能越界。</li>
<li>给函数传值，但是这个值不符合函数的要求。</li>
<li><p>optional为nil，但是你需要它不是nil。</p>

<pre><code>注意
断言会使程序退出，并不代表需要你设计你的代码让不符合条件的情况不会发生。然而，在开发阶段，断言是发现这些可能造成不符合条件的情况是非常有效的办法。
</code></pre></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Welcome to Swift - A Swift Tour]]></title>
    <link href="http://zxhfirefox.github.io/blog/2014/09/14/welcome-to-swift-a-swift-tour/"/>
    <updated>2014-09-14T18:29:00+08:00</updated>
    <id>http://zxhfirefox.github.io/blog/2014/09/14/welcome-to-swift-a-swift-tour</id>
    <content type="html"><![CDATA[<p>传统来说，我们学习一门语言的第一个程序将是HelloWorld。在Swift里，非常简单：</p>

<pre><code class="ru">println("Hello,World")
</code></pre>

<p>如果你之前写过C或者Objc的代码，这个语法你应该不陌生，在Swift里，这行代码就是一个完整的程序，你不需要导入其他库来使用输入输出或者字符串处理。写在全局作用域的代码被用来作为程序的入口，所以你不需要一个main函数。你也不用在每一个语句后面写上分号。</p>

<p>这里我们将通过许多的例子来给你足够的知识让你能够开始用Swift写代码。遇到不能理解的地方也不要紧，这里的所有内容在这本书的剩余部分都会详细介绍。</p>

<h4>Simple Values （基础值）</h4>

<p>用let来声明常量，var声明变量。常量的值不需要在编译期知道，但是你只能赋值一次，这意味着你用常量来定义一次，然后在很多地方使用。</p>

<pre><code class="ru">var myVariable = 42
myVariable = 48
let myConstant = 42
</code></pre>

<p>常量和变量必须具有和你赋值给他们的值相同的类型，但是你并不需要总是明确的写出他们的类型。你只管提供值，让编译器决定类型。在上面的例子里，myVaribale将是整数类型，因为它的初始化值是整数。</p>

<p>如果一个初始化值不足以提供类型信息，那你就必须提供类型，写在变量的后面，用冒号隔开。</p>

<pre><code class="ru">let implictInteger = 70
let implictDouble = 70.0
let explictDouble : Double = 70
</code></pre>

<p>值永远都不会隐式转换为其他类型。如果你需要转换一个值到另外一个类型，你需要显式转化。</p>

<pre><code class="ru">let label = "The width is "
let width = 94
let widthLabel = label + String(width)
</code></pre>

<p>其实有更简单的办法在字符串中插入值，把值写在括号里，在括号前面写一个 \ 。</p>

<pre><code class="ru">let apples = 3
let oranges = 5
let appleSummary = "I have \(apples) apples"
let fruitSummary = "I have \(apples + oranges) pieces of fruit."
</code></pre>

<p>使用[ ]来创建数组和字典，在[ ]里写上索引或键来访问数字和字典里的元素。</p>

<pre><code class="ru">var shoppingList = ["catfish", "water", "tulips", "blue paint"]
shoppingList[1] = "bottle of water"
var occupations = [
    "Malcolm" : "Captain" ,
    "Kaylee"  : "Mechanic",
]
occupations["Jayne"] = "Public Relations"
</code></pre>

<p>创建空的数字和字典，用初始化语法：</p>

<pre><code class="ru">let emptyArray = [String]()
let emptyDictionary = [String:Float]()
</code></pre>

<h4>Control Flow（控制流程）</h4>

<p>用 if 和 switch 来做条件分支，用 for-in，for，while，do-while 来做循环。在条件分支和循环里的括号是可选的，但是包含代码的大括号是必须的。</p>

<pre><code class="ru">let individualScores = [75, 43, 103, 87, 12]
var teamScore = 0
for score in individualScores {
    if score &gt; 50 {
        teamScore += 3
    }else{
        teamScore += 1
    }
}
</code></pre>

<p>在 if 语句里，条件值必须是布尔表达式，这意味着 if score {} 是错误的，这里不会隐式的和 0 比较。</p>

<p>你可以用 if 和 let 一起处理那些可能不存在的值。这些值被表达为Optional，一个Optional的值要么包含一个值，要么包含 nil 来表示值不存在。 在值的类型后面加个 ？表示Optional。</p>

<pre><code class="ru">var optionalString : String? = "Hello"
optionalString == nil
var optionalName : String? = "John"
var greeting = "Hello"
if let name = optionalName {
    greeting = "Hello,\(name)"
}
</code></pre>

<p>如果Optional的值为 nil，条件就是 false，大括号里的代码就被略过了，否则，Optional的值被解包(Unwrap)并赋值给了在 let 后面的常量，这样这个常量在下面的代码快里也是可见的。</p>

<p>switch 支持任何种类的数据和多种多样的比较奥做，它们不局限于整数和相等性比较。</p>

<pre><code class="ru">let vegetable = "red pepper"
switch vegetable {
    case "celery":
        let vegerableComent = "Add some raisins and make ants on a log."
    case "cucumber", "watercress":
        let vegerableComment = "That would make a good tea sandwich."
    case let x where x.hasSuffix("pepper"):
        let vegetableComment = "Is it a spicy \(x) ?"
    default:
        let vegetableComment = "Everything tastes good in soup."
}
</code></pre>

<p>注意如何在一个模式中使用 let 来把匹配的值赋值给一个常量。</p>

<p>在执行完匹配的case里的代码，程序就离开了switch语句。代码不会继续执行下一个case，所以不需要显示的从每一个case里 break 出来。</p>

<p>你可以用 for-in 来遍历一个字典里的内容，你需要提供一对名字来匹配每一个键值对。字典是无序集合，所以键值对的顺序是任意的。</p>

<pre><code class="ru">let interestingNumbers = [
    "Prime" : [2,3,5,7,11,13],
    "Fibonacci" : [1,1,2,3,5,8],
    "Square" : [1,4,9,16,25],
]
var largest = 0
for (kind,numbers) in interestingNumbers {
    for number in numbers {
        if number &gt; largest {
            largest = number
        }
     }
 }
</code></pre>

<p> 使用 while 来重复一段代码直到条件改变。条件也可以放在尾部，保证代码至少执行一次。</p>

<pre><code class="ru"> var n = 2
 while n &lt; 100 {
     n = n * 2
 }
 n
 var m = 2
 do{
     m = m * 2
 } while m &lt; 100
 m
</code></pre>

<p> 你可以在循环中持有一个索引，可以通过 ..&lt; 来创建一个区间， 或是显式的初始化，条件，增加。 下面两个循环做的事情是一样的</p>

<pre><code class="ru">var firstLoop = 0
for i in 0..&lt;4 {
    firstLoop += i
}
firstLoop
var secondLoop = 0
for var i = 0; i &lt; 4; ++i {
    secondLoop += i
}
secondLoop
</code></pre>

<p>..&lt; 不包含最大值，半开区间[ ), &hellip;包含最大值，闭区间 [ ]。</p>

<h4>Functions and Closures (函数与闭包)</h4>

<p>用 func 来声明一个函数，在函数名后面加上括弧，在括弧里传入参数来调用函数。用 -> 区分参数名字和函数的返回类型。</p>

<pre><code class="ru">func greet(name: String, day: String) -&gt; String {
    return "Hello \(name), today is \(day)"
}
greet("Bob","Tuesday")
</code></pre>

<p>使用元组来表示一个组合值，比如从一个函数返回多个值。元组的元素可以用过名字或数字来引用。</p>

<pre><code class="ru">func calculateStatistics(scores: [Int]) -&gt; (min: Int, max: Int, sum: Int) {
    var min = scores[0]
    var max = scores[0]
    var sum = 0
    for score in scores {
        if score &gt; max {
            max = score
        else if score &lt; min {
            min = score
        }
        sum += score
     }
     return (min, max, sum)
}
let statistics = calculateStatistics([5,3,100,3,9])
statistics.sum
statistics.2
</code></pre>

<p>函数也可以接受不定数量的参数，会收集在一个数组里。</p>

<pre><code class="ru">func sumOf(numbers : Int...) -&gt; Int {
    var sum = 0
    for number in numbers {
        sum += number
    }
    return sum
}
sumOf()
sumOf(42,597,12)
</code></pre>

<p>函数可以嵌套，被嵌套的函数可以访问外层函数里的变量。可以使用嵌套函数来组织比较复杂或冗长的代码。</p>

<pre><code class="ru">func returnFifteen() -&gt; Int {
    var y = 10
    func add() {
        y += 5
    }
    add()
    return y
}
returnFifteen()
</code></pre>

<p>函数是一等类型。这意味着函数可以作为其他函数的返回值。</p>

<pre><code class="ru">func makeIncrementer() -&gt; (Int -&gt; Int) {
    func addOne(number: Int) -&gt; Int {
        return 1 + number
    }
    return addOne
}
var increment = makeIncrementer()
increment(7)
</code></pre>

<p>函数也可以接受其他函数作为参数。</p>

<pre><code class="ru">func hasAnyMatches(list: [Int], condition: Int -&gt; Bool) -&gt; Bool {
    for item in list {
        if condition(item) {
            return true
        }
    }
    return false
}
func lessThanTen(number: Int) -&gt; Bool {
    return number &lt; 10
}
var numbers = [20,19,7,12]
hasAnyMatches(numbers, lessThanTen)
</code></pre>

<p>函数其实是一种特殊的闭包（一些代码可以在稍后被调用）。闭包里的代码可以访问那些在闭包被创建的作用域里可以见的变量和函数，即使闭包在另外的作用域被执行（嵌套函数的那个例子里就是这样）。你可以写一个没有名字的闭包，把代码直接包含在大括号里，使用 in 把参数，返回值和函数体区分开来。</p>

<pre><code class="ru">numbers.map({
    (number: Int) -&gt; Int in
    let result = 3 * number
    return result
})
</code></pre>

<p>你还有一些选项可以把闭包写的更精确。当一个闭包的类型是已知的，例如delegate的回调，你可以省略闭包的参数的类型，或者它的返回值，或者两个都省略。单个语句的闭包隐式的返回他们的唯一的语句的值。</p>

<pre><code class="ru">let mappedNumbers = numbers.map({ number in 3 * number })
mappedNumbers
</code></pre>

<p>你可以在闭包里通过数字引用参数而不是名字（这种方式在非常短的闭包里非常有用）。一个闭包如果作为一个函数的最后一个参数，可以把闭包的代码写在函数调用的括弧后面。</p>

<pre><code class="ru">let sortedNumber = sorted(numbers) { $0 &gt; $1 }
sortedNumber
</code></pre>

<h4>Objects and Classes (对象与类)</h4>

<p>使用 class 加上类名来创建一个类。 在类里声明属性和声明一个常量，变量一样，只是在类的上下文里。同样，方法和函数的声明也一样的。</p>

<pre><code class="ru">class Shape {
    var numberOfSides = 0
    func simpleDescription() -&gt; String {
        return "A shape with \(numberOfSides) sides"
    }
}
</code></pre>

<p>在类名后面加上括弧来创建实例。用 . 来访问属性和方法。</p>

<pre><code class="ru">var shape = Shape()
shape.numberOfSides = 7
var shapeDescription = shape.simpleDescription()
</code></pre>

<p>这个版本的Shape类缺少一个重要的东西，一个在实例被创建时的初始化函数。用 init 来创建一个。</p>

<pre><code class="ru">class NamedShape {
    var numberOfSides = 0
    var name : String
    init(name:String){
        self.name = name
    }
    func simpleDescription() -&gt; String {
        return "A shape with \(numberOfSides) sides"
    }
}
</code></pre>

<p>注意在初始化函数里，如何用 self 来区分属性和参数。 参数在创建一个类的实例像函数调用一样传递给了初始化函数。每一个属性都需要赋值，不管是在声明的时候还是在初始化函数里。</p>

<p>使用 deinit 来创建一个析构函数(deinitializer)在对象被deallocated的时候做一些清理工作。</p>

<p>子类在自己的类名后面标注它们的父类，用冒号隔开。Swift并没有一个强制要求的标准基类，你可以包含一个基类，也可以省略。</p>

<p>子类里重写父类的实现的方法需要标记为 override， 如果没有写 override 却重写了父类的方法，编译器会报错。如果写了 override 但并不是真的重写了一个方法，编译器也会报错。</p>

<pre><code class="ru">class Square: NamedShape {
    var sideLength: Double
    init(sideLength: Double, name: String) {
        self.sideLength = sideLength
        super.init(name: name)
        numberOfSides = 4
    }
    func area() -&gt;  Double {
        return sideLength * sideLength
    }
    override func simpleDescription() -&gt; String {
        return "A square with sides of length \(sideLength)."
    }
}
let test = Square(sideLength: 5.2, name: "my test square")
test.area()
test.simpleDescription()
</code></pre>

<p>除了简单的被存储属性，属性还可以有 getter 和 setter。</p>

<pre><code class="ru">class EquilateralTriangle: NamedShape {
    var sideLength: Double = 0.0
    init(sideLength: Double, name: String) {
        self.sideLength = sideLength
        super.init(name: name)
        numberOfSides = 3
    }
    var perimeter: Double {
        get {
            return 3.0 * sideLength
        }
        set {
            sideLength = newValue / 3.0
        }
    }
    override func simpleDescription() -&gt; String {
        return "An equilateral triangle with sides of length \(sideLength)."
    }
}
var triangle = EquilateralTriangle(sideLength: 3.1, name: "a triangle")
triangle.perimeter
triangle.perimeter = 9.9
triangle.sideLength
</code></pre>

<p>在 perimeter 的 setter里，新的值默认的名字叫 newValue，你也可以显式的在set后面加上名字。</p>

<p>注意在 EquilateralTriangle 的 init有三个不同的步骤：</p>

<ol>
<li>  设置子类声明的属性。</li>
<li>  调用父类的初始化函数。</li>
<li>  修改父类定义的属性，还有任何其他的初始化工作都可以在这一时刻进行。</li>
</ol>


<p>如果你不需要计算一个属性，但是在它被改变之前和之后需要执行代码的话，可以使用 willSet 和 didSet。</p>

<pre><code class="ru">class TriangleAndSquare {
    var triangle: EquilateralTriangle {
        willSet {
            square.sideLength = newValue.sideLength
        }
    }
    var square: Square {
        willSet {
            triangle.sideLength = newValue.sideLength
        }
    }
    init(size: Double, name: String) {
        square = Square(sideLength: size, name: name)
        triangle = EquilateralTriangle(sideLength: size, name: name)
    }
}
var triangleAndSquare = TriangleAndSquare(size: 10, name: "another test shape")
triangleAndSquare.square.sideLength
triangleAndSquare.triangle.sideLength
triangleAndSquare.square = Square(sideLength: 50, name: "larger square")
triangleAndSquare.triangle.sideLength
</code></pre>

<p>类里的方法和函数有一个重要的区别。函数的参数名只用在函数里面，但是方法的参数名在调用方法的时候也需要用到(除了第一个)。默认情况下，一个方法在调用时和方法内部时用同一个参数名字，但是你也可以给出第二个名字，用在方法内部。</p>

<pre><code class="ru">class Counter {
    var count: Int = 0
    func incrementBy(amount: Int, numberOfTimes times: Int) {
        count += amount * times
    }
}
var counter = Counter()
counter.incrementBy(2, numberOfTimes: 7)
</code></pre>

<p>当使用Optional时，你可以在方法，属性和下标的操作之前加上 ? 。如果在 ？ 之前的值是 nil， 所有在 ？ 之后的都被忽略并且整个表达式的值也是 nil。 否则，Optional的值被解包， ？ 之后的所有都处理在这个解包后的值。在这两种情况下，整个表达式的值都是Optional。</p>

<pre><code class="ru">let optionalSquare: Square? = Square(sideLength: 2.5, name: "optional square")
let sideLength = optionalSquare?.sideLength
</code></pre>

<h4>Enumerations and Structures (枚举与结构)</h4>

<p>使用 enum 来创建枚举，像 class 和其他所有有名类型一样，枚举也可以有方法。</p>

<pre><code class="ru">enum Rank: Int {
    case Ace = 1
    case Two, Three, Four, Five, Six, Seven, Eight, Nine, Ten
    case Jack, Queen, King
    func simpleDescription() -&gt; String {
        switch self {
        case .Ace:
            return "ace"
        case .Jack:
            return "jack"
        case .Queen:
            return "queen"
        case .King:
            return "king"
        default:
            return String(self.toRaw())
        }
    }
}
let ace = Rank.Ace
let aceRawValue = ace.toRaw()
</code></pre>

<p>在上面的例子里，枚举的原始类型(raw type)是 Int，所以你只需要给出第一个枚举的值，其他的会自动赋值。你可以使用字符串和浮点数来作为枚举的原始类型。</p>

<p>使用 toRaw 和 fromRaw 来在原始值和枚举值之前转化。</p>

<pre><code class="ru">if let convertedRank = Rank.fromRaw(3) {
    let threeDescription = convertedRank.simpleDescription()
}
</code></pre>

<p>枚举的成员值是实际的值，而不是原始值的另外一种写法，事实上，如果没有合适的原始值，你可以不提共。</p>

<pre><code class="ru">enum Suit {
    case Spades, Hearts, Diamonds, Clubs
    func simpleDescription() -&gt; String {
        switch self {
        case .Spades:
            return "spades"
        case .Hearts:
            return "hearts"
        case .Diamonds:
            return "diamonds"
        case .Clubs:
            return "clubs"
        }
    }
}
let hearts = Suit.Hearts
let heartsDescription = hearts.simpleDescription()
</code></pre>

<p>注意 Hearts 被引用的时侯的两种方式，当赋值的时候， Suit.Hearts 全名被使用，因为不知道常量的类型；在 switch里，因为 self 的类型已知，所以使用了 .Hearts 简短的名字。你可以在任何类型已知的情况下使用简短的名字。</p>

<p>使用 struct 来创建一个结构体。结构体和类有很多一样的行为，包括方法和初始化方法。它们两个最重要的区别就是结构体在你代码里来回传递的时候总是被拷贝的，而类则是传递引用（reference）。</p>

<pre><code class="ru">struct Card {
    var rank: Rank
    var suit: Suit
    func simpleDescription() -&gt; String {
        return "The \(rank.simpleDescription()) of \(suit.simpleDescription())"
    }
}
let threeOfSpades = Card(rank: .Three, suit: .Spades)
let threeOfSpadesDescription = threeOfSpades.simpleDescription()
</code></pre>

<p>一个枚举实例的枚举成员可以有这个实例的关联值（assocaited value），同一个枚举成员的不同实例可以有不同的关联值。你在创建这个实例的时候提供关联值。关联值和原始值是不一样的，一个枚举成员的原始值对于所有的实例都一样，而且你是在定义枚举类型的时候提供原始值。</p>

<p>例如，向一个服务器请求日出和日落时间，服务器要么返回值，要么返回错误。</p>

<pre><code class="ru">enum ServerResponse {
    case Result(String, String)
    case Error(String)
}
let success = ServerResponse.Result("6:00 am", "8:09 pm")
let failure = ServerResponse.Error("Out of cheese.")
switch success {
case let .Result(sunrise, sunset):
    let serverResponse = "Sunrise is at \(sunrise) and sunset is at \(sunset)."
case let .Error(error):
    let serverResponse = "Failure...  \(error)"
}
</code></pre>

<p>注意，日出和日落的值是如何从 ServerResponse 里匹配出来的。</p>

<h4>Protocol and Extensions (协议和扩展)</h4>

<p>使用 protocol 来声明一个协议。</p>

<pre><code class="ru">protocol ExampleProtocol {
    var simpleDescription: String { get }
    mutating func adjust()
}
</code></pre>

<p>类，枚举和结构体都可以实现协议。</p>

<pre><code class="ru">class SimpleClass: ExampleProtocol {
    var simpleDescription: String = "A very simple class."
    var anotherProperty: Int = 69105
    func adjust() {
        simpleDescription += "  Now 100% adjusted."
    }
}
var a = SimpleClass()
a.adjust()
let aDescription = a.simpleDescription
struct SimpleStructure: ExampleProtocol {
    var simpleDescription: String = "A simple structure"
    mutating func adjust() {
        simpleDescription += " (adjusted)"
    }
}
var b = SimpleStructure()
b.adjust()
let bDescription = b.simpleDescription
</code></pre>

<p>注意例子中使用 mutating 关键字来标识方法会修改结构体。类的方法不用标识为 mutating，因为类的方法总是可以修改这个类。</p>

<p>使用 extension 来给现有的类型增加功能，例如方法和计算的属性。你可以使用 extension 来给一个类型增加协议的实现。</p>

<pre><code class="ru">extension Int: ExampleProtocol {
    var simpleDescription: String {
        return "The number \(self)"
    }
    mutating func adjust() {
        self += 42
    }
}
7.simpleDescription
</code></pre>

<p>你可以把协议名字当作任何其他有名字的类型来用，例如，创建一个对象的集合，对象有着不同的类型，但是都实现了同一个协议。当你使用类型为协议类型的值时，只有协议定义的方法是可以用的。</p>

<pre><code class="ru">let protocolValue: ExampleProtocol = a
protocolValue.simpleDescription
// protocolValue.anotherProperty  // Uncomment to see the error
</code></pre>

<p>尽管 protocolValue 在运行时是 SimpleClass类别的，编译器认为它就是 ExampleProtocol类型。这意味着你不能偶然的访问到类和协议都有的方法和属性(not sure.)</p>

<h4>Generics (泛型)</h4>

<p>把名字写到尖括号里来创建一个泛型函数或者类型。</p>

<pre><code class="ru">func repeat&lt;ItemType&gt;(item: ItemType, times: Int) -&gt; [ItemType] {
    var result = [ItemType]()
    for i in 0..&lt;times {
        result.append(item)
    }
    return result
}
repeat("knock", 4)
</code></pre>

<p>你可以定义泛型的函数，方法，也可以定义泛型的类，枚举，结构体。</p>

<pre><code class="ru">enum OptionalValue&lt;T&gt; { // Reimplement the Swift standard library's optional type
    case None
    case Some(T)
}
var possibleInteger: OptionalValue&lt;Int&gt; = .None
possibleInteger = .Some(100)
</code></pre>

<p>在类型名字后面使用 where 来给出一系列要求，例如，要求这个类型必须实现某个协议，要求两个类型必须一样，或者要求需要某一个特定的父类。</p>

<pre><code class="ru">func anyCommonElements &lt;T, U where T: SequenceType, U: SequenceType, T.Generator.Element: Equatable, T.Generator.Element == U.Generator.Element&gt; (lhs: T, rhs: U) -&gt; Bool {
    for lhsItem in lhs {
        for rhsItem in rhs {
            if lhsItem == rhsItem {
                return true
            }
        }
    }
    return false
}
anyCommonElements([1, 2, 3], [3])
</code></pre>

<p>在上面的例子里，你可以省略 where 直接把协议或者类名写在一个冒号后面。 写 &lt;T: Equatable> 和 <T where T : Equatable> 是一样的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Welcome to Swift - About Swift]]></title>
    <link href="http://zxhfirefox.github.io/blog/2014/09/14/welcome-to-swift-about-swift/"/>
    <updated>2014-09-14T16:20:47+08:00</updated>
    <id>http://zxhfirefox.github.io/blog/2014/09/14/welcome-to-swift-about-swift</id>
    <content type="html"><![CDATA[<p>Swift是一门建立在C和Objective-C的优点之上，而又没有C兼容性限制的用来编写iOS和OS X应用的编程语言。Swift采用了安全的编程模式，并且添加了许多现代语言的特性来使编程更简单，更灵活而且更有意思。全新的Swift，加上成熟且备受喜爱的Cocoa和CocoaTouch的框架，将让我们去重新想象如何开发软件。</p>

<p>创建Swift已经好几年了。Apple通过改进现有的编译器，调试器和基础框架来为Swift打基础。我们通过ARC来简化内存管理。我们建立在Foundation和Cocoa的框架栈也全部标准化和现代化。Objective-C也支持了Block，容器字面量(collection literals)和模块（modules），这些使得框架在适应现代语言的时候不会出现问题。就是因为这些改进，我们才能够在现在为我们今后软件开发介绍一门的新的语言。</p>

<p>Objective-C的开发者不会觉得Swift太陌生。Swift应用了Objc的命名参数的可读性还有Objc的动态对象模型。它还提供了无缝的访问Cocoa框架以及Objc代码混编的能力。在这些基础之上，Swift还提供了很多新的特性，并统一了语言中过程化和面向对象的部分。</p>

<p>Swift对于新人来说一样友好。他是第一个产业品质的系统编程语言，但是同时又像脚本语言一样有趣和非常强的表达能力。它支持Playground，一种可以让程序员不用编译，运行程序而直接看到结果的特性。</p>

<p>Swift将苹果广阔的工程文化里的智慧和现代语言最好的思想结合在一起。编译器为了性能而优化，语言为了开发而优化，两者都不舍弃。Swift可以很好的从简单的hello，world伸缩到整个操作系统。所有这些都将使得Swift成为开发者和苹果一个明智的投资。</p>

<p>Swift提供了一个非常好的方式来开发iOS和OS X应用，并且它也会持续改进。我们对于Swift的未来是有远大目标的。我们也迫不及待的希望看到你用它来创造的东西。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Translate The Swift Programming Language]]></title>
    <link href="http://zxhfirefox.github.io/blog/2014/09/14/translate-the-swift-programming-language/"/>
    <updated>2014-09-14T14:26:00+08:00</updated>
    <id>http://zxhfirefox.github.io/blog/2014/09/14/translate-the-swift-programming-language</id>
    <content type="html"><![CDATA[<p>This blog was created a long time ago, I did not write any meaningful things.</p>

<p>As Apple release the swift programming language 1.0, I think I want to write something.</p>

<p>The first goal is trying to translate the Swift Programming Language.</p>

<p>Hope I can make it.</p>
]]></content>
  </entry>
  
</feed>

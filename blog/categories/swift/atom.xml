<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: swift | zxhfirefox's Blog]]></title>
  <link href="http://zxhfirefox.github.io/blog/categories/swift/atom.xml" rel="self"/>
  <link href="http://zxhfirefox.github.io/"/>
  <updated>2014-11-17T23:28:12+08:00</updated>
  <id>http://zxhfirefox.github.io/</id>
  <author>
    <name><![CDATA[zxhfirefox]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Using Swift with Cocoa and Objective-C: Migration-Migrating Your ObjC Code to Swift]]></title>
    <link href="http://zxhfirefox.github.io/blog/2014/11/17/using-swift-with-objc-n-migration-migrating-your-objc-code-to-swift/"/>
    <updated>2014-11-17T23:24:58+08:00</updated>
    <id>http://zxhfirefox.github.io/blog/2014/11/17/using-swift-with-objc-n-migration-migrating-your-objc-code-to-swift</id>
    <content type="html"><![CDATA[<p>迁移，让我们有机会去重新审视现有的ObjC的app，我们可以使用Swift来替换其中的一部分来改进它的架构，逻辑和性能。直接来说，我们使用前面学得知识(混合与匹配，互用性)来一点点迁移我们的app。混合与匹配，让我们选择合适的部分来使用Swift重写，把剩下的留在ObjC。互用性让我们可以把这些新的特性在融会到ObjC里。使用这些工具来探索Swift丰富的功能，然后把这些在整合回ObjC得app，我们不需要一次性从头使用Swift写一个新的app。</p>

<h3>为了迁移修改ObjC的代码</h3>

<p>在我们迁移代码之前，确保我们的Swift和ObjC都有着最好的兼容性。这意味着需要整理和现代化我们现有的ObjC代码。我们现有的遵循现代化的ObjC代码会让迁移过程变得简单。如何现代化ObjC的代码，可以去看<a href="https://developer.apple.com/library/ios/releasenotes/ObjectiveC/ModernizationObjC/AdoptingModernObjective-C/AdoptingModernObjective-C.html#//apple_ref/doc/uid/TP40014150">这个文档</a>。</p>

<h3>迁移过程</h3>

<p>最高效的迁移过程是按照文件来做，一次迁移一个类。因为我们不能在ObjC里继承Swift的类，所以我们最好选择那些没有子类的类。我们用.swift文件来代替.h和.m文件。所有的接口和实现都在一个文件里。我们不需要创建头文件，Xcode会在我们需要引用时自动为我们创建一个头文件。</p>

<h4>开始之前</h4>

<ol>
<li>创建一个对应的.swift文件，我们可以使用和.m一样名字的也可以选择不一样的。类名字的前缀也是可选的。</li>
<li>导入相关的系统框架。</li>
<li>在ObjC桥接头文件里添加我们需要在Swift使用的ObjC文件。</li>
<li>为了让我们的Swift类在ObjC里可见和可用，我们要么让它继承自一个ObjC的类，要么标记为@objc。为了给出在ObjC里使用的一个名字，可以使用@objc(&lt;#name#>)，其中&lt;#name#>是我们在ObjC里要用来引用这类的名字。</li>
</ol>


<h4>迁移中</h4>

<ol>
<li>我们可以通过继承ObjC的类，实现ObjC的协议等等让我们Swift类可以整合ObjC的行为。</li>
<li>当我们使用ObjC的API时，我们需要知道Swift是如何把ObjC的API导入进来的。</li>
<li>当我们使用Cocoa框架时，记得有些类型Swift是桥接的，这意味着我们可以直接使用Swift类型。</li>
<li>当我们使用Cocoa框架时，我们需要使用Cocoa转换过来的常用设计模式。</li>
<li>当我们打算把ObjC的属性转到Swift时，读一下属性那篇文档。</li>
<li>使用@objc(&lt;#name#>)来给出在ObjC里使用时的名字。</li>
</ol>


<pre><code class="swift">var enabled: Bool {
@objc(isEnabled) get {
    /* ... */
}
}
</code></pre>

<ol>
<li>把实例方法(-)和类方法(+)，转到对应的func和class func。</li>
<li>把简单的宏定义为常量，把复杂的宏定义为函数。</li>
</ol>


<h4>迁移结束后</h4>

<ol>
<li>在ObjC里，把头文件改成 #import &ldquo;ProductModuleName-Swift.h&#8221;。</li>
<li>从目标(target)里删掉原来的.m和.h文件，不需要删除文件。</li>
<li>我代码里的旧的ObjC的类的名字用Swift的名字替换掉。</li>
</ol>


<h3>注意和技巧</h3>

<p>尽管我们需要迁移的代码不尽相同，但是下面是一些通用的步骤和技巧。</p>

<ol>
<li>记得我们无法在ObjC里继承一个Swift类。因此，迁移的ObjC的类不能有子类。</li>
<li>迁移完毕一个类之后，从目标里把ObjC的类移除，避免编译错误(重复的符号)。</li>
<li>为了让Swift在ObjC中可用，Swift的类必须继承自ObjC的类，或是用@objc标记。</li>
<li>在ObjC使用Swift代码，记得有些Swift特性是无法转换到ObjC的。</li>
<li>cmd-click来查看一个Swift的类的生成的头文件。</li>
<li>option-click一个符号，来查看它的信息：类型，特性，文档注释。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using Swift with Cocoa and Objective-C: Interoperability-Interacting with C APIs]]></title>
    <link href="http://zxhfirefox.github.io/blog/2014/11/17/using-swift-with-objc-interoperability-y-interact-with-c/"/>
    <updated>2014-11-17T23:19:56+08:00</updated>
    <id>http://zxhfirefox.github.io/blog/2014/11/17/using-swift-with-objc-interoperability-y-interact-with-c</id>
    <content type="html"><![CDATA[<p>作为和ObjC互用性的一部分，Swift保留了一部分和C兼容的类型和特性。Swift也提供了一种和通用的C结构和模式的方法。</p>

<!-- more -->


<h3>基础类型</h3>

<p>Swift提供了和C一样的基础整数类型。然而，Swift并不提供默认的这些类型和Swift类型的自动转换，所以谨慎使用。</p>

<pre><code>C Type              Swift Type
bool                CBool
char,signed char    CChar
unsigned char       CUnsignedChar
short               CShort
unsigned short      CUnsignedShort
int                 CInt
unsigned int        CUnsignedInt
long                CLong
unsigned long       CUnsignedLong
long long           CLongLong
unsigned long long  CUnsignedLongLong
wchar_t             CWideChar
char16_t            CChar16
char32_t            CChar32
float               CFloat
double              CDouble
</code></pre>

<h3>枚举</h3>

<p>Swift会把所有的使用NS_ENUM的C枚举导入成一个Swift的枚举类型。这意味着枚举值的前缀会被截掉。</p>

<pre><code class="objc">//ObjC
typedef NS_ENUM(NSInteger, UITableViewCellStyle) {
   UITableViewCellStyleDefault,
   UITableViewCellStyleValue1,
   UITableViewCellStyleValue2,
   UITableViewCellStyleSubtitle
};
</code></pre>

<p>到了Swift就变成了：</p>

<pre><code class="swift">//Swift
enum UITableViewCellStyle: Int {
    case Default
    case Value1
    case Value2
    case Subtitle
}
</code></pre>

<p>当我们引用一个枚举值时，在值的前面加一个 .</p>

<pre><code class="swift">let cellStyle: UITableViewCellStyle = .Default
</code></pre>

<p>Swift也会导入被标记为NS_OPTIONS的options枚举值。这些枚举的值可以支持位操作符。</p>

<p>在ObjC里，我们使用0表示空的option。在Swift里，使用nil。</p>

<pre><code class="swift">let myString = myData.base64EncodedStringWithOptions(nil)
</code></pre>

<h3>指针</h3>

<p>在任何时候，Swift都会避免让我们直接访问指针。但是，仍然提供了一些指针类型供我们需要时使用。下面的Type是一个真实类型的占位符。</p>

<p>对于返回值，变量，参数，有下面的映射：</p>

<pre><code>C Syntax        Swift Syntax
const Type *    UnsafePointer&lt;Type&gt;
Type *          UnsafeMuatblePointer&lt;Type&gt;
</code></pre>

<p>对于类类型：</p>

<pre><code>C Syntax            Swift Syntax
Type * const *      UnsafePointer&lt;Type&gt;
Type * __strong *   UnsafeMutablePointer&lt;Type&gt;
Type **             AutoreleasingUnsafeMutablePointer&lt;Type&gt;
</code></pre>

<h4>常量指针</h4>

<p>当一个函数声明如果接受一个UnsafePointer<Type>的参数，它可以接受一下几种：
    *   nil，作为空指针传入
    *   一个UnsafePointer<Type>，UnsafeMutablePointer<Type>，AutoreleasingUnsafeMutablePointer<Type> 值，并转换到UnsafePointer<Type>。
    *   一个in-out表达式，它的操作数是一个Type的左值。作为操作数的地址传入。
    *   一个[Type]值，作为一个数组开始的指针传入，生命周期也是函数调用。</p>

<pre><code class="swift">func takesAPointer(x: UnsafePointer&lt;Float&gt;) { /*...*/ }
</code></pre>

<p>我们可以调用：</p>

<pre><code class="swift">var x: Float = 0.0
var p: UnsafePointer&lt;Float&gt; = nil
takesAPointer(nil)
takesAPointer(p)
takesAPointer(&amp;x)
takesAPointer([1.0, 2.0, 3.0])
</code></pre>

<p>当一个函数接受一个UnsafePointer<Void>的参数，他可以接受任何的Type在UnsafePointer<Type>里可以接受的参数。</p>

<pre><code class="swift">func takesAVoidPointer(x: UnsafePointer&lt;Void&gt;)  { /* ... */ }
</code></pre>

<p>我们可以调用：</p>

<pre><code class="swift">var x: Float = 0.0, y: Int = 0
var p: UnsafePointer&lt;Float&gt; = nil, q: UnsafePointer&lt;Int&gt; = nil
takesAVoidPointer(nil)
takesAVoidPointer(p)
takesAVoidPointer(q)
takesAVoidPointer(&amp;x)
takesAVoidPointer(&amp;y)
takesAVoidPointer([1.0, 2.0, 3.0] as [Float])
let intArray = [1, 2, 3]
takesAVoidPointer(intArray)
</code></pre>

<h4>可变指针</h4>

<p>当一个函数接受一个UnsafeMutablePointer<Type>的参数时，它可以接受下面的实参：
    *   nil作为空指针传入
    *   一个 UnsafeMutablePointer<Type> 值
    *   一个in-out表达式，它的操作数是一个Type的左值。作为操作数的地址传入
    *   一个[Type]值，作为一个数组开始的指针传入，生命周期也是函数调用</p>

<p>例如：</p>

<pre><code class="swift">func takesAMutablePointer(x: UnsafeMutablePointer&lt;Float&gt;) { /*...*/ }
</code></pre>

<p>下面的调用都可以：</p>

<pre><code class="swift">var x: Float = 0.0
var p: UnsafeMutablePointer&lt;Float&gt; = nil
var a: [Float] = [1.0, 2.0, 3.0]
takesAMutablePointer(nil)
takesAMutablePointer(p)
takesAMutablePointer(&amp;x)
takesAMutablePointer(&amp;a)
</code></pre>

<p>当一个函数接受一个UnsafeMutablePointer <Void>的参数，他可以接受任何的Type在UnsafeMutablePointer <Type>里可以接受的参数。</p>

<p>例如：</p>

<pre><code class="swift">func takesAMutableVoidPointer(x: UnsafeMutablePointer&lt;Void&gt;)  { /* ... */ }
</code></pre>

<p>下面的调用都可以：</p>

<pre><code class="swift">var x: Float = 0.0, y: Int = 0
var p: UnsafeMutablePointer&lt;Float&gt; = nil, q: UnsafeMutablePointer&lt;Int&gt; = nil
var a: [Float] = [1.0, 2.0, 3.0], b: [Int] = [1, 2, 3]
takesAMutableVoidPointer(nil)
takesAMutableVoidPointer(p)
takesAMutableVoidPointer(q)
takesAMutableVoidPointer(&amp;x)
takesAMutableVoidPointer(&amp;y)
takesAMutableVoidPointer(&amp;a)
takesAMutableVoidPointer(&amp;b)
</code></pre>

<h4>自动释放的指针</h4>

<p>当一个函数接受一个AutoreleasingUnsafeMutablePointer <Type>的参数时，它可以接受下面的实参：
    *   nil作为空指针传入
    *   一个 AutoreleasingUnsafeMutablePointer <Type> 值
    *   一个in-out表达式，它的操作数是基础类型被拷贝的临时的非拥有的buffer。这个buffer的地址被传递给被调用函数，然后在返回时，这个buffer的值被加载，保留(retained)，并且赋值给这个操作数</p>

<p>注意，没有数组。</p>

<p>例如：</p>

<pre><code class="swift">func takesAnAutoreleasingPointer(x: AutoreleasingUnsafeMutablePointer&lt;NSDate?&gt;) { /* ... */ }
</code></pre>

<p>下面的调用都可以：</p>

<pre><code class="swift">var x: NSDate? = nil
var p: AutoreleasingUnsafeMutablePointer&lt;NSDate?&gt; = nil
takesAnAutoreleasingPointer(nil)
takesAnAutoreleasingPointer(p)
takesAnAutoreleasingPointer(&amp;x)
</code></pre>

<p>被指向的类型是不会被桥接的。例如，NSString** 转到Swift就成了AutoreleasingUnsafeMutablePointer&lt;NSString?>而不是AutoreleasingUnsafeMutablePointer&lt;String?>。</p>

<h4>函数指针</h4>

<p>C的函数指针在Swift里成了CFunctionPointer<Type>，而Type是一个Swift函数类型。例如，一个C里的函数指针是 int (*)(void)类型的，转到Swift就变成了CFunctionPointer&lt;() -> Int32>。</p>

<h3>全局常量</h3>

<p>在C和ObjC定义的全局常量会被自动导入为Swift全局常量。</p>

<h3>预编译指令</h3>

<p>Swift编译器并不包含预编译器。相反，它使用一些编译期的属性，编译配置和语言特性来完成类似的功能。因此，预编译指令在Swift里并没有被实现。</p>

<h4>简单的宏</h4>

<p>通常我们在C和ObjC里用#define来定义的宏，在Swift都应该用全局常量代替。例如，#define FADE_ANIMATION_DURATION 0.35 在Swift里表示为let FADE_ANIMATION_DURATION = 0.35 更好。这样简单的宏会被导入为全局常量。</p>

<h4>复杂的宏</h4>

<p>在C和ObjC里使用的复杂的宏在Swift里没有替代品。复杂的宏是指那些没有定义常量的，包括使用参数的，类似于函数的宏。我们在C和ObjC里使用复杂的宏是为了避免类型检查的限制或者避免大量重复的代码。然而，宏会增加我们bebug和重构的复杂度。在Swift里，我们可以使用函数和泛型来达到同样的目的。因此，在C和ObjC的复杂的宏在Swift里不可用。</p>

<h4>编译配置</h4>

<p>Swift和ObjC代码通过不同的方式编译。Swift代码可以根据编译配置的值来条件编译。编译配置包含了字面的true和false，命令行flag，还有下面的平台检测函数。我们可以使用-D &lt;#flag#>。</p>

<pre><code>函数                  参数
os()                  OS X,iOS
arch()                x86_64,arm,arm64,i386


注意
arch(arm)的结果对于arm64的设备返回是false。arch(i386)对于32位iOS模拟器返回true。
</code></pre>

<p>一个简单的条件编译：</p>

<pre><code class="swift">    #if build configuration
        statements
    #else
        statements
    #endif
</code></pre>

<p>我们也可以使用||，&amp;&amp;，和 ！来写出复杂的条件编译。</p>

<pre><code class="swift">    #if build configuration &amp;&amp; !build configuration
        statements
    #elseif build configuration
        statements
    #else
        statements
    #endif
</code></pre>

<p>和C里的条件编译不一样，Swift里条件编译的代码部分必须是完整独立且语法正确的代码块。因为所有的Swift代码都会做语法检查，即使它在条件编译的时候不会编译。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using Swift with Cocoa and Objective-C: Interoperability-Adopting Cocoa Design Patterns]]></title>
    <link href="http://zxhfirefox.github.io/blog/2014/11/17/using-swift-with-objc-interoperability-y-adopting-cocoa-design-patterns/"/>
    <updated>2014-11-17T23:18:39+08:00</updated>
    <id>http://zxhfirefox.github.io/blog/2014/11/17/using-swift-with-objc-interoperability-y-adopting-cocoa-design-patterns</id>
    <content type="html"><![CDATA[<p>使用Cocoa已经建立好的设计模式可以帮助我们写出良好设计的app。许多的这种模式都依赖ObjC里定义的类。因为Swift和ObjC可以互相调用，所以我们可以在Swift里使用ObjC的模式。在很多情况下，我们可以使用Swift的特性来简化或扩展现有的Cocoa模式，让他们更加强大，更加有用。</p>

<!-- more -->


<h3>代理</h3>

<p>在Swift和ObjC里，代理通常使用一个定义了一些要求的协议和一个实现了协议的代理属性来表达。和在ObjC里一样，在我们给一个可能不存在的代理发消息时，我们询问代理是否响应这个selector。在Swift里，我们可以用optional链条来调用一个可能是nil的对象上的一个可选的方法，然后用if-let语法来检查返回的结果。</p>

<pre><code class="swift">class MyDelegate: NSObject, NSWindowDelegate {
    func window(NSWindow, willUseFullScreenContentSize proposedSize: NSSize) -&gt; NSSize {
        return proposedSize
    }
}
var myDelegate: NSWindowDelegate? = MyDelegate()
if let fullScreenSize = myDelegate?.window?(myWindow, willUseFullScreenContentSize: mySize) {
    println(NSStringFromSize(fullScreenSize))
}
</code></pre>

<p>我们先检查myDelegate是不是nil，检查myDelegate是否实现了window:willUseFullScreenContentSize:方法，如果都是true，调用方法，返回一个对象叫fullScreenSize。</p>

<h3>错误报告</h3>

<p>Swift里错误报告的模式和ObjC的一样，使用可选的返回值。在最简单的情况下，我们返回Bool值来表示函数调用成功与否。如果我们需要返回错误信息，我们添加一个out的NSError参数，类型是NSErrorPointer。这个类型基本和ObjC的 NSError** 类似，但是由额外的内存安全和optional typing。我们使用 &amp; 来传入一个optional的NSError类型给NSErrorPointer。</p>

<pre><code class="swift">var writeError: NSError?
let written = myString.writeToFile(path, atomically: false,
    encoding: NSUTF8StringEncoding,
    error: &amp;writeError)
if !written {
    if let error = writeError {
        println("write failure: \(error.localizedDescription)")
    }
}
</code></pre>

<p>当我们自己实现函数，需要提供错误报告时，我们把一个NSError对象设置到NSErrorPointer的memory属性。确保调用者给我们传入了一个不是nil的NSErrorPointer对象：</p>

<pre><code class="swift">func contentsForType(typeName: String!, error: NSErrorPointer) -&gt; AnyObject! {
    if cannotProduceContentsForType(typeName) {
        if error {
            error.memory = NSError(domain: domain, code: code, userInfo: [:])
        }
        return nil
    }
    // ...
}
</code></pre>

<h3>KVO</h3>

<p>KVO是一种可以让对象在其他对象某个属性变化时接到通知的一种方式。只要我们的Swift类继承自NSObject，我们就能在这个类上使用KVO。我们需要三步来实现KVO。</p>

<ol>
<li>在我们想观察的属性前面加上dynamic。</li>
</ol>


<pre><code class="swift">class MyObjectToObserve: NSObject {
    dynamic var myDate = NSDate()
    func updateDate() {
        myDate = NSDate()
    }
}
</code></pre>

<ol>
<li>创建一个全局的private的上下文变量。</li>
</ol>


<pre><code class="swift">private var myContext = 0
</code></pre>

<ol>
<li>添加一个观察者，重写observeValueForKeyPath:ofObject:change:context:，然后在deinit里移除观察者。</li>
</ol>


<pre><code class="swift">class MyObserver: NSObject {
    var objectToObserve = MyObjectToObserve()
    override init() {
        super.init()
        objectToObserve.addObserver(self, forKeyPath: "myDate", options: .New, context: &amp;myContext)
    }
    override func observeValueForKeyPath(keyPath: String, ofObject object: AnyObject, change: [NSObject: AnyObject], context: UnsafeMutablePointer&lt;Void&gt;) {
        if context == &amp;myContext {
            println("Date changed: \(change[NSKeyValueChangeNewKey])")
        } else {
            super.observeValueForKeyPath(keyPath, ofObject: object, change: change, context: context)
        }
    }
    deinit {
        objectToObserve.removeObserver(self, forKeyPath: "myDate", context: &amp;myContext)
    }
}
</code></pre>

<h3>目标-动作</h3>

<p>目标-动作是一种通用的模式，他可以让一个对象在某个特定事件发生时给另外一个对象发消息。它在ObjC和Swift里是很相似的。在Swift里，我们用Selector类型来代表ObjC的selectors。</p>

<h3>Introspection(自省)</h3>

<p>在ObjC里，我们用isKindOfClass:来检查一个对象是否是某个类以及它子类的实例(注：这里，苹果文档是错的= =)，用conformsToProtocol:来检查对象是否实现了某个协议。在Swift里，我们用is 来检查类型，用 as? 来向下转换一个类型。</p>

<p>我们用is来检查一个实例是否是一个类的实例：(注：这里不明确是类本身还是子类也可以，所以我做了实现，是子类也可以。应该说成，用 is 来判断一个比较广泛的类的实例是否是这个广泛类的某一个子类的实例)。</p>

<pre><code class="swift">if object is UIButton {
    // object is of type UIButton
} else {
    // object is not of type UIButton
}
</code></pre>

<p>注：下面是我测试的代码。</p>

<pre><code class="swift">import UIKit
class ParentView : UIView
{
}
class ChildView : ParentView
{
}
let view : UIView = ChildView() //我们必须给出view的类型，如果自动推导，它就是ChildView类型，下面的代码就会报错。
if view is ParentView {
    println(true) // true
}
if view is ChildView {
    println(true) // true
}
</code></pre>

<p>我们也可以用 as? 来尝试把一个实例向下转换到一个子类的类型。as?返回一个optional的对象，然后用if-let语句来检查结果。</p>

<pre><code class="swift">if let button = object as? UIButton {
    // object is successfully cast to type UIButton and bound to button
} else {
    // object could not be cast to type UIButton
}
</code></pre>

<p>检查是否实现协议和检查是否是类的实例是一样的：</p>

<pre><code class="swift">if let dataSource = object as? UITableViewDataSource {
    // object conforms to UITableViewDataSource and is bound to dataSource
} else {
    // object not conform to UITableViewDataSource
}
</code></pre>

<p>注意，上面的dataSource是UITableViewDataSource的对象，如果我想调用它的其他方法(不是UITableViewDataSource定义的方法)，我们需要把它们在转换到其他类型来调用。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using Swift with Cocoa and Objective-C: Interoperability-Working With Cocoa Data Types]]></title>
    <link href="http://zxhfirefox.github.io/blog/2014/11/17/using-swift-with-objc-interoperability-x-working-with-cocoa-data-types/"/>
    <updated>2014-11-17T23:17:29+08:00</updated>
    <id>http://zxhfirefox.github.io/blog/2014/11/17/using-swift-with-objc-interoperability-x-working-with-cocoa-data-types</id>
    <content type="html"><![CDATA[<p>作为与ObjC互用性的一部分，Swift提供了方便和高效的方法来处理Cocoa的数据类型。</p>

<p>Swift自动的在Swift和ObjC之间互相转换一些类型。还有一些类型是Swift和ObjC通用的。这两种数据类型一般叫做桥接数据类型(bridged data types)。例如，我们可以把Array传递给一个需要NSArray的方法。我们也可以在桥接类型之间互相转换，用 as 或是直接给出变量或常量的值。</p>

<p>Swift也提供了一些方便的包裹来使得我们可以方便，统一和Foundation的数据类型交互。</p>

<!-- more -->


<h3>字符串</h3>

<p>Swift会自动在String和NSString之间转换。这意味着在任何时候你需要一个NSString的时候，你都可以直接给一个String。这样我们即可以使用Swift的字符串插入(string interpolation)，也可以使用Swift和NSString提供的众多API。所以，我们基本上不需要在我们的代码里使用NSString。事实上，当Swift导入ObjC的API时，它把所有的NSString都替换成了String，而当ObjC使用Swift时，所有的String都替换成了NSString。</p>

<p>要打开字符串桥接(bridging)，只需要导入Foundation。</p>

<pre><code class="swift">import Foundation
let greeting = "hello, world!"
let capitalizedGreeting = greeting.capitalizedString
// capitalizedGreeting: String = Hello, World!
</code></pre>

<p>如果我们确实需要使用NSString对象，我们可以把一个String转换到NSString。因为String和NSString总是可以互相转换，所以我们不需要使用 as?，而是直接使用 as。</p>

<pre><code class="swift">import Foundation
let myString: NSString = "123"
if let integerValue = (myString as String).toInt() {
    println("\(myString) is the integer \(integerValue)")
}
</code></pre>

<h4>本地化</h4>

<p>在ObjC里，我们使用NSLocalizedString系列的宏来本地化字符串。这一系列宏包括了NSLocalizedString，NSLocalizedStringFromTable，NSLocalizedStringFromTableInBundle，NSLocalizedStringWithDefaultValue。在Swift里，我们使用一个函数来处理所有这些：NSLocalizedString(key:tableName:bundle:value:comment:)。这个函数的tableName，bundle，value有默认值。</p>

<h3>数字</h3>

<p>Swift自动在特定的数字类型之间互相桥接。例如Int，Float和NSNumber。</p>

<pre><code class="swift">let n = 42
let m: NSNumber = n
</code></pre>

<p>我们也可以在需要NSNumber的地方传入一个Int。注意，因为NSNumber可以包含很多类型的值，所以我们不能随便传递其他类型的值。</p>

<p>下面的类型都会自动桥接到NSNumber：
    *   Int
    *   UInt
    *   Float
    *   Double
    *   Bool</p>

<h3>集合类</h3>

<p>Swift自动把NSArray和NSDictionary和他们Swift对应的相互转换。这样我们就即可以使用Swift的优秀算法和语法，也可以使用Foundation和Swift的集合互相交互。</p>

<h4>数组</h4>

<p>Swift自动在Array和NSArray之间互相转换。当我们把NSArray转换到Swift数组时，结果的类型是[AnyObject]。一个AnyObject的对象和OjbC或Swift的对象都兼容，或者可以被桥接到另外一个。我们可以把任何NSArray对象桥接到Swift数组，因为所有的ObjC对象都和AnyObject兼容。因为这个，所以Swift编译器在导入ObjC的API时会把所有NSArray替换成[AnyObject]。</p>

<p>在我们把NSArray桥接到Swift数组后，我们可以进一步把它向下转换到特定的类型。不像把NSArray转换到[AnyObject]，把AnyObject转换到特定类型不是一定成功的。编译器知道运行时才能确定数组里的元素是否能成功转换到特定类型。所以，把[AnyObject]转换到[SomeType]返回一个optional的值。</p>

<pre><code class="swift">let swiftArray = foundationArray as [AnyObject]
if let downcastedSwiftArray = swiftArray as? [UIView] {
    // downcastedSwiftArray contains only UIView objects
}
</code></pre>

<p>我们也可以在for-in循环里直接转换：</p>

<pre><code class="swift">for aView in foundationArray as [UIView] {
    // aView is of type UIView
}
</code></pre>

<pre><code>注意
这里是强制转换，如果不成功，会造成运行时错误。
</code></pre>

<p>当我们把一个Swift数组转换到NSArray时，Swift数组的元素必须是AnyObject兼容的类型。例如，一个数组[Int],包含Int，但是Int不是类，所以和AnyObject不兼容，但是，Int会自动桥接到NSNumber，所以最后Int是AnyObject兼容的。因此，我们可以把一个[Int]的数组转换到NSArray。如果一个Swift数组里的元素不是AnyObject兼容的，那么转换时会造成运行时错误。</p>

<p>我们也可以直接从Swift数组字面量来创建一个NSArray，这种方式也遵循上面的规则。</p>

<pre><code class="swift">let schoolSupplies: NSArray = ["Pencil", "Eraser", "Notebook"]
// schoolSupplies is an NSArray object containing NSString objects
</code></pre>

<p>当我们在ObjC中使用Swift的类或协议时，导入器会把所有的Swift数组类型转换到NSArray。如果给Swift的API提供了一个NSArray，但是元素类型不对，会造成运行时错误，如果一个Swift的API返回一个Swift的数组，却不能转换到NSArray，也会造成运行时错误。</p>

<h4>字典</h4>

<p>除了数组，Swift还会在Dictionary和NSDictionary之间互相转换。当我们把一个NSDictionary转换到Dictionary的时候，结果的类型是[NSObject: AnyObject]。我们可以把任何的NSDictionary转换到Dictionary，因为所有的ObjC的类都是AnyObject兼容的。注意，一个对象是AnyObject兼容的意思是他是一个ObjC或Swift的类，或者它可以被转到一个这样的。所有的NSDictionary都可以转到Dictionary，所以Swift编译器在导入ObjC的API时把所有的NSDictionary都转到了[NSObject: AnyObject]。相似的，当我们在ObjC中使用Swift的类或协议时，导入器也会把所有的Swift字典转换到NSDictionary。</p>

<p>在把一个NSDictionary转到到Swift的字典后，我们可以进一步向下转换到一个更具体的类型。就和向下转换数组一样，向下转换字典不保证一定成功。所以向下转换[NSObject: AnyObject]返回的时一个optional。</p>

<p>当我们做反向转换时，就是把Swift转到ObjC。key和value都必须是类的实例，或是可以转到一个类的实例。</p>

<p>我们也可以使用Swift的字典字面量来创建NSDctionary，和上面的规则一样。</p>

<h3>Foundation数据类型</h3>

<p>Swift定义了一个方便的封装让我们来使用Foundation的数据类型。我们使用这一层封装来使用类似于NSSize和NSPoint的类型，语法和Swift其他部分的语法自然且统一。</p>

<pre><code class="swift">let size = NSSize(width: 20, height: 40)
</code></pre>

<p>这层封装让我们调用方法也很自然：</p>

<pre><code class="swift">let rect = CGRect(x: 50, y: 50, width: 100, height: 100)
let width = rect.width    // equivalent of CGRectGetWidth(rect)
let maxY = rect.maxY      // equivalent of CGRectGetMaxY(rect)
</code></pre>

<p>Swift把NSUInteger和NSInteger都转到Int。Foundation里的这两个类型都转到了Int。在Swift里使用Int是保持一致性，但是需要的时候我们也可以用UInt。</p>

<h3>Foundation函数</h3>

<p>NSLog函数在Swift依然可用，打印到系统console。</p>

<pre><code class="swift">NSLog("%.7f",pi)
</code></pre>

<p>Swift也还有print和println函数。这些函数也很简单，强大，而且因为Swift的字符串插入而更通用。他们不会打印到系统的console但是可以用于更通用的打印需求。</p>

<p>NSAssert，在Swift不能使用，相反，我们使用assert函数。</p>

<h3>Core Foundation</h3>

<p>Core Foundation类型会被自动导入为完整的Swift类。由于内存管理注解已经给出，Swift会自动管理Core Foundation的对象的内存，包括我们自己创建的Core Foundation对象。在Swift里，我们可以使用Foundation和Core Foundation互相桥接的对象。我们也可以把Core Foundation的一些对象先转换到Foundation对象，再转换到Swift标准库的对象。</p>

<h4>重新映射的类型</h4>

<p>当Swift导入Core Foundation的对象的时候，编译器会重新映射他们的名字。编译器去掉了名字后面的Ref，因为Swift类本来就是引用类型。</p>

<p>Core Foundation的CFTypeRef完全的被重新映射到AnyObject。所有我们使用CFTypeRef的地方，我们都应该使用AnyObject。</p>

<h4>内存被管理的对象</h4>

<p>从有注解的API返回的Core Foundation对象的内存由Swift管理，我们不需要去调用CFRetain，CFRealease或者CFAutorelease。如果我们自己的C函数或ObjC方法放回了Core Foundation对象，我们必须要函数或方法注解为CF_RETURNS_RETAINED或者CF_RETURNS_NOT_RETAINED。这样，编译器就能自动为我们插入正确的内存管理函数。如果我们仅仅使用有注解的API，那下面的部分就可以略过，否则，我们需要继续学习内存未被管理的对象。</p>

<h4>内存未被管理的对象</h4>

<p>当Swift导入的API没有被注解，那么编译器就无法插入正确的内存管理代码。Swift会把这些返回的Core Foundation对象封装到一个Unmanaged<T>的结构体。所有的非直接返回Core Foundation对象的也都是内存未被管理的。</p>

<pre><code class="swift">//ObjC
CFStringRef StringByAddingTwoStrings(CFStringRef string1, CFStringRef string2)
</code></pre>

<p>Swift会把它导入为：</p>

<pre><code class="swift">func StringByAddingTwoStrings(CFString!, CFString!) -&gt; Unmanaged&lt;CFString&gt;!
</code></pre>

<p>当我们碰到了一个内存尾部管理的对象，我们在使用之前应该把它转换为内存被管理的对象。这样，我们就不用管理内存了。Unmanaged<T>有两个方法来把未被管理的对象转换到被管理的对象takeUnretainedValue()和takeRetainedValue()。两个方法都返回了原始的对象，我们根据我们调用的API是否返回一个unretained或是retained的对象。</p>

<p>假设上面的例子里的函数在返回时没有retain返回值。在使用之前，我们就该调用takeUnretainedValue()来拿到原始值。</p>

<pre><code class="swift">let memoryManagedResult = StringByAddingTwoStrings(str1, str2).takeUnretainedValue()
// memoryManagedResult is a memory managed CFString
</code></pre>

<p>我们也可以在一个内存未被管理的对象上调用retain()，release()，autorealease()，但是这样并不推荐。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using Swift with Cocoa and Objective-C: Interoperability-Writing Swift Classes with ObjC Behavior]]></title>
    <link href="http://zxhfirefox.github.io/blog/2014/11/17/using-swift-with-objc-interoperability-writing-swift-class-with-objc-behavior/"/>
    <updated>2014-11-17T23:16:04+08:00</updated>
    <id>http://zxhfirefox.github.io/blog/2014/11/17/using-swift-with-objc-interoperability-writing-swift-class-with-objc-behavior</id>
    <content type="html"><![CDATA[<p>互用性(Interoperability)让我们可以定义包含ObjC行为的Swift类。我们在定义Swift类时，可以继承ObjC的类，可以实现ObjC的协议，可以使用ObjC其他的功能。这意味着我们可以以类为基础来创建ObjC行为相似的类，并且使用Swift现代的，强大的特性来加强我们的类。</p>

<!-- more -->


<h3>从ObjC的类继承</h3>

<p>在Swift里，我们可以定义ObjC类的子类。</p>

<pre><code class="swift">import UIKit
class MySwiftViewController: UIViewController {
    // define the class
}
</code></pre>

<p>我们将获得父类所有的功能。但是当我们需要重写父类的方法时，记得添加override。</p>

<h3>实现协议</h3>

<p>在Swift里，我们可以实现定义在ObjC的协议。和Swift协议一样，任何的ObjC的协议都写在父类的列表里，用逗号隔开。</p>

<pre><code class="swift">class MySwiftViewController: UIViewController, UITableViewDelegate, UITableViewDataSource {
    // define the class
}
</code></pre>

<p>ObjC的协议在导入Swift时，会变成Swift的协议。如果我们想在Swift代码里引用协议UITableViewDelegate，我们直接写成UITableViewDelegate，而不是像ObjC写成id<UITableViewDelegate> 。</p>

<p>因为Swift里的类和协议的命名空间是统一的，所以ObjC的NSObject协议对应到Swift变成了NSObjectProtocol。</p>

<h3>写初始化函数和反初始化函数</h3>

<p>Swift编译器确保我们的初始化函数不会留下未初始化的属性，这样增加了代码的安全性和可预判性(predictability)。另外，和ObjC不一样，Swift没有额外的内存分配调用。即使我们在使用ObjC类型，我们也使用Swift的语法来创建对象，Swift会把ObjC的初始化函数转化为Swift的初始化函数。</p>

<p>当我们需要在类实例被销毁时想执行更多的清理工作，我们实现deinit而不是dealloc方法。Swift反初始化会在对象被销毁前自动调用。Swift在结束我们本身的反初始化函数后也会自动调用父类反初始化函数。当我们使用ObjC的类，或是我们继承自ObjC的类，Swift也会自动调用对应的dealloc方法。</p>

<h3>整合 InterfaceBuilder</h3>

<p>Swift编译器包含了一些标记可以在Swift类里打开IB的特性。我们可以像在ObjC中一样，在Swift里使用outlet，action和实施渲染(live rendering)。</p>

<h4>使用 Outlet 和 Action</h4>

<p>Outlet和Action让我们在IB里可以把界面元素和我们的代码连结起来。我们需要在属性和方法前面加上 @IBOutlet 和 @IBAction来使用。我们在数组前面标记 @IBOutlet来声明一个outlet集合(outlet collection)。</p>

<p>当我们在Swift声明outlet时，我们应该把属性的类型声明为自动解包的optional。这样，我们就可以让故事板(storyboard)来在运行时连接这些outlet。当我们的类从故事版或xib初始化时，我们可以认为属性已经连接好的。</p>

<pre><code class="swift">class MyViewController: UIViewController {
    @IBOutlet weak var button: UIButton!
    @IBOutlet var textFields: [UITextField]!
    @IBAction func buttonTapped(AnyObject) {
        println("button tapped!")
    }
}
</code></pre>

<h4>实时渲染</h4>

<p>我们可以使用 @IBDesignable 和 @IBInspectable 来在IB里打开实时，交互的视图设计。当我们从UIView或者NSView继承时，我们可以把子类标记为@ IBDesignable。这样，当我们在IB中加入自定义的类时，IB会把我们类渲染出来。</p>

<p>我们也可以在属性前面添加@IBInspectable来让我们在IB设计界面时，可以实时调整这些属性的值。</p>

<pre><code class="swift">@IBDesignable
class MyCustomView: UIView {
    @IBInspectable var textColor: UIColor
    @IBInspectable var iconHeight: CGFloat
    /* ... */
}
</code></pre>

<h3>明确属性(Property)特性(Attribute)</h3>

<p>在ObjC里，属性可以有一系列的特性来给出关于属性的额外信息。在Swift，这些信息需要用其他方式给出。</p>

<h4>强引用和弱引用</h4>

<p>Swift默认提供强引用，用weak关键字来说明弱引用。这个关键字只能用于那些类型是optional的类的属性。</p>

<h4>读写和只读</h4>

<p>在Swift里，我们没有readwrite和readonly特性，我们用let来表示只读，用var来表示可读可写。当声明计算属性时，我们如果只给出getter，那就是只读，如果给出了getter和setter，那就是可读可写。</p>

<h4>拷贝</h4>

<p>在Swift里，ObjC的copy属性特性被翻译为了@NSCopying。这个属性的类型必须实现NSCopying协议。</p>

<h3>实现 Core Data 的管理对象(Managed Object)的子类</h3>

<p>Core Data为 NSManagedObject 的子类的属性提供了底层存储和实现。我们需要在我们的管理对象(Managed Object)的子类的每一个属性或是每一个关系前加 @NSManaged标记。它和Objc的@dynamic一样，告诉Swift编译器这些属性的存储和实现会在运行时给出。然而，和@dynamic不一样，@NSManaged只给Core Data提供支持。</p>

<p>Swift类是有命名空间的，就是他们的模块，一般就是所在的项目。我们在使用NSManagedObject的Swift子类和Core Data模型时，需要在类名检查器前面加上模块的名字。</p>

<h3>和ObjC的API一起使用Swift的类名</h3>

<p>Swift的类有基于他们编译进的模块的命名空间，即使是在ObjC里使用的时候。和ObjC不同，ObjC的所有的名字都在一个全局的命名空间里，所以不能有重名，Swift的类可以在不同的模块里有相同的名字，而不会造成混淆。例如，在Swift里MyFramework的MyClass的全称是MyFramework. MyClass。一个Swift的app的目标就是模块，所以一个app名叫MyGreatApp里的一个名叫Observer的类的全名叫MyGreatApp.Observer。</p>

<p>为了在ObjC中使用Swift类时保留命名空间，Swift类在暴露给ObjC时暴露的全名。因此，当我们使用字符串表示Swift类名的时候，我们必须给出全名。例如，我们在做一个基于文档的app，我们需要在Info.plist里给出文档类的名字。在Swift里，我们必须使用全名，包括app的模块名字。</p>

<p>下面的例子，NSClassFromString通过一个字符串来获取一个类的引用。如果要得到一个Swift类，必须给出全名。</p>

<pre><code class="swift">let myPersonClass: AnyClass = NSClassFromString("MyGreatApp.Person")
</code></pre>
]]></content>
  </entry>
  
</feed>
